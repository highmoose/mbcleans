/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/js-beautify";
exports.ids = ["vendor-chunks/js-beautify"];
exports.modules = {

/***/ "(rsc)/./node_modules/js-beautify/js/index.js":
/*!**********************************************!*\
  !*** ./node_modules/js-beautify/js/index.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*jshint node:true */ /* globals define */ /*\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n\n*/ \n/**\nThe following batches are equivalent:\n\nvar beautify_js = require('js-beautify');\nvar beautify_js = require('js-beautify').js;\nvar beautify_js = require('js-beautify').js_beautify;\n\nvar beautify_css = require('js-beautify').css;\nvar beautify_css = require('js-beautify').css_beautify;\n\nvar beautify_html = require('js-beautify').html;\nvar beautify_html = require('js-beautify').html_beautify;\n\nAll methods returned accept two arguments, the source string and an options object.\n**/ function get_beautify(js_beautify, css_beautify, html_beautify) {\n    // the default is js\n    var beautify = function(src, config) {\n        return js_beautify.js_beautify(src, config);\n    };\n    // short aliases\n    beautify.js = js_beautify.js_beautify;\n    beautify.css = css_beautify.css_beautify;\n    beautify.html = html_beautify.html_beautify;\n    // legacy aliases\n    beautify.js_beautify = js_beautify.js_beautify;\n    beautify.css_beautify = css_beautify.css_beautify;\n    beautify.html_beautify = html_beautify.html_beautify;\n    return beautify;\n}\nif (true) {\n    // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n        __webpack_require__(/*! ./lib/beautify */ \"(rsc)/./node_modules/js-beautify/js/lib/beautify.js\"),\n        __webpack_require__(/*! ./lib/beautify-css */ \"(rsc)/./node_modules/js-beautify/js/lib/beautify-css.js\"),\n        __webpack_require__(/*! ./lib/beautify-html */ \"(rsc)/./node_modules/js-beautify/js/lib/beautify-html.js\")\n    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(js_beautify, css_beautify, html_beautify) {\n        return get_beautify(js_beautify, css_beautify, html_beautify);\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanMtYmVhdXRpZnkvanMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsbUZBQW1CLEdBQ25CLGtCQUFrQixHQUNsQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQSxHQUVBO0FBRUE7Ozs7Ozs7Ozs7Ozs7O0NBY0MsR0FFRCxTQUFTQSxhQUFhQyxXQUFXLEVBQUVDLFlBQVksRUFBRUMsYUFBYTtJQUM1RCxvQkFBb0I7SUFDcEIsSUFBSUMsV0FBVyxTQUFTQyxHQUFHLEVBQUVDLE1BQU07UUFDakMsT0FBT0wsWUFBWUEsV0FBVyxDQUFDSSxLQUFLQztJQUN0QztJQUVBLGdCQUFnQjtJQUNoQkYsU0FBU0csRUFBRSxHQUFHTixZQUFZQSxXQUFXO0lBQ3JDRyxTQUFTSSxHQUFHLEdBQUdOLGFBQWFBLFlBQVk7SUFDeENFLFNBQVNLLElBQUksR0FBR04sY0FBY0EsYUFBYTtJQUUzQyxpQkFBaUI7SUFDakJDLFNBQVNILFdBQVcsR0FBR0EsWUFBWUEsV0FBVztJQUM5Q0csU0FBU0YsWUFBWSxHQUFHQSxhQUFhQSxZQUFZO0lBQ2pERSxTQUFTRCxhQUFhLEdBQUdBLGNBQWNBLGFBQWE7SUFFcEQsT0FBT0M7QUFDVDtBQUVBLElBQUksSUFBMEMsRUFBRTtJQUM5QywwRkFBMEY7SUFDMUZNLGlDQUFPO1FBQ0wsZ0dBQWdCO1FBQ2hCLHdHQUFvQjtRQUNwQiwwR0FBcUI7S0FDdEIsbUNBQUUsU0FBU1QsV0FBVyxFQUFFQyxZQUFZLEVBQUVDLGFBQWE7UUFDbEQsT0FBT0gsYUFBYUMsYUFBYUMsY0FBY0M7SUFDakQsQ0FBQztBQUFBLGtHQUFDO0FBQ0osT0FBTyxFQVVOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWJjbGVhbnMvLi9ub2RlX21vZHVsZXMvanMtYmVhdXRpZnkvanMvaW5kZXguanM/MWNhOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKmpzaGludCBub2RlOnRydWUgKi9cbi8qIGdsb2JhbHMgZGVmaW5lICovXG4vKlxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG5UaGUgZm9sbG93aW5nIGJhdGNoZXMgYXJlIGVxdWl2YWxlbnQ6XG5cbnZhciBiZWF1dGlmeV9qcyA9IHJlcXVpcmUoJ2pzLWJlYXV0aWZ5Jyk7XG52YXIgYmVhdXRpZnlfanMgPSByZXF1aXJlKCdqcy1iZWF1dGlmeScpLmpzO1xudmFyIGJlYXV0aWZ5X2pzID0gcmVxdWlyZSgnanMtYmVhdXRpZnknKS5qc19iZWF1dGlmeTtcblxudmFyIGJlYXV0aWZ5X2NzcyA9IHJlcXVpcmUoJ2pzLWJlYXV0aWZ5JykuY3NzO1xudmFyIGJlYXV0aWZ5X2NzcyA9IHJlcXVpcmUoJ2pzLWJlYXV0aWZ5JykuY3NzX2JlYXV0aWZ5O1xuXG52YXIgYmVhdXRpZnlfaHRtbCA9IHJlcXVpcmUoJ2pzLWJlYXV0aWZ5JykuaHRtbDtcbnZhciBiZWF1dGlmeV9odG1sID0gcmVxdWlyZSgnanMtYmVhdXRpZnknKS5odG1sX2JlYXV0aWZ5O1xuXG5BbGwgbWV0aG9kcyByZXR1cm5lZCBhY2NlcHQgdHdvIGFyZ3VtZW50cywgdGhlIHNvdXJjZSBzdHJpbmcgYW5kIGFuIG9wdGlvbnMgb2JqZWN0LlxuKiovXG5cbmZ1bmN0aW9uIGdldF9iZWF1dGlmeShqc19iZWF1dGlmeSwgY3NzX2JlYXV0aWZ5LCBodG1sX2JlYXV0aWZ5KSB7XG4gIC8vIHRoZSBkZWZhdWx0IGlzIGpzXG4gIHZhciBiZWF1dGlmeSA9IGZ1bmN0aW9uKHNyYywgY29uZmlnKSB7XG4gICAgcmV0dXJuIGpzX2JlYXV0aWZ5LmpzX2JlYXV0aWZ5KHNyYywgY29uZmlnKTtcbiAgfTtcblxuICAvLyBzaG9ydCBhbGlhc2VzXG4gIGJlYXV0aWZ5LmpzID0ganNfYmVhdXRpZnkuanNfYmVhdXRpZnk7XG4gIGJlYXV0aWZ5LmNzcyA9IGNzc19iZWF1dGlmeS5jc3NfYmVhdXRpZnk7XG4gIGJlYXV0aWZ5Lmh0bWwgPSBodG1sX2JlYXV0aWZ5Lmh0bWxfYmVhdXRpZnk7XG5cbiAgLy8gbGVnYWN5IGFsaWFzZXNcbiAgYmVhdXRpZnkuanNfYmVhdXRpZnkgPSBqc19iZWF1dGlmeS5qc19iZWF1dGlmeTtcbiAgYmVhdXRpZnkuY3NzX2JlYXV0aWZ5ID0gY3NzX2JlYXV0aWZ5LmNzc19iZWF1dGlmeTtcbiAgYmVhdXRpZnkuaHRtbF9iZWF1dGlmeSA9IGh0bWxfYmVhdXRpZnkuaHRtbF9iZWF1dGlmeTtcblxuICByZXR1cm4gYmVhdXRpZnk7XG59XG5cbmlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAvLyBBZGQgc3VwcG9ydCBmb3IgQU1EICggaHR0cHM6Ly9naXRodWIuY29tL2FtZGpzL2FtZGpzLWFwaS93aWtpL0FNRCNkZWZpbmVhbWQtcHJvcGVydHktIClcbiAgZGVmaW5lKFtcbiAgICBcIi4vbGliL2JlYXV0aWZ5XCIsXG4gICAgXCIuL2xpYi9iZWF1dGlmeS1jc3NcIixcbiAgICBcIi4vbGliL2JlYXV0aWZ5LWh0bWxcIlxuICBdLCBmdW5jdGlvbihqc19iZWF1dGlmeSwgY3NzX2JlYXV0aWZ5LCBodG1sX2JlYXV0aWZ5KSB7XG4gICAgcmV0dXJuIGdldF9iZWF1dGlmeShqc19iZWF1dGlmeSwgY3NzX2JlYXV0aWZ5LCBodG1sX2JlYXV0aWZ5KTtcbiAgfSk7XG59IGVsc2Uge1xuICAoZnVuY3Rpb24obW9kKSB7XG4gICAgdmFyIGJlYXV0aWZpZXIgPSByZXF1aXJlKCcuL3NyYy9pbmRleCcpO1xuICAgIGJlYXV0aWZpZXIuanNfYmVhdXRpZnkgPSBiZWF1dGlmaWVyLmpzO1xuICAgIGJlYXV0aWZpZXIuY3NzX2JlYXV0aWZ5ID0gYmVhdXRpZmllci5jc3M7XG4gICAgYmVhdXRpZmllci5odG1sX2JlYXV0aWZ5ID0gYmVhdXRpZmllci5odG1sO1xuXG4gICAgbW9kLmV4cG9ydHMgPSBnZXRfYmVhdXRpZnkoYmVhdXRpZmllciwgYmVhdXRpZmllciwgYmVhdXRpZmllcik7XG5cbiAgfSkobW9kdWxlKTtcbn0iXSwibmFtZXMiOlsiZ2V0X2JlYXV0aWZ5IiwianNfYmVhdXRpZnkiLCJjc3NfYmVhdXRpZnkiLCJodG1sX2JlYXV0aWZ5IiwiYmVhdXRpZnkiLCJzcmMiLCJjb25maWciLCJqcyIsImNzcyIsImh0bWwiLCJkZWZpbmUiLCJhbWQiLCJtb2QiLCJiZWF1dGlmaWVyIiwicmVxdWlyZSIsImV4cG9ydHMiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/js-beautify/js/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/js-beautify/js/lib/beautify-css.js":
/*!*********************************************************!*\
  !*** ./node_modules/js-beautify/js/lib/beautify-css.js ***!
  \*********************************************************/
/***/ ((module, exports) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* AUTO-GENERATED. DO NOT MODIFY. */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n\n\n CSS Beautifier\n---------------\n\n    Written by Harutyun Amirjanyan, (amirjanyan@gmail.com)\n\n    Based on code initially developed by: Einar Lielmanis, <einar@beautifier.io>\n        https://beautifier.io/\n\n    Usage:\n        css_beautify(source_text);\n        css_beautify(source_text, options);\n\n    The options are (default in brackets):\n        indent_size (4)                         — indentation size,\n        indent_char (space)                     — character to indent with,\n        selector_separator_newline (true)       - separate selectors with newline or\n                                                  not (e.g. \"a,\\nbr\" or \"a, br\")\n        end_with_newline (false)                - end with a newline\n        newline_between_rules (true)            - add a new line after every css rule\n        space_around_selector_separator (false) - ensure space around selector separators:\n                                                  '>', '+', '~' (e.g. \"a>b\" -> \"a > b\")\n    e.g\n\n    css_beautify(css_source_text, {\n      'indent_size': 1,\n      'indent_char': '\\t',\n      'selector_separator': ' ',\n      'end_with_newline': false,\n      'newline_between_rules': true,\n      'space_around_selector_separator': true\n    });\n*/ // http://www.w3.org/TR/CSS21/syndata.html#tokenization\n// http://www.w3.org/TR/css3-syntax/\n(function() {\n    /* GENERATED_BUILD_OUTPUT */ var legacy_beautify_css;\n    /******/ (function() {\n        /******/ \"use strict\";\n        /******/ var __webpack_modules__ = [\n            ,\n            ,\n            /* 2 */ /***/ function(module) {\n                /*jshint node:true */ /*\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ function OutputLine(parent) {\n                    this.__parent = parent;\n                    this.__character_count = 0;\n                    // use indent_count as a marker for this.__lines that have preserved indentation\n                    this.__indent_count = -1;\n                    this.__alignment_count = 0;\n                    this.__wrap_point_index = 0;\n                    this.__wrap_point_character_count = 0;\n                    this.__wrap_point_indent_count = -1;\n                    this.__wrap_point_alignment_count = 0;\n                    this.__items = [];\n                }\n                OutputLine.prototype.clone_empty = function() {\n                    var line = new OutputLine(this.__parent);\n                    line.set_indent(this.__indent_count, this.__alignment_count);\n                    return line;\n                };\n                OutputLine.prototype.item = function(index) {\n                    if (index < 0) {\n                        return this.__items[this.__items.length + index];\n                    } else {\n                        return this.__items[index];\n                    }\n                };\n                OutputLine.prototype.has_match = function(pattern) {\n                    for(var lastCheckedOutput = this.__items.length - 1; lastCheckedOutput >= 0; lastCheckedOutput--){\n                        if (this.__items[lastCheckedOutput].match(pattern)) {\n                            return true;\n                        }\n                    }\n                    return false;\n                };\n                OutputLine.prototype.set_indent = function(indent, alignment) {\n                    if (this.is_empty()) {\n                        this.__indent_count = indent || 0;\n                        this.__alignment_count = alignment || 0;\n                        this.__character_count = this.__parent.get_indent_size(this.__indent_count, this.__alignment_count);\n                    }\n                };\n                OutputLine.prototype._set_wrap_point = function() {\n                    if (this.__parent.wrap_line_length) {\n                        this.__wrap_point_index = this.__items.length;\n                        this.__wrap_point_character_count = this.__character_count;\n                        this.__wrap_point_indent_count = this.__parent.next_line.__indent_count;\n                        this.__wrap_point_alignment_count = this.__parent.next_line.__alignment_count;\n                    }\n                };\n                OutputLine.prototype._should_wrap = function() {\n                    return this.__wrap_point_index && this.__character_count > this.__parent.wrap_line_length && this.__wrap_point_character_count > this.__parent.next_line.__character_count;\n                };\n                OutputLine.prototype._allow_wrap = function() {\n                    if (this._should_wrap()) {\n                        this.__parent.add_new_line();\n                        var next = this.__parent.current_line;\n                        next.set_indent(this.__wrap_point_indent_count, this.__wrap_point_alignment_count);\n                        next.__items = this.__items.slice(this.__wrap_point_index);\n                        this.__items = this.__items.slice(0, this.__wrap_point_index);\n                        next.__character_count += this.__character_count - this.__wrap_point_character_count;\n                        this.__character_count = this.__wrap_point_character_count;\n                        if (next.__items[0] === \" \") {\n                            next.__items.splice(0, 1);\n                            next.__character_count -= 1;\n                        }\n                        return true;\n                    }\n                    return false;\n                };\n                OutputLine.prototype.is_empty = function() {\n                    return this.__items.length === 0;\n                };\n                OutputLine.prototype.last = function() {\n                    if (!this.is_empty()) {\n                        return this.__items[this.__items.length - 1];\n                    } else {\n                        return null;\n                    }\n                };\n                OutputLine.prototype.push = function(item) {\n                    this.__items.push(item);\n                    var last_newline_index = item.lastIndexOf(\"\\n\");\n                    if (last_newline_index !== -1) {\n                        this.__character_count = item.length - last_newline_index;\n                    } else {\n                        this.__character_count += item.length;\n                    }\n                };\n                OutputLine.prototype.pop = function() {\n                    var item = null;\n                    if (!this.is_empty()) {\n                        item = this.__items.pop();\n                        this.__character_count -= item.length;\n                    }\n                    return item;\n                };\n                OutputLine.prototype._remove_indent = function() {\n                    if (this.__indent_count > 0) {\n                        this.__indent_count -= 1;\n                        this.__character_count -= this.__parent.indent_size;\n                    }\n                };\n                OutputLine.prototype._remove_wrap_indent = function() {\n                    if (this.__wrap_point_indent_count > 0) {\n                        this.__wrap_point_indent_count -= 1;\n                    }\n                };\n                OutputLine.prototype.trim = function() {\n                    while(this.last() === \" \"){\n                        this.__items.pop();\n                        this.__character_count -= 1;\n                    }\n                };\n                OutputLine.prototype.toString = function() {\n                    var result = \"\";\n                    if (this.is_empty()) {\n                        if (this.__parent.indent_empty_lines) {\n                            result = this.__parent.get_indent_string(this.__indent_count);\n                        }\n                    } else {\n                        result = this.__parent.get_indent_string(this.__indent_count, this.__alignment_count);\n                        result += this.__items.join(\"\");\n                    }\n                    return result;\n                };\n                function IndentStringCache(options, baseIndentString) {\n                    this.__cache = [\n                        \"\"\n                    ];\n                    this.__indent_size = options.indent_size;\n                    this.__indent_string = options.indent_char;\n                    if (!options.indent_with_tabs) {\n                        this.__indent_string = new Array(options.indent_size + 1).join(options.indent_char);\n                    }\n                    // Set to null to continue support for auto detection of base indent\n                    baseIndentString = baseIndentString || \"\";\n                    if (options.indent_level > 0) {\n                        baseIndentString = new Array(options.indent_level + 1).join(this.__indent_string);\n                    }\n                    this.__base_string = baseIndentString;\n                    this.__base_string_length = baseIndentString.length;\n                }\n                IndentStringCache.prototype.get_indent_size = function(indent, column) {\n                    var result = this.__base_string_length;\n                    column = column || 0;\n                    if (indent < 0) {\n                        result = 0;\n                    }\n                    result += indent * this.__indent_size;\n                    result += column;\n                    return result;\n                };\n                IndentStringCache.prototype.get_indent_string = function(indent_level, column) {\n                    var result = this.__base_string;\n                    column = column || 0;\n                    if (indent_level < 0) {\n                        indent_level = 0;\n                        result = \"\";\n                    }\n                    column += indent_level * this.__indent_size;\n                    this.__ensure_cache(column);\n                    result += this.__cache[column];\n                    return result;\n                };\n                IndentStringCache.prototype.__ensure_cache = function(column) {\n                    while(column >= this.__cache.length){\n                        this.__add_column();\n                    }\n                };\n                IndentStringCache.prototype.__add_column = function() {\n                    var column = this.__cache.length;\n                    var indent = 0;\n                    var result = \"\";\n                    if (this.__indent_size && column >= this.__indent_size) {\n                        indent = Math.floor(column / this.__indent_size);\n                        column -= indent * this.__indent_size;\n                        result = new Array(indent + 1).join(this.__indent_string);\n                    }\n                    if (column) {\n                        result += new Array(column + 1).join(\" \");\n                    }\n                    this.__cache.push(result);\n                };\n                function Output(options, baseIndentString) {\n                    this.__indent_cache = new IndentStringCache(options, baseIndentString);\n                    this.raw = false;\n                    this._end_with_newline = options.end_with_newline;\n                    this.indent_size = options.indent_size;\n                    this.wrap_line_length = options.wrap_line_length;\n                    this.indent_empty_lines = options.indent_empty_lines;\n                    this.__lines = [];\n                    this.previous_line = null;\n                    this.current_line = null;\n                    this.next_line = new OutputLine(this);\n                    this.space_before_token = false;\n                    this.non_breaking_space = false;\n                    this.previous_token_wrapped = false;\n                    // initialize\n                    this.__add_outputline();\n                }\n                Output.prototype.__add_outputline = function() {\n                    this.previous_line = this.current_line;\n                    this.current_line = this.next_line.clone_empty();\n                    this.__lines.push(this.current_line);\n                };\n                Output.prototype.get_line_number = function() {\n                    return this.__lines.length;\n                };\n                Output.prototype.get_indent_string = function(indent, column) {\n                    return this.__indent_cache.get_indent_string(indent, column);\n                };\n                Output.prototype.get_indent_size = function(indent, column) {\n                    return this.__indent_cache.get_indent_size(indent, column);\n                };\n                Output.prototype.is_empty = function() {\n                    return !this.previous_line && this.current_line.is_empty();\n                };\n                Output.prototype.add_new_line = function(force_newline) {\n                    // never newline at the start of file\n                    // otherwise, newline only if we didn't just add one or we're forced\n                    if (this.is_empty() || !force_newline && this.just_added_newline()) {\n                        return false;\n                    }\n                    // if raw output is enabled, don't print additional newlines,\n                    // but still return True as though you had\n                    if (!this.raw) {\n                        this.__add_outputline();\n                    }\n                    return true;\n                };\n                Output.prototype.get_code = function(eol) {\n                    this.trim(true);\n                    // handle some edge cases where the last tokens\n                    // has text that ends with newline(s)\n                    var last_item = this.current_line.pop();\n                    if (last_item) {\n                        if (last_item[last_item.length - 1] === \"\\n\") {\n                            last_item = last_item.replace(/\\n+$/g, \"\");\n                        }\n                        this.current_line.push(last_item);\n                    }\n                    if (this._end_with_newline) {\n                        this.__add_outputline();\n                    }\n                    var sweet_code = this.__lines.join(\"\\n\");\n                    if (eol !== \"\\n\") {\n                        sweet_code = sweet_code.replace(/[\\n]/g, eol);\n                    }\n                    return sweet_code;\n                };\n                Output.prototype.set_wrap_point = function() {\n                    this.current_line._set_wrap_point();\n                };\n                Output.prototype.set_indent = function(indent, alignment) {\n                    indent = indent || 0;\n                    alignment = alignment || 0;\n                    // Next line stores alignment values\n                    this.next_line.set_indent(indent, alignment);\n                    // Never indent your first output indent at the start of the file\n                    if (this.__lines.length > 1) {\n                        this.current_line.set_indent(indent, alignment);\n                        return true;\n                    }\n                    this.current_line.set_indent();\n                    return false;\n                };\n                Output.prototype.add_raw_token = function(token) {\n                    for(var x = 0; x < token.newlines; x++){\n                        this.__add_outputline();\n                    }\n                    this.current_line.set_indent(-1);\n                    this.current_line.push(token.whitespace_before);\n                    this.current_line.push(token.text);\n                    this.space_before_token = false;\n                    this.non_breaking_space = false;\n                    this.previous_token_wrapped = false;\n                };\n                Output.prototype.add_token = function(printable_token) {\n                    this.__add_space_before_token();\n                    this.current_line.push(printable_token);\n                    this.space_before_token = false;\n                    this.non_breaking_space = false;\n                    this.previous_token_wrapped = this.current_line._allow_wrap();\n                };\n                Output.prototype.__add_space_before_token = function() {\n                    if (this.space_before_token && !this.just_added_newline()) {\n                        if (!this.non_breaking_space) {\n                            this.set_wrap_point();\n                        }\n                        this.current_line.push(\" \");\n                    }\n                };\n                Output.prototype.remove_indent = function(index) {\n                    var output_length = this.__lines.length;\n                    while(index < output_length){\n                        this.__lines[index]._remove_indent();\n                        index++;\n                    }\n                    this.current_line._remove_wrap_indent();\n                };\n                Output.prototype.trim = function(eat_newlines) {\n                    eat_newlines = eat_newlines === undefined ? false : eat_newlines;\n                    this.current_line.trim();\n                    while(eat_newlines && this.__lines.length > 1 && this.current_line.is_empty()){\n                        this.__lines.pop();\n                        this.current_line = this.__lines[this.__lines.length - 1];\n                        this.current_line.trim();\n                    }\n                    this.previous_line = this.__lines.length > 1 ? this.__lines[this.__lines.length - 2] : null;\n                };\n                Output.prototype.just_added_newline = function() {\n                    return this.current_line.is_empty();\n                };\n                Output.prototype.just_added_blankline = function() {\n                    return this.is_empty() || this.current_line.is_empty() && this.previous_line.is_empty();\n                };\n                Output.prototype.ensure_empty_line_above = function(starts_with, ends_with) {\n                    var index = this.__lines.length - 2;\n                    while(index >= 0){\n                        var potentialEmptyLine = this.__lines[index];\n                        if (potentialEmptyLine.is_empty()) {\n                            break;\n                        } else if (potentialEmptyLine.item(0).indexOf(starts_with) !== 0 && potentialEmptyLine.item(-1) !== ends_with) {\n                            this.__lines.splice(index + 1, 0, new OutputLine(this));\n                            this.previous_line = this.__lines[this.__lines.length - 2];\n                            break;\n                        }\n                        index--;\n                    }\n                };\n                module.exports.Output = Output;\n            /***/ },\n            ,\n            ,\n            ,\n            /* 6 */ /***/ function(module) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ function Options(options, merge_child_field) {\n                    this.raw_options = _mergeOpts(options, merge_child_field);\n                    // Support passing the source text back with no change\n                    this.disabled = this._get_boolean(\"disabled\");\n                    this.eol = this._get_characters(\"eol\", \"auto\");\n                    this.end_with_newline = this._get_boolean(\"end_with_newline\");\n                    this.indent_size = this._get_number(\"indent_size\", 4);\n                    this.indent_char = this._get_characters(\"indent_char\", \" \");\n                    this.indent_level = this._get_number(\"indent_level\");\n                    this.preserve_newlines = this._get_boolean(\"preserve_newlines\", true);\n                    this.max_preserve_newlines = this._get_number(\"max_preserve_newlines\", 32786);\n                    if (!this.preserve_newlines) {\n                        this.max_preserve_newlines = 0;\n                    }\n                    this.indent_with_tabs = this._get_boolean(\"indent_with_tabs\", this.indent_char === \"\t\");\n                    if (this.indent_with_tabs) {\n                        this.indent_char = \"\t\";\n                        // indent_size behavior changed after 1.8.6\n                        // It used to be that indent_size would be\n                        // set to 1 for indent_with_tabs. That is no longer needed and\n                        // actually doesn't make sense - why not use spaces? Further,\n                        // that might produce unexpected behavior - tabs being used\n                        // for single-column alignment. So, when indent_with_tabs is true\n                        // and indent_size is 1, reset indent_size to 4.\n                        if (this.indent_size === 1) {\n                            this.indent_size = 4;\n                        }\n                    }\n                    // Backwards compat with 1.3.x\n                    this.wrap_line_length = this._get_number(\"wrap_line_length\", this._get_number(\"max_char\"));\n                    this.indent_empty_lines = this._get_boolean(\"indent_empty_lines\");\n                    // valid templating languages ['django', 'erb', 'handlebars', 'php', 'smarty', 'angular']\n                    // For now, 'auto' = all off for javascript, all except angular on for html (and inline javascript/css).\n                    // other values ignored\n                    this.templating = this._get_selection_list(\"templating\", [\n                        \"auto\",\n                        \"none\",\n                        \"angular\",\n                        \"django\",\n                        \"erb\",\n                        \"handlebars\",\n                        \"php\",\n                        \"smarty\"\n                    ], [\n                        \"auto\"\n                    ]);\n                }\n                Options.prototype._get_array = function(name, default_value) {\n                    var option_value = this.raw_options[name];\n                    var result = default_value || [];\n                    if (typeof option_value === \"object\") {\n                        if (option_value !== null && typeof option_value.concat === \"function\") {\n                            result = option_value.concat();\n                        }\n                    } else if (typeof option_value === \"string\") {\n                        result = option_value.split(/[^a-zA-Z0-9_\\/\\-]+/);\n                    }\n                    return result;\n                };\n                Options.prototype._get_boolean = function(name, default_value) {\n                    var option_value = this.raw_options[name];\n                    var result = option_value === undefined ? !!default_value : !!option_value;\n                    return result;\n                };\n                Options.prototype._get_characters = function(name, default_value) {\n                    var option_value = this.raw_options[name];\n                    var result = default_value || \"\";\n                    if (typeof option_value === \"string\") {\n                        result = option_value.replace(/\\\\r/, \"\\r\").replace(/\\\\n/, \"\\n\").replace(/\\\\t/, \"\t\");\n                    }\n                    return result;\n                };\n                Options.prototype._get_number = function(name, default_value) {\n                    var option_value = this.raw_options[name];\n                    default_value = parseInt(default_value, 10);\n                    if (isNaN(default_value)) {\n                        default_value = 0;\n                    }\n                    var result = parseInt(option_value, 10);\n                    if (isNaN(result)) {\n                        result = default_value;\n                    }\n                    return result;\n                };\n                Options.prototype._get_selection = function(name, selection_list, default_value) {\n                    var result = this._get_selection_list(name, selection_list, default_value);\n                    if (result.length !== 1) {\n                        throw new Error(\"Invalid Option Value: The option '\" + name + \"' can only be one of the following values:\\n\" + selection_list + \"\\nYou passed in: '\" + this.raw_options[name] + \"'\");\n                    }\n                    return result[0];\n                };\n                Options.prototype._get_selection_list = function(name, selection_list, default_value) {\n                    if (!selection_list || selection_list.length === 0) {\n                        throw new Error(\"Selection list cannot be empty.\");\n                    }\n                    default_value = default_value || [\n                        selection_list[0]\n                    ];\n                    if (!this._is_valid_selection(default_value, selection_list)) {\n                        throw new Error(\"Invalid Default Value!\");\n                    }\n                    var result = this._get_array(name, default_value);\n                    if (!this._is_valid_selection(result, selection_list)) {\n                        throw new Error(\"Invalid Option Value: The option '\" + name + \"' can contain only the following values:\\n\" + selection_list + \"\\nYou passed in: '\" + this.raw_options[name] + \"'\");\n                    }\n                    return result;\n                };\n                Options.prototype._is_valid_selection = function(result, selection_list) {\n                    return result.length && selection_list.length && !result.some(function(item) {\n                        return selection_list.indexOf(item) === -1;\n                    });\n                };\n                // merges child options up with the parent options object\n                // Example: obj = {a: 1, b: {a: 2}}\n                //          mergeOpts(obj, 'b')\n                //\n                //          Returns: {a: 2}\n                function _mergeOpts(allOptions, childFieldName) {\n                    var finalOpts = {};\n                    allOptions = _normalizeOpts(allOptions);\n                    var name;\n                    for(name in allOptions){\n                        if (name !== childFieldName) {\n                            finalOpts[name] = allOptions[name];\n                        }\n                    }\n                    //merge in the per type settings for the childFieldName\n                    if (childFieldName && allOptions[childFieldName]) {\n                        for(name in allOptions[childFieldName]){\n                            finalOpts[name] = allOptions[childFieldName][name];\n                        }\n                    }\n                    return finalOpts;\n                }\n                function _normalizeOpts(options) {\n                    var convertedOpts = {};\n                    var key;\n                    for(key in options){\n                        var newKey = key.replace(/-/g, \"_\");\n                        convertedOpts[newKey] = options[key];\n                    }\n                    return convertedOpts;\n                }\n                module.exports.Options = Options;\n                module.exports.normalizeOpts = _normalizeOpts;\n                module.exports.mergeOpts = _mergeOpts;\n            /***/ },\n            ,\n            /* 8 */ /***/ function(module) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var regexp_has_sticky = RegExp.prototype.hasOwnProperty(\"sticky\");\n                function InputScanner(input_string) {\n                    this.__input = input_string || \"\";\n                    this.__input_length = this.__input.length;\n                    this.__position = 0;\n                }\n                InputScanner.prototype.restart = function() {\n                    this.__position = 0;\n                };\n                InputScanner.prototype.back = function() {\n                    if (this.__position > 0) {\n                        this.__position -= 1;\n                    }\n                };\n                InputScanner.prototype.hasNext = function() {\n                    return this.__position < this.__input_length;\n                };\n                InputScanner.prototype.next = function() {\n                    var val = null;\n                    if (this.hasNext()) {\n                        val = this.__input.charAt(this.__position);\n                        this.__position += 1;\n                    }\n                    return val;\n                };\n                InputScanner.prototype.peek = function(index) {\n                    var val = null;\n                    index = index || 0;\n                    index += this.__position;\n                    if (index >= 0 && index < this.__input_length) {\n                        val = this.__input.charAt(index);\n                    }\n                    return val;\n                };\n                // This is a JavaScript only helper function (not in python)\n                // Javascript doesn't have a match method\n                // and not all implementation support \"sticky\" flag.\n                // If they do not support sticky then both this.match() and this.test() method\n                // must get the match and check the index of the match.\n                // If sticky is supported and set, this method will use it.\n                // Otherwise it will check that global is set, and fall back to the slower method.\n                InputScanner.prototype.__match = function(pattern, index) {\n                    pattern.lastIndex = index;\n                    var pattern_match = pattern.exec(this.__input);\n                    if (pattern_match && !(regexp_has_sticky && pattern.sticky)) {\n                        if (pattern_match.index !== index) {\n                            pattern_match = null;\n                        }\n                    }\n                    return pattern_match;\n                };\n                InputScanner.prototype.test = function(pattern, index) {\n                    index = index || 0;\n                    index += this.__position;\n                    if (index >= 0 && index < this.__input_length) {\n                        return !!this.__match(pattern, index);\n                    } else {\n                        return false;\n                    }\n                };\n                InputScanner.prototype.testChar = function(pattern, index) {\n                    // test one character regex match\n                    var val = this.peek(index);\n                    pattern.lastIndex = 0;\n                    return val !== null && pattern.test(val);\n                };\n                InputScanner.prototype.match = function(pattern) {\n                    var pattern_match = this.__match(pattern, this.__position);\n                    if (pattern_match) {\n                        this.__position += pattern_match[0].length;\n                    } else {\n                        pattern_match = null;\n                    }\n                    return pattern_match;\n                };\n                InputScanner.prototype.read = function(starting_pattern, until_pattern, until_after) {\n                    var val = \"\";\n                    var match;\n                    if (starting_pattern) {\n                        match = this.match(starting_pattern);\n                        if (match) {\n                            val += match[0];\n                        }\n                    }\n                    if (until_pattern && (match || !starting_pattern)) {\n                        val += this.readUntil(until_pattern, until_after);\n                    }\n                    return val;\n                };\n                InputScanner.prototype.readUntil = function(pattern, until_after) {\n                    var val = \"\";\n                    var match_index = this.__position;\n                    pattern.lastIndex = this.__position;\n                    var pattern_match = pattern.exec(this.__input);\n                    if (pattern_match) {\n                        match_index = pattern_match.index;\n                        if (until_after) {\n                            match_index += pattern_match[0].length;\n                        }\n                    } else {\n                        match_index = this.__input_length;\n                    }\n                    val = this.__input.substring(this.__position, match_index);\n                    this.__position = match_index;\n                    return val;\n                };\n                InputScanner.prototype.readUntilAfter = function(pattern) {\n                    return this.readUntil(pattern, true);\n                };\n                InputScanner.prototype.get_regexp = function(pattern, match_from) {\n                    var result = null;\n                    var flags = \"g\";\n                    if (match_from && regexp_has_sticky) {\n                        flags = \"y\";\n                    }\n                    // strings are converted to regexp\n                    if (typeof pattern === \"string\" && pattern !== \"\") {\n                        // result = new RegExp(pattern.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&'), flags);\n                        result = new RegExp(pattern, flags);\n                    } else if (pattern) {\n                        result = new RegExp(pattern.source, flags);\n                    }\n                    return result;\n                };\n                InputScanner.prototype.get_literal_regexp = function(literal_string) {\n                    return RegExp(literal_string.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\"));\n                };\n                /* css beautifier legacy helpers */ InputScanner.prototype.peekUntilAfter = function(pattern) {\n                    var start = this.__position;\n                    var val = this.readUntilAfter(pattern);\n                    this.__position = start;\n                    return val;\n                };\n                InputScanner.prototype.lookBack = function(testVal) {\n                    var start = this.__position - 1;\n                    return start >= testVal.length && this.__input.substring(start - testVal.length, start).toLowerCase() === testVal;\n                };\n                module.exports.InputScanner = InputScanner;\n            /***/ },\n            ,\n            ,\n            ,\n            ,\n            /* 13 */ /***/ function(module) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ function Directives(start_block_pattern, end_block_pattern) {\n                    start_block_pattern = typeof start_block_pattern === \"string\" ? start_block_pattern : start_block_pattern.source;\n                    end_block_pattern = typeof end_block_pattern === \"string\" ? end_block_pattern : end_block_pattern.source;\n                    this.__directives_block_pattern = new RegExp(start_block_pattern + / beautify( \\w+[:]\\w+)+ /.source + end_block_pattern, \"g\");\n                    this.__directive_pattern = / (\\w+)[:](\\w+)/g;\n                    this.__directives_end_ignore_pattern = new RegExp(start_block_pattern + /\\sbeautify\\signore:end\\s/.source + end_block_pattern, \"g\");\n                }\n                Directives.prototype.get_directives = function(text) {\n                    if (!text.match(this.__directives_block_pattern)) {\n                        return null;\n                    }\n                    var directives = {};\n                    this.__directive_pattern.lastIndex = 0;\n                    var directive_match = this.__directive_pattern.exec(text);\n                    while(directive_match){\n                        directives[directive_match[1]] = directive_match[2];\n                        directive_match = this.__directive_pattern.exec(text);\n                    }\n                    return directives;\n                };\n                Directives.prototype.readIgnored = function(input) {\n                    return input.readUntilAfter(this.__directives_end_ignore_pattern);\n                };\n                module.exports.Directives = Directives;\n            /***/ },\n            ,\n            /* 15 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_41634__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var Beautifier = __nested_webpack_require_41634__(16).Beautifier, Options = __nested_webpack_require_41634__(17).Options;\n                function css_beautify(source_text, options) {\n                    var beautifier = new Beautifier(source_text, options);\n                    return beautifier.beautify();\n                }\n                module.exports = css_beautify;\n                module.exports.defaultOptions = function() {\n                    return new Options();\n                };\n            /***/ },\n            /* 16 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_43420__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var Options = __nested_webpack_require_43420__(17).Options;\n                var Output = __nested_webpack_require_43420__(2).Output;\n                var InputScanner = __nested_webpack_require_43420__(8).InputScanner;\n                var Directives = __nested_webpack_require_43420__(13).Directives;\n                var directives_core = new Directives(/\\/\\*/, /\\*\\//);\n                var lineBreak = /\\r\\n|[\\r\\n]/;\n                var allLineBreaks = /\\r\\n|[\\r\\n]/g;\n                // tokenizer\n                var whitespaceChar = /\\s/;\n                var whitespacePattern = /(?:\\s|\\n)+/g;\n                var block_comment_pattern = /\\/\\*(?:[\\s\\S]*?)((?:\\*\\/)|$)/g;\n                var comment_pattern = /\\/\\/(?:[^\\n\\r\\u2028\\u2029]*)/g;\n                function Beautifier(source_text, options) {\n                    this._source_text = source_text || \"\";\n                    // Allow the setting of language/file-type specific options\n                    // with inheritance of overall settings\n                    this._options = new Options(options);\n                    this._ch = null;\n                    this._input = null;\n                    // https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule\n                    this.NESTED_AT_RULE = {\n                        \"page\": true,\n                        \"font-face\": true,\n                        \"keyframes\": true,\n                        // also in CONDITIONAL_GROUP_RULE below\n                        \"media\": true,\n                        \"supports\": true,\n                        \"document\": true\n                    };\n                    this.CONDITIONAL_GROUP_RULE = {\n                        \"media\": true,\n                        \"supports\": true,\n                        \"document\": true\n                    };\n                    this.NON_SEMICOLON_NEWLINE_PROPERTY = [\n                        \"grid-template-areas\",\n                        \"grid-template\"\n                    ];\n                }\n                Beautifier.prototype.eatString = function(endChars) {\n                    var result = \"\";\n                    this._ch = this._input.next();\n                    while(this._ch){\n                        result += this._ch;\n                        if (this._ch === \"\\\\\") {\n                            result += this._input.next();\n                        } else if (endChars.indexOf(this._ch) !== -1 || this._ch === \"\\n\") {\n                            break;\n                        }\n                        this._ch = this._input.next();\n                    }\n                    return result;\n                };\n                // Skips any white space in the source text from the current position.\n                // When allowAtLeastOneNewLine is true, will output new lines for each\n                // newline character found; if the user has preserve_newlines off, only\n                // the first newline will be output\n                Beautifier.prototype.eatWhitespace = function(allowAtLeastOneNewLine) {\n                    var result = whitespaceChar.test(this._input.peek());\n                    var newline_count = 0;\n                    while(whitespaceChar.test(this._input.peek())){\n                        this._ch = this._input.next();\n                        if (allowAtLeastOneNewLine && this._ch === \"\\n\") {\n                            if (newline_count === 0 || newline_count < this._options.max_preserve_newlines) {\n                                newline_count++;\n                                this._output.add_new_line(true);\n                            }\n                        }\n                    }\n                    return result;\n                };\n                // Nested pseudo-class if we are insideRule\n                // and the next special character found opens\n                // a new block\n                Beautifier.prototype.foundNestedPseudoClass = function() {\n                    var openParen = 0;\n                    var i = 1;\n                    var ch = this._input.peek(i);\n                    while(ch){\n                        if (ch === \"{\") {\n                            return true;\n                        } else if (ch === \"(\") {\n                            // pseudoclasses can contain ()\n                            openParen += 1;\n                        } else if (ch === \")\") {\n                            if (openParen === 0) {\n                                return false;\n                            }\n                            openParen -= 1;\n                        } else if (ch === \";\" || ch === \"}\") {\n                            return false;\n                        }\n                        i++;\n                        ch = this._input.peek(i);\n                    }\n                    return false;\n                };\n                Beautifier.prototype.print_string = function(output_string) {\n                    this._output.set_indent(this._indentLevel);\n                    this._output.non_breaking_space = true;\n                    this._output.add_token(output_string);\n                };\n                Beautifier.prototype.preserveSingleSpace = function(isAfterSpace) {\n                    if (isAfterSpace) {\n                        this._output.space_before_token = true;\n                    }\n                };\n                Beautifier.prototype.indent = function() {\n                    this._indentLevel++;\n                };\n                Beautifier.prototype.outdent = function() {\n                    if (this._indentLevel > 0) {\n                        this._indentLevel--;\n                    }\n                };\n                /*_____________________--------------------_____________________*/ Beautifier.prototype.beautify = function() {\n                    if (this._options.disabled) {\n                        return this._source_text;\n                    }\n                    var source_text = this._source_text;\n                    var eol = this._options.eol;\n                    if (eol === \"auto\") {\n                        eol = \"\\n\";\n                        if (source_text && lineBreak.test(source_text || \"\")) {\n                            eol = source_text.match(lineBreak)[0];\n                        }\n                    }\n                    // HACK: newline parsing inconsistent. This brute force normalizes the this._input.\n                    source_text = source_text.replace(allLineBreaks, \"\\n\");\n                    // reset\n                    var baseIndentString = source_text.match(/^[\\t ]*/)[0];\n                    this._output = new Output(this._options, baseIndentString);\n                    this._input = new InputScanner(source_text);\n                    this._indentLevel = 0;\n                    this._nestedLevel = 0;\n                    this._ch = null;\n                    var parenLevel = 0;\n                    var insideRule = false;\n                    // This is the value side of a property value pair (blue in the following ex)\n                    // label { content: blue }\n                    var insidePropertyValue = false;\n                    var enteringConditionalGroup = false;\n                    var insideNonNestedAtRule = false;\n                    var insideScssMap = false;\n                    var topCharacter = this._ch;\n                    var insideNonSemiColonValues = false;\n                    var whitespace;\n                    var isAfterSpace;\n                    var previous_ch;\n                    while(true){\n                        whitespace = this._input.read(whitespacePattern);\n                        isAfterSpace = whitespace !== \"\";\n                        previous_ch = topCharacter;\n                        this._ch = this._input.next();\n                        if (this._ch === \"\\\\\" && this._input.hasNext()) {\n                            this._ch += this._input.next();\n                        }\n                        topCharacter = this._ch;\n                        if (!this._ch) {\n                            break;\n                        } else if (this._ch === \"/\" && this._input.peek() === \"*\") {\n                            // /* css comment */\n                            // Always start block comments on a new line.\n                            // This handles scenarios where a block comment immediately\n                            // follows a property definition on the same line or where\n                            // minified code is being beautified.\n                            this._output.add_new_line();\n                            this._input.back();\n                            var comment = this._input.read(block_comment_pattern);\n                            // Handle ignore directive\n                            var directives = directives_core.get_directives(comment);\n                            if (directives && directives.ignore === \"start\") {\n                                comment += directives_core.readIgnored(this._input);\n                            }\n                            this.print_string(comment);\n                            // Ensures any new lines following the comment are preserved\n                            this.eatWhitespace(true);\n                            // Block comments are followed by a new line so they don't\n                            // share a line with other properties\n                            this._output.add_new_line();\n                        } else if (this._ch === \"/\" && this._input.peek() === \"/\") {\n                            // // single line comment\n                            // Preserves the space before a comment\n                            // on the same line as a rule\n                            this._output.space_before_token = true;\n                            this._input.back();\n                            this.print_string(this._input.read(comment_pattern));\n                            // Ensures any new lines following the comment are preserved\n                            this.eatWhitespace(true);\n                        } else if (this._ch === \"$\") {\n                            this.preserveSingleSpace(isAfterSpace);\n                            this.print_string(this._ch);\n                            // strip trailing space, if present, for hash property checks\n                            var variable = this._input.peekUntilAfter(/[: ,;{}()[\\]\\/='\"]/g);\n                            if (variable.match(/[ :]$/)) {\n                                // we have a variable or pseudo-class, add it and insert one space before continuing\n                                variable = this.eatString(\": \").replace(/\\s+$/, \"\");\n                                this.print_string(variable);\n                                this._output.space_before_token = true;\n                            }\n                            // might be sass variable\n                            if (parenLevel === 0 && variable.indexOf(\":\") !== -1) {\n                                insidePropertyValue = true;\n                                this.indent();\n                            }\n                        } else if (this._ch === \"@\") {\n                            this.preserveSingleSpace(isAfterSpace);\n                            // deal with less property mixins @{...}\n                            if (this._input.peek() === \"{\") {\n                                this.print_string(this._ch + this.eatString(\"}\"));\n                            } else {\n                                this.print_string(this._ch);\n                                // strip trailing space, if present, for hash property checks\n                                var variableOrRule = this._input.peekUntilAfter(/[: ,;{}()[\\]\\/='\"]/g);\n                                if (variableOrRule.match(/[ :]$/)) {\n                                    // we have a variable or pseudo-class, add it and insert one space before continuing\n                                    variableOrRule = this.eatString(\": \").replace(/\\s+$/, \"\");\n                                    this.print_string(variableOrRule);\n                                    this._output.space_before_token = true;\n                                }\n                                // might be less variable\n                                if (parenLevel === 0 && variableOrRule.indexOf(\":\") !== -1) {\n                                    insidePropertyValue = true;\n                                    this.indent();\n                                // might be a nesting at-rule\n                                } else if (variableOrRule in this.NESTED_AT_RULE) {\n                                    this._nestedLevel += 1;\n                                    if (variableOrRule in this.CONDITIONAL_GROUP_RULE) {\n                                        enteringConditionalGroup = true;\n                                    }\n                                // might be a non-nested at-rule\n                                } else if (parenLevel === 0 && !insidePropertyValue) {\n                                    insideNonNestedAtRule = true;\n                                }\n                            }\n                        } else if (this._ch === \"#\" && this._input.peek() === \"{\") {\n                            this.preserveSingleSpace(isAfterSpace);\n                            this.print_string(this._ch + this.eatString(\"}\"));\n                        } else if (this._ch === \"{\") {\n                            if (insidePropertyValue) {\n                                insidePropertyValue = false;\n                                this.outdent();\n                            }\n                            // non nested at rule becomes nested\n                            insideNonNestedAtRule = false;\n                            // when entering conditional groups, only rulesets are allowed\n                            if (enteringConditionalGroup) {\n                                enteringConditionalGroup = false;\n                                insideRule = this._indentLevel >= this._nestedLevel;\n                            } else {\n                                // otherwise, declarations are also allowed\n                                insideRule = this._indentLevel >= this._nestedLevel - 1;\n                            }\n                            if (this._options.newline_between_rules && insideRule) {\n                                if (this._output.previous_line && this._output.previous_line.item(-1) !== \"{\") {\n                                    this._output.ensure_empty_line_above(\"/\", \",\");\n                                }\n                            }\n                            this._output.space_before_token = true;\n                            // The difference in print_string and indent order is necessary to indent the '{' correctly\n                            if (this._options.brace_style === \"expand\") {\n                                this._output.add_new_line();\n                                this.print_string(this._ch);\n                                this.indent();\n                                this._output.set_indent(this._indentLevel);\n                            } else {\n                                // inside mixin and first param is object\n                                if (previous_ch === \"(\") {\n                                    this._output.space_before_token = false;\n                                } else if (previous_ch !== \",\") {\n                                    this.indent();\n                                }\n                                this.print_string(this._ch);\n                            }\n                            this.eatWhitespace(true);\n                            this._output.add_new_line();\n                        } else if (this._ch === \"}\") {\n                            this.outdent();\n                            this._output.add_new_line();\n                            if (previous_ch === \"{\") {\n                                this._output.trim(true);\n                            }\n                            if (insidePropertyValue) {\n                                this.outdent();\n                                insidePropertyValue = false;\n                            }\n                            this.print_string(this._ch);\n                            insideRule = false;\n                            if (this._nestedLevel) {\n                                this._nestedLevel--;\n                            }\n                            this.eatWhitespace(true);\n                            this._output.add_new_line();\n                            if (this._options.newline_between_rules && !this._output.just_added_blankline()) {\n                                if (this._input.peek() !== \"}\") {\n                                    this._output.add_new_line(true);\n                                }\n                            }\n                            if (this._input.peek() === \")\") {\n                                this._output.trim(true);\n                                if (this._options.brace_style === \"expand\") {\n                                    this._output.add_new_line(true);\n                                }\n                            }\n                        } else if (this._ch === \":\") {\n                            for(var i = 0; i < this.NON_SEMICOLON_NEWLINE_PROPERTY.length; i++){\n                                if (this._input.lookBack(this.NON_SEMICOLON_NEWLINE_PROPERTY[i])) {\n                                    insideNonSemiColonValues = true;\n                                    break;\n                                }\n                            }\n                            if ((insideRule || enteringConditionalGroup) && !(this._input.lookBack(\"&\") || this.foundNestedPseudoClass()) && !this._input.lookBack(\"(\") && !insideNonNestedAtRule && parenLevel === 0) {\n                                // 'property: value' delimiter\n                                // which could be in a conditional group query\n                                this.print_string(\":\");\n                                if (!insidePropertyValue) {\n                                    insidePropertyValue = true;\n                                    this._output.space_before_token = true;\n                                    this.eatWhitespace(true);\n                                    this.indent();\n                                }\n                            } else {\n                                // sass/less parent reference don't use a space\n                                // sass nested pseudo-class don't use a space\n                                // preserve space before pseudoclasses/pseudoelements, as it means \"in any child\"\n                                if (this._input.lookBack(\" \")) {\n                                    this._output.space_before_token = true;\n                                }\n                                if (this._input.peek() === \":\") {\n                                    // pseudo-element\n                                    this._ch = this._input.next();\n                                    this.print_string(\"::\");\n                                } else {\n                                    // pseudo-class\n                                    this.print_string(\":\");\n                                }\n                            }\n                        } else if (this._ch === '\"' || this._ch === \"'\") {\n                            var preserveQuoteSpace = previous_ch === '\"' || previous_ch === \"'\";\n                            this.preserveSingleSpace(preserveQuoteSpace || isAfterSpace);\n                            this.print_string(this._ch + this.eatString(this._ch));\n                            this.eatWhitespace(true);\n                        } else if (this._ch === \";\") {\n                            insideNonSemiColonValues = false;\n                            if (parenLevel === 0) {\n                                if (insidePropertyValue) {\n                                    this.outdent();\n                                    insidePropertyValue = false;\n                                }\n                                insideNonNestedAtRule = false;\n                                this.print_string(this._ch);\n                                this.eatWhitespace(true);\n                                // This maintains single line comments on the same\n                                // line. Block comments are also affected, but\n                                // a new line is always output before one inside\n                                // that section\n                                if (this._input.peek() !== \"/\") {\n                                    this._output.add_new_line();\n                                }\n                            } else {\n                                this.print_string(this._ch);\n                                this.eatWhitespace(true);\n                                this._output.space_before_token = true;\n                            }\n                        } else if (this._ch === \"(\") {\n                            if (this._input.lookBack(\"url\")) {\n                                this.print_string(this._ch);\n                                this.eatWhitespace();\n                                parenLevel++;\n                                this.indent();\n                                this._ch = this._input.next();\n                                if (this._ch === \")\" || this._ch === '\"' || this._ch === \"'\") {\n                                    this._input.back();\n                                } else if (this._ch) {\n                                    this.print_string(this._ch + this.eatString(\")\"));\n                                    if (parenLevel) {\n                                        parenLevel--;\n                                        this.outdent();\n                                    }\n                                }\n                            } else {\n                                var space_needed = false;\n                                if (this._input.lookBack(\"with\")) {\n                                    // look back is not an accurate solution, we need tokens to confirm without whitespaces\n                                    space_needed = true;\n                                }\n                                this.preserveSingleSpace(isAfterSpace || space_needed);\n                                this.print_string(this._ch);\n                                // handle scss/sass map\n                                if (insidePropertyValue && previous_ch === \"$\" && this._options.selector_separator_newline) {\n                                    this._output.add_new_line();\n                                    insideScssMap = true;\n                                } else {\n                                    this.eatWhitespace();\n                                    parenLevel++;\n                                    this.indent();\n                                }\n                            }\n                        } else if (this._ch === \")\") {\n                            if (parenLevel) {\n                                parenLevel--;\n                                this.outdent();\n                            }\n                            if (insideScssMap && this._input.peek() === \";\" && this._options.selector_separator_newline) {\n                                insideScssMap = false;\n                                this.outdent();\n                                this._output.add_new_line();\n                            }\n                            this.print_string(this._ch);\n                        } else if (this._ch === \",\") {\n                            this.print_string(this._ch);\n                            this.eatWhitespace(true);\n                            if (this._options.selector_separator_newline && (!insidePropertyValue || insideScssMap) && parenLevel === 0 && !insideNonNestedAtRule) {\n                                this._output.add_new_line();\n                            } else {\n                                this._output.space_before_token = true;\n                            }\n                        } else if ((this._ch === \">\" || this._ch === \"+\" || this._ch === \"~\") && !insidePropertyValue && parenLevel === 0) {\n                            //handle combinator spacing\n                            if (this._options.space_around_combinator) {\n                                this._output.space_before_token = true;\n                                this.print_string(this._ch);\n                                this._output.space_before_token = true;\n                            } else {\n                                this.print_string(this._ch);\n                                this.eatWhitespace();\n                                // squash extra whitespace\n                                if (this._ch && whitespaceChar.test(this._ch)) {\n                                    this._ch = \"\";\n                                }\n                            }\n                        } else if (this._ch === \"]\") {\n                            this.print_string(this._ch);\n                        } else if (this._ch === \"[\") {\n                            this.preserveSingleSpace(isAfterSpace);\n                            this.print_string(this._ch);\n                        } else if (this._ch === \"=\") {\n                            this.eatWhitespace();\n                            this.print_string(\"=\");\n                            if (whitespaceChar.test(this._ch)) {\n                                this._ch = \"\";\n                            }\n                        } else if (this._ch === \"!\" && !this._input.lookBack(\"\\\\\")) {\n                            this._output.space_before_token = true;\n                            this.print_string(this._ch);\n                        } else {\n                            var preserveAfterSpace = previous_ch === '\"' || previous_ch === \"'\";\n                            this.preserveSingleSpace(preserveAfterSpace || isAfterSpace);\n                            this.print_string(this._ch);\n                            if (!this._output.just_added_newline() && this._input.peek() === \"\\n\" && insideNonSemiColonValues) {\n                                this._output.add_new_line();\n                            }\n                        }\n                    }\n                    var sweetCode = this._output.get_code(eol);\n                    return sweetCode;\n                };\n                module.exports.Beautifier = Beautifier;\n            /***/ },\n            /* 17 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_71255__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var BaseOptions = __nested_webpack_require_71255__(6).Options;\n                function Options(options) {\n                    BaseOptions.call(this, options, \"css\");\n                    this.selector_separator_newline = this._get_boolean(\"selector_separator_newline\", true);\n                    this.newline_between_rules = this._get_boolean(\"newline_between_rules\", true);\n                    var space_around_selector_separator = this._get_boolean(\"space_around_selector_separator\");\n                    this.space_around_combinator = this._get_boolean(\"space_around_combinator\") || space_around_selector_separator;\n                    var brace_style_split = this._get_selection_list(\"brace_style\", [\n                        \"collapse\",\n                        \"expand\",\n                        \"end-expand\",\n                        \"none\",\n                        \"preserve-inline\"\n                    ]);\n                    this.brace_style = \"collapse\";\n                    for(var bs = 0; bs < brace_style_split.length; bs++){\n                        if (brace_style_split[bs] !== \"expand\") {\n                            // default to collapse, as only collapse|expand is implemented for now\n                            this.brace_style = \"collapse\";\n                        } else {\n                            this.brace_style = brace_style_split[bs];\n                        }\n                    }\n                }\n                Options.prototype = new BaseOptions();\n                module.exports.Options = Options;\n            /***/ }\n        ];\n        /************************************************************************/ /******/ // The module cache\n        /******/ var __webpack_module_cache__ = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_74263__(moduleId) {\n            /******/ // Check if module is in cache\n            /******/ var cachedModule = __webpack_module_cache__[moduleId];\n            /******/ if (cachedModule !== undefined) {\n                /******/ return cachedModule.exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module = __webpack_module_cache__[moduleId] = {\n                /******/ // no module.id needed\n                /******/ // no module.loaded needed\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ __webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_74263__);\n            /******/ /******/ // Return the exports of the module\n            /******/ return module.exports;\n        /******/ }\n        /******/ /************************************************************************/ /******/ /******/ // startup\n        /******/ // Load entry module and return exports\n        /******/ // This entry module is referenced by other modules so it can't be inlined\n        /******/ var __nested_webpack_exports__ = __nested_webpack_require_74263__(15);\n        /******/ legacy_beautify_css = __nested_webpack_exports__;\n    /******/ /******/ })();\n    var css_beautify = legacy_beautify_css;\n    /* Footer */ if (true) {\n        // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n            return {\n                css_beautify: css_beautify\n            };\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanMtYmVhdXRpZnkvanMvbGliL2JlYXV0aWZ5LWNzcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxrR0FBa0MsR0FDbEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEwREEsR0FFQSx1REFBdUQ7QUFDdkQsb0NBQW9DO0FBRW5DO0lBRUQsMEJBQTBCLEdBQzFCLElBQUlBO0lBQ0osTUFBTSxHQUFJO1FBQ1YsTUFBTSxHQUFJO1FBQ1YsTUFBTSxHQUFJLElBQUlDLHNCQUF1Qjs7O1lBR3JDLEtBQUssR0FDTCxHQUFHLEdBQUksU0FBU0MsTUFBTTtnQkFFdEIsbUJBQW1CLEdBQ25COzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3QkEsR0FJQSxTQUFTQyxXQUFXQyxNQUFNO29CQUN4QixJQUFJLENBQUNDLFFBQVEsR0FBR0Q7b0JBQ2hCLElBQUksQ0FBQ0UsaUJBQWlCLEdBQUc7b0JBQ3pCLGdGQUFnRjtvQkFDaEYsSUFBSSxDQUFDQyxjQUFjLEdBQUcsQ0FBQztvQkFDdkIsSUFBSSxDQUFDQyxpQkFBaUIsR0FBRztvQkFDekIsSUFBSSxDQUFDQyxrQkFBa0IsR0FBRztvQkFDMUIsSUFBSSxDQUFDQyw0QkFBNEIsR0FBRztvQkFDcEMsSUFBSSxDQUFDQyx5QkFBeUIsR0FBRyxDQUFDO29CQUNsQyxJQUFJLENBQUNDLDRCQUE0QixHQUFHO29CQUVwQyxJQUFJLENBQUNDLE9BQU8sR0FBRyxFQUFFO2dCQUNuQjtnQkFFQVYsV0FBV1csU0FBUyxDQUFDQyxXQUFXLEdBQUc7b0JBQ2pDLElBQUlDLE9BQU8sSUFBSWIsV0FBVyxJQUFJLENBQUNFLFFBQVE7b0JBQ3ZDVyxLQUFLQyxVQUFVLENBQUMsSUFBSSxDQUFDVixjQUFjLEVBQUUsSUFBSSxDQUFDQyxpQkFBaUI7b0JBQzNELE9BQU9RO2dCQUNUO2dCQUVBYixXQUFXVyxTQUFTLENBQUNJLElBQUksR0FBRyxTQUFTQyxLQUFL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TUFBTSxHQUFJO1FBQ1YsTUFBTSxHQUNOLHdFQUF3RSxHQUN4RSxNQUFNLEdBQ04sTUFBTSxHQUFJLFVBQVU7UUFDcEIsTUFBTSxHQUFJLHVDQUF1QztRQUNqRCxNQUFNLEdBQUksMEVBQTBFO1FBQ3BGLE1BQU0sR0FBSSxJQUFJMkosMEJBQW1CQSxHQUFHcEUsZ0NBQW1CQSxDQUFDO1FBQ3hELE1BQU0sR0FBSXBNLHNCQUFzQndRLDBCQUFtQkE7SUFDbkQsTUFBTSxHQUNOLE1BQU0sR0FBRztJQUVULElBQUlsRSxlQUFldE07SUFDbkIsVUFBVSxHQUNWLElBQUksSUFBMEMsRUFBRTtRQUM1QywwRkFBMEY7UUFDMUZ5USxpQ0FBTyxFQUFFLG1DQUFFO1lBQ1AsT0FBTztnQkFDSG5FLGNBQWNBO1lBQ2xCO1FBQ0osQ0FBQztBQUFBLGtHQUFDO0lBQ04sT0FBTyxFQVVOO0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYmNsZWFucy8uL25vZGVfbW9kdWxlcy9qcy1iZWF1dGlmeS9qcy9saWIvYmVhdXRpZnktY3NzLmpzP2M0M2YiXSwic291cmNlc0NvbnRlbnQiOlsiLyogQVVUTy1HRU5FUkFURUQuIERPIE5PVCBNT0RJRlkuICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cblxuXG4gQ1NTIEJlYXV0aWZpZXJcbi0tLS0tLS0tLS0tLS0tLVxuXG4gICAgV3JpdHRlbiBieSBIYXJ1dHl1biBBbWlyamFueWFuLCAoYW1pcmphbnlhbkBnbWFpbC5jb20pXG5cbiAgICBCYXNlZCBvbiBjb2RlIGluaXRpYWxseSBkZXZlbG9wZWQgYnk6IEVpbmFyIExpZWxtYW5pcywgPGVpbmFyQGJlYXV0aWZpZXIuaW8+XG4gICAgICAgIGh0dHBzOi8vYmVhdXRpZmllci5pby9cblxuICAgIFVzYWdlOlxuICAgICAgICBjc3NfYmVhdXRpZnkoc291cmNlX3RleHQpO1xuICAgICAgICBjc3NfYmVhdXRpZnkoc291cmNlX3RleHQsIG9wdGlvbnMpO1xuXG4gICAgVGhlIG9wdGlvbnMgYXJlIChkZWZhdWx0IGluIGJyYWNrZXRzKTpcbiAgICAgICAgaW5kZW50X3NpemUgKDQpICAgICAgICAgICAgICAgICAgICAgICAgIOKAlCBpbmRlbnRhdGlvbiBzaXplLFxuICAgICAgICBpbmRlbnRfY2hhciAoc3BhY2UpICAgICAgICAgICAgICAgICAgICAg4oCUIGNoYXJhY3RlciB0byBpbmRlbnQgd2l0aCxcbiAgICAgICAgc2VsZWN0b3Jfc2VwYXJhdG9yX25ld2xpbmUgKHRydWUpICAgICAgIC0gc2VwYXJhdGUgc2VsZWN0b3JzIHdpdGggbmV3bGluZSBvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3QgKGUuZy4gXCJhLFxcbmJyXCIgb3IgXCJhLCBiclwiKVxuICAgICAgICBlbmRfd2l0aF9uZXdsaW5lIChmYWxzZSkgICAgICAgICAgICAgICAgLSBlbmQgd2l0aCBhIG5ld2xpbmVcbiAgICAgICAgbmV3bGluZV9iZXR3ZWVuX3J1bGVzICh0cnVlKSAgICAgICAgICAgIC0gYWRkIGEgbmV3IGxpbmUgYWZ0ZXIgZXZlcnkgY3NzIHJ1bGVcbiAgICAgICAgc3BhY2VfYXJvdW5kX3NlbGVjdG9yX3NlcGFyYXRvciAoZmFsc2UpIC0gZW5zdXJlIHNwYWNlIGFyb3VuZCBzZWxlY3RvciBzZXBhcmF0b3JzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPicsICcrJywgJ34nIChlLmcuIFwiYT5iXCIgLT4gXCJhID4gYlwiKVxuICAgIGUuZ1xuXG4gICAgY3NzX2JlYXV0aWZ5KGNzc19zb3VyY2VfdGV4dCwge1xuICAgICAgJ2luZGVudF9zaXplJzogMSxcbiAgICAgICdpbmRlbnRfY2hhcic6ICdcXHQnLFxuICAgICAgJ3NlbGVjdG9yX3NlcGFyYXRvcic6ICcgJyxcbiAgICAgICdlbmRfd2l0aF9uZXdsaW5lJzogZmFsc2UsXG4gICAgICAnbmV3bGluZV9iZXR3ZWVuX3J1bGVzJzogdHJ1ZSxcbiAgICAgICdzcGFjZV9hcm91bmRfc2VsZWN0b3Jfc2VwYXJhdG9yJzogdHJ1ZVxuICAgIH0pO1xuKi9cblxuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI3Rva2VuaXphdGlvblxuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zeW50YXgvXG5cbihmdW5jdGlvbigpIHtcblxuLyogR0VORVJBVEVEX0JVSUxEX09VVFBVVCAqL1xudmFyIGxlZ2FjeV9iZWF1dGlmeV9jc3M7XG4vKioqKioqLyAoZnVuY3Rpb24oKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0XCJ1c2Ugc3RyaWN0XCI7XG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlc19fID0gKFtcbi8qIDAgKi8sXG4vKiAxICovLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG5mdW5jdGlvbiBPdXRwdXRMaW5lKHBhcmVudCkge1xuICB0aGlzLl9fcGFyZW50ID0gcGFyZW50O1xuICB0aGlzLl9fY2hhcmFjdGVyX2NvdW50ID0gMDtcbiAgLy8gdXNlIGluZGVudF9jb3VudCBhcyBhIG1hcmtlciBmb3IgdGhpcy5fX2xpbmVzIHRoYXQgaGF2ZSBwcmVzZXJ2ZWQgaW5kZW50YXRpb25cbiAgdGhpcy5fX2luZGVudF9jb3VudCA9IC0xO1xuICB0aGlzLl9fYWxpZ25tZW50X2NvdW50ID0gMDtcbiAgdGhpcy5fX3dyYXBfcG9pbnRfaW5kZXggPSAwO1xuICB0aGlzLl9fd3JhcF9wb2ludF9jaGFyYWN0ZXJfY291bnQgPSAwO1xuICB0aGlzLl9fd3JhcF9wb2ludF9pbmRlbnRfY291bnQgPSAtMTtcbiAgdGhpcy5fX3dyYXBfcG9pbnRfYWxpZ25tZW50X2NvdW50ID0gMDtcblxuICB0aGlzLl9faXRlbXMgPSBbXTtcbn1cblxuT3V0cHV0TGluZS5wcm90b3R5cGUuY2xvbmVfZW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGxpbmUgPSBuZXcgT3V0cHV0TGluZSh0aGlzLl9fcGFyZW50KTtcbiAgbGluZS5zZXRfaW5kZW50KHRoaXMuX19pbmRlbnRfY291bnQsIHRoaXMuX19hbGlnbm1lbnRfY291bnQpO1xuICByZXR1cm4gbGluZTtcbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLml0ZW0gPSBmdW5jdGlvbihpbmRleCkge1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIHRoaXMuX19pdGVtc1t0aGlzLl9faXRlbXMubGVuZ3RoICsgaW5kZXhdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLl9faXRlbXNbaW5kZXhdO1xuICB9XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5oYXNfbWF0Y2ggPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gIGZvciAodmFyIGxhc3RDaGVja2VkT3V0cHV0ID0gdGhpcy5fX2l0ZW1zLmxlbmd0aCAtIDE7IGxhc3RDaGVja2VkT3V0cHV0ID49IDA7IGxhc3RDaGVja2VkT3V0cHV0LS0pIHtcbiAgICBpZiAodGhpcy5fX2l0ZW1zW2xhc3RDaGVja2VkT3V0cHV0XS5tYXRjaChwYXR0ZXJuKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLnNldF9pbmRlbnQgPSBmdW5jdGlvbihpbmRlbnQsIGFsaWdubWVudCkge1xuICBpZiAodGhpcy5pc19lbXB0eSgpKSB7XG4gICAgdGhpcy5fX2luZGVudF9jb3VudCA9IGluZGVudCB8fCAwO1xuICAgIHRoaXMuX19hbGlnbm1lbnRfY291bnQgPSBhbGlnbm1lbnQgfHwgMDtcbiAgICB0aGlzLl9fY2hhcmFjdGVyX2NvdW50ID0gdGhpcy5fX3BhcmVudC5nZXRfaW5kZW50X3NpemUodGhpcy5fX2luZGVudF9jb3VudCwgdGhpcy5fX2FsaWdubWVudF9jb3VudCk7XG4gIH1cbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLl9zZXRfd3JhcF9wb2ludCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fX3BhcmVudC53cmFwX2xpbmVfbGVuZ3RoKSB7XG4gICAgdGhpcy5fX3dyYXBfcG9pbnRfaW5kZXggPSB0aGlzLl9faXRlbXMubGVuZ3RoO1xuICAgIHRoaXMuX193cmFwX3BvaW50X2NoYXJhY3Rlcl9jb3VudCA9IHRoaXMuX19jaGFyYWN0ZXJfY291bnQ7XG4gICAgdGhpcy5fX3dyYXBfcG9pbnRfaW5kZW50X2NvdW50ID0gdGhpcy5fX3BhcmVudC5uZXh0X2xpbmUuX19pbmRlbnRfY291bnQ7XG4gICAgdGhpcy5fX3dyYXBfcG9pbnRfYWxpZ25tZW50X2NvdW50ID0gdGhpcy5fX3BhcmVudC5uZXh0X2xpbmUuX19hbGlnbm1lbnRfY291bnQ7XG4gIH1cbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLl9zaG91bGRfd3JhcCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fX3dyYXBfcG9pbnRfaW5kZXggJiZcbiAgICB0aGlzLl9fY2hhcmFjdGVyX2NvdW50ID4gdGhpcy5fX3BhcmVudC53cmFwX2xpbmVfbGVuZ3RoICYmXG4gICAgdGhpcy5fX3dyYXBfcG9pbnRfY2hhcmFjdGVyX2NvdW50ID4gdGhpcy5fX3BhcmVudC5uZXh0X2xpbmUuX19jaGFyYWN0ZXJfY291bnQ7XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5fYWxsb3dfd3JhcCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fc2hvdWxkX3dyYXAoKSkge1xuICAgIHRoaXMuX19wYXJlbnQuYWRkX25ld19saW5lKCk7XG4gICAgdmFyIG5leHQgPSB0aGlzLl9fcGFyZW50LmN1cnJlbnRfbGluZTtcbiAgICBuZXh0LnNldF9pbmRlbnQodGhpcy5fX3dyYXBfcG9pbnRfaW5kZW50X2NvdW50LCB0aGlzLl9fd3JhcF9wb2ludF9hbGlnbm1lbnRfY291bnQpO1xuICAgIG5leHQuX19pdGVtcyA9IHRoaXMuX19pdGVtcy5zbGljZSh0aGlzLl9fd3JhcF9wb2ludF9pbmRleCk7XG4gICAgdGhpcy5fX2l0ZW1zID0gdGhpcy5fX2l0ZW1zLnNsaWNlKDAsIHRoaXMuX193cmFwX3BvaW50X2luZGV4KTtcblxuICAgIG5leHQuX19jaGFyYWN0ZXJfY291bnQgKz0gdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCAtIHRoaXMuX193cmFwX3BvaW50X2NoYXJhY3Rlcl9jb3VudDtcbiAgICB0aGlzLl9fY2hhcmFjdGVyX2NvdW50ID0gdGhpcy5fX3dyYXBfcG9pbnRfY2hhcmFjdGVyX2NvdW50O1xuXG4gICAgaWYgKG5leHQuX19pdGVtc1swXSA9PT0gXCIgXCIpIHtcbiAgICAgIG5leHQuX19pdGVtcy5zcGxpY2UoMCwgMSk7XG4gICAgICBuZXh0Ll9fY2hhcmFjdGVyX2NvdW50IC09IDE7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLmlzX2VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9faXRlbXMubGVuZ3RoID09PSAwO1xufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUubGFzdCA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuaXNfZW1wdHkoKSkge1xuICAgIHJldHVybiB0aGlzLl9faXRlbXNbdGhpcy5fX2l0ZW1zLmxlbmd0aCAtIDFdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oaXRlbSkge1xuICB0aGlzLl9faXRlbXMucHVzaChpdGVtKTtcbiAgdmFyIGxhc3RfbmV3bGluZV9pbmRleCA9IGl0ZW0ubGFzdEluZGV4T2YoJ1xcbicpO1xuICBpZiAobGFzdF9uZXdsaW5lX2luZGV4ICE9PSAtMSkge1xuICAgIHRoaXMuX19jaGFyYWN0ZXJfY291bnQgPSBpdGVtLmxlbmd0aCAtIGxhc3RfbmV3bGluZV9pbmRleDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9fY2hhcmFjdGVyX2NvdW50ICs9IGl0ZW0ubGVuZ3RoO1xuICB9XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGl0ZW0gPSBudWxsO1xuICBpZiAoIXRoaXMuaXNfZW1wdHkoKSkge1xuICAgIGl0ZW0gPSB0aGlzLl9faXRlbXMucG9wKCk7XG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCAtPSBpdGVtLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gaXRlbTtcbn07XG5cblxuT3V0cHV0TGluZS5wcm90b3R5cGUuX3JlbW92ZV9pbmRlbnQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX19pbmRlbnRfY291bnQgPiAwKSB7XG4gICAgdGhpcy5fX2luZGVudF9jb3VudCAtPSAxO1xuICAgIHRoaXMuX19jaGFyYWN0ZXJfY291bnQgLT0gdGhpcy5fX3BhcmVudC5pbmRlbnRfc2l6ZTtcbiAgfVxufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUuX3JlbW92ZV93cmFwX2luZGVudCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fX3dyYXBfcG9pbnRfaW5kZW50X2NvdW50ID4gMCkge1xuICAgIHRoaXMuX193cmFwX3BvaW50X2luZGVudF9jb3VudCAtPSAxO1xuICB9XG59O1xuT3V0cHV0TGluZS5wcm90b3R5cGUudHJpbSA9IGZ1bmN0aW9uKCkge1xuICB3aGlsZSAodGhpcy5sYXN0KCkgPT09ICcgJykge1xuICAgIHRoaXMuX19pdGVtcy5wb3AoKTtcbiAgICB0aGlzLl9fY2hhcmFjdGVyX2NvdW50IC09IDE7XG4gIH1cbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgaWYgKHRoaXMuaXNfZW1wdHkoKSkge1xuICAgIGlmICh0aGlzLl9fcGFyZW50LmluZGVudF9lbXB0eV9saW5lcykge1xuICAgICAgcmVzdWx0ID0gdGhpcy5fX3BhcmVudC5nZXRfaW5kZW50X3N0cmluZyh0aGlzLl9faW5kZW50X2NvdW50KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gdGhpcy5fX3BhcmVudC5nZXRfaW5kZW50X3N0cmluZyh0aGlzLl9faW5kZW50X2NvdW50LCB0aGlzLl9fYWxpZ25tZW50X2NvdW50KTtcbiAgICByZXN1bHQgKz0gdGhpcy5fX2l0ZW1zLmpvaW4oJycpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5mdW5jdGlvbiBJbmRlbnRTdHJpbmdDYWNoZShvcHRpb25zLCBiYXNlSW5kZW50U3RyaW5nKSB7XG4gIHRoaXMuX19jYWNoZSA9IFsnJ107XG4gIHRoaXMuX19pbmRlbnRfc2l6ZSA9IG9wdGlvbnMuaW5kZW50X3NpemU7XG4gIHRoaXMuX19pbmRlbnRfc3RyaW5nID0gb3B0aW9ucy5pbmRlbnRfY2hhcjtcbiAgaWYgKCFvcHRpb25zLmluZGVudF93aXRoX3RhYnMpIHtcbiAgICB0aGlzLl9faW5kZW50X3N0cmluZyA9IG5ldyBBcnJheShvcHRpb25zLmluZGVudF9zaXplICsgMSkuam9pbihvcHRpb25zLmluZGVudF9jaGFyKTtcbiAgfVxuXG4gIC8vIFNldCB0byBudWxsIHRvIGNvbnRpbnVlIHN1cHBvcnQgZm9yIGF1dG8gZGV0ZWN0aW9uIG9mIGJhc2UgaW5kZW50XG4gIGJhc2VJbmRlbnRTdHJpbmcgPSBiYXNlSW5kZW50U3RyaW5nIHx8ICcnO1xuICBpZiAob3B0aW9ucy5pbmRlbnRfbGV2ZWwgPiAwKSB7XG4gICAgYmFzZUluZGVudFN0cmluZyA9IG5ldyBBcnJheShvcHRpb25zLmluZGVudF9sZXZlbCArIDEpLmpvaW4odGhpcy5fX2luZGVudF9zdHJpbmcpO1xuICB9XG5cbiAgdGhpcy5fX2Jhc2Vfc3RyaW5nID0gYmFzZUluZGVudFN0cmluZztcbiAgdGhpcy5fX2Jhc2Vfc3RyaW5nX2xlbmd0aCA9IGJhc2VJbmRlbnRTdHJpbmcubGVuZ3RoO1xufVxuXG5JbmRlbnRTdHJpbmdDYWNoZS5wcm90b3R5cGUuZ2V0X2luZGVudF9zaXplID0gZnVuY3Rpb24oaW5kZW50LCBjb2x1bW4pIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuX19iYXNlX3N0cmluZ19sZW5ndGg7XG4gIGNvbHVtbiA9IGNvbHVtbiB8fCAwO1xuICBpZiAoaW5kZW50IDwgMCkge1xuICAgIHJlc3VsdCA9IDA7XG4gIH1cbiAgcmVzdWx0ICs9IGluZGVudCAqIHRoaXMuX19pbmRlbnRfc2l6ZTtcbiAgcmVzdWx0ICs9IGNvbHVtbjtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbkluZGVudFN0cmluZ0NhY2hlLnByb3RvdHlwZS5nZXRfaW5kZW50X3N0cmluZyA9IGZ1bmN0aW9uKGluZGVudF9sZXZlbCwgY29sdW1uKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9fYmFzZV9zdHJpbmc7XG4gIGNvbHVtbiA9IGNvbHVtbiB8fCAwO1xuICBpZiAoaW5kZW50X2xldmVsIDwgMCkge1xuICAgIGluZGVudF9sZXZlbCA9IDA7XG4gICAgcmVzdWx0ID0gJyc7XG4gIH1cbiAgY29sdW1uICs9IGluZGVudF9sZXZlbCAqIHRoaXMuX19pbmRlbnRfc2l6ZTtcbiAgdGhpcy5fX2Vuc3VyZV9jYWNoZShjb2x1bW4pO1xuICByZXN1bHQgKz0gdGhpcy5fX2NhY2hlW2NvbHVtbl07XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5JbmRlbnRTdHJpbmdDYWNoZS5wcm90b3R5cGUuX19lbnN1cmVfY2FjaGUgPSBmdW5jdGlvbihjb2x1bW4pIHtcbiAgd2hpbGUgKGNvbHVtbiA+PSB0aGlzLl9fY2FjaGUubGVuZ3RoKSB7XG4gICAgdGhpcy5fX2FkZF9jb2x1bW4oKTtcbiAgfVxufTtcblxuSW5kZW50U3RyaW5nQ2FjaGUucHJvdG90eXBlLl9fYWRkX2NvbHVtbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY29sdW1uID0gdGhpcy5fX2NhY2hlLmxlbmd0aDtcbiAgdmFyIGluZGVudCA9IDA7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgaWYgKHRoaXMuX19pbmRlbnRfc2l6ZSAmJiBjb2x1bW4gPj0gdGhpcy5fX2luZGVudF9zaXplKSB7XG4gICAgaW5kZW50ID0gTWF0aC5mbG9vcihjb2x1bW4gLyB0aGlzLl9faW5kZW50X3NpemUpO1xuICAgIGNvbHVtbiAtPSBpbmRlbnQgKiB0aGlzLl9faW5kZW50X3NpemU7XG4gICAgcmVzdWx0ID0gbmV3IEFycmF5KGluZGVudCArIDEpLmpvaW4odGhpcy5fX2luZGVudF9zdHJpbmcpO1xuICB9XG4gIGlmIChjb2x1bW4pIHtcbiAgICByZXN1bHQgKz0gbmV3IEFycmF5KGNvbHVtbiArIDEpLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHRoaXMuX19jYWNoZS5wdXNoKHJlc3VsdCk7XG59O1xuXG5mdW5jdGlvbiBPdXRwdXQob3B0aW9ucywgYmFzZUluZGVudFN0cmluZykge1xuICB0aGlzLl9faW5kZW50X2NhY2hlID0gbmV3IEluZGVudFN0cmluZ0NhY2hlKG9wdGlvbnMsIGJhc2VJbmRlbnRTdHJpbmcpO1xuICB0aGlzLnJhdyA9IGZhbHNlO1xuICB0aGlzLl9lbmRfd2l0aF9uZXdsaW5lID0gb3B0aW9ucy5lbmRfd2l0aF9uZXdsaW5lO1xuICB0aGlzLmluZGVudF9zaXplID0gb3B0aW9ucy5pbmRlbnRfc2l6ZTtcbiAgdGhpcy53cmFwX2xpbmVfbGVuZ3RoID0gb3B0aW9ucy53cmFwX2xpbmVfbGVuZ3RoO1xuICB0aGlzLmluZGVudF9lbXB0eV9saW5lcyA9IG9wdGlvbnMuaW5kZW50X2VtcHR5X2xpbmVzO1xuICB0aGlzLl9fbGluZXMgPSBbXTtcbiAgdGhpcy5wcmV2aW91c19saW5lID0gbnVsbDtcbiAgdGhpcy5jdXJyZW50X2xpbmUgPSBudWxsO1xuICB0aGlzLm5leHRfbGluZSA9IG5ldyBPdXRwdXRMaW5lKHRoaXMpO1xuICB0aGlzLnNwYWNlX2JlZm9yZV90b2tlbiA9IGZhbHNlO1xuICB0aGlzLm5vbl9icmVha2luZ19zcGFjZSA9IGZhbHNlO1xuICB0aGlzLnByZXZpb3VzX3Rva2VuX3dyYXBwZWQgPSBmYWxzZTtcbiAgLy8gaW5pdGlhbGl6ZVxuICB0aGlzLl9fYWRkX291dHB1dGxpbmUoKTtcbn1cblxuT3V0cHV0LnByb3RvdHlwZS5fX2FkZF9vdXRwdXRsaW5lID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucHJldmlvdXNfbGluZSA9IHRoaXMuY3VycmVudF9saW5lO1xuICB0aGlzLmN1cnJlbnRfbGluZSA9IHRoaXMubmV4dF9saW5lLmNsb25lX2VtcHR5KCk7XG4gIHRoaXMuX19saW5lcy5wdXNoKHRoaXMuY3VycmVudF9saW5lKTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuZ2V0X2xpbmVfbnVtYmVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9fbGluZXMubGVuZ3RoO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5nZXRfaW5kZW50X3N0cmluZyA9IGZ1bmN0aW9uKGluZGVudCwgY29sdW1uKSB7XG4gIHJldHVybiB0aGlzLl9faW5kZW50X2NhY2hlLmdldF9pbmRlbnRfc3RyaW5nKGluZGVudCwgY29sdW1uKTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuZ2V0X2luZGVudF9zaXplID0gZnVuY3Rpb24oaW5kZW50LCBjb2x1bW4pIHtcbiAgcmV0dXJuIHRoaXMuX19pbmRlbnRfY2FjaGUuZ2V0X2luZGVudF9zaXplKGluZGVudCwgY29sdW1uKTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuaXNfZW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICF0aGlzLnByZXZpb3VzX2xpbmUgJiYgdGhpcy5jdXJyZW50X2xpbmUuaXNfZW1wdHkoKTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuYWRkX25ld19saW5lID0gZnVuY3Rpb24oZm9yY2VfbmV3bGluZSkge1xuICAvLyBuZXZlciBuZXdsaW5lIGF0IHRoZSBzdGFydCBvZiBmaWxlXG4gIC8vIG90aGVyd2lzZSwgbmV3bGluZSBvbmx5IGlmIHdlIGRpZG4ndCBqdXN0IGFkZCBvbmUgb3Igd2UncmUgZm9yY2VkXG4gIGlmICh0aGlzLmlzX2VtcHR5KCkgfHxcbiAgICAoIWZvcmNlX25ld2xpbmUgJiYgdGhpcy5qdXN0X2FkZGVkX25ld2xpbmUoKSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBpZiByYXcgb3V0cHV0IGlzIGVuYWJsZWQsIGRvbid0IHByaW50IGFkZGl0aW9uYWwgbmV3bGluZXMsXG4gIC8vIGJ1dCBzdGlsbCByZXR1cm4gVHJ1ZSBhcyB0aG91Z2ggeW91IGhhZFxuICBpZiAoIXRoaXMucmF3KSB7XG4gICAgdGhpcy5fX2FkZF9vdXRwdXRsaW5lKCk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmdldF9jb2RlID0gZnVuY3Rpb24oZW9sKSB7XG4gIHRoaXMudHJpbSh0cnVlKTtcblxuICAvLyBoYW5kbGUgc29tZSBlZGdlIGNhc2VzIHdoZXJlIHRoZSBsYXN0IHRva2Vuc1xuICAvLyBoYXMgdGV4dCB0aGF0IGVuZHMgd2l0aCBuZXdsaW5lKHMpXG4gIHZhciBsYXN0X2l0ZW0gPSB0aGlzLmN1cnJlbnRfbGluZS5wb3AoKTtcbiAgaWYgKGxhc3RfaXRlbSkge1xuICAgIGlmIChsYXN0X2l0ZW1bbGFzdF9pdGVtLmxlbmd0aCAtIDFdID09PSAnXFxuJykge1xuICAgICAgbGFzdF9pdGVtID0gbGFzdF9pdGVtLnJlcGxhY2UoL1xcbiskL2csICcnKTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50X2xpbmUucHVzaChsYXN0X2l0ZW0pO1xuICB9XG5cbiAgaWYgKHRoaXMuX2VuZF93aXRoX25ld2xpbmUpIHtcbiAgICB0aGlzLl9fYWRkX291dHB1dGxpbmUoKTtcbiAgfVxuXG4gIHZhciBzd2VldF9jb2RlID0gdGhpcy5fX2xpbmVzLmpvaW4oJ1xcbicpO1xuXG4gIGlmIChlb2wgIT09ICdcXG4nKSB7XG4gICAgc3dlZXRfY29kZSA9IHN3ZWV0X2NvZGUucmVwbGFjZSgvW1xcbl0vZywgZW9sKTtcbiAgfVxuICByZXR1cm4gc3dlZXRfY29kZTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuc2V0X3dyYXBfcG9pbnQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jdXJyZW50X2xpbmUuX3NldF93cmFwX3BvaW50KCk7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLnNldF9pbmRlbnQgPSBmdW5jdGlvbihpbmRlbnQsIGFsaWdubWVudCkge1xuICBpbmRlbnQgPSBpbmRlbnQgfHwgMDtcbiAgYWxpZ25tZW50ID0gYWxpZ25tZW50IHx8IDA7XG5cbiAgLy8gTmV4dCBsaW5lIHN0b3JlcyBhbGlnbm1lbnQgdmFsdWVzXG4gIHRoaXMubmV4dF9saW5lLnNldF9pbmRlbnQoaW5kZW50LCBhbGlnbm1lbnQpO1xuXG4gIC8vIE5ldmVyIGluZGVudCB5b3VyIGZpcnN0IG91dHB1dCBpbmRlbnQgYXQgdGhlIHN0YXJ0IG9mIHRoZSBmaWxlXG4gIGlmICh0aGlzLl9fbGluZXMubGVuZ3RoID4gMSkge1xuICAgIHRoaXMuY3VycmVudF9saW5lLnNldF9pbmRlbnQoaW5kZW50LCBhbGlnbm1lbnQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdGhpcy5jdXJyZW50X2xpbmUuc2V0X2luZGVudCgpO1xuICByZXR1cm4gZmFsc2U7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmFkZF9yYXdfdG9rZW4gPSBmdW5jdGlvbih0b2tlbikge1xuICBmb3IgKHZhciB4ID0gMDsgeCA8IHRva2VuLm5ld2xpbmVzOyB4KyspIHtcbiAgICB0aGlzLl9fYWRkX291dHB1dGxpbmUoKTtcbiAgfVxuICB0aGlzLmN1cnJlbnRfbGluZS5zZXRfaW5kZW50KC0xKTtcbiAgdGhpcy5jdXJyZW50X2xpbmUucHVzaCh0b2tlbi53aGl0ZXNwYWNlX2JlZm9yZSk7XG4gIHRoaXMuY3VycmVudF9saW5lLnB1c2godG9rZW4udGV4dCk7XG4gIHRoaXMuc3BhY2VfYmVmb3JlX3Rva2VuID0gZmFsc2U7XG4gIHRoaXMubm9uX2JyZWFraW5nX3NwYWNlID0gZmFsc2U7XG4gIHRoaXMucHJldmlvdXNfdG9rZW5fd3JhcHBlZCA9IGZhbHNlO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5hZGRfdG9rZW4gPSBmdW5jdGlvbihwcmludGFibGVfdG9rZW4pIHtcbiAgdGhpcy5fX2FkZF9zcGFjZV9iZWZvcmVfdG9rZW4oKTtcbiAgdGhpcy5jdXJyZW50X2xpbmUucHVzaChwcmludGFibGVfdG9rZW4pO1xuICB0aGlzLnNwYWNlX2JlZm9yZV90b2tlbiA9IGZhbHNlO1xuICB0aGlzLm5vbl9icmVha2luZ19zcGFjZSA9IGZhbHNlO1xuICB0aGlzLnByZXZpb3VzX3Rva2VuX3dyYXBwZWQgPSB0aGlzLmN1cnJlbnRfbGluZS5fYWxsb3dfd3JhcCgpO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5fX2FkZF9zcGFjZV9iZWZvcmVfdG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuc3BhY2VfYmVmb3JlX3Rva2VuICYmICF0aGlzLmp1c3RfYWRkZWRfbmV3bGluZSgpKSB7XG4gICAgaWYgKCF0aGlzLm5vbl9icmVha2luZ19zcGFjZSkge1xuICAgICAgdGhpcy5zZXRfd3JhcF9wb2ludCgpO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRfbGluZS5wdXNoKCcgJyk7XG4gIH1cbn07XG5cbk91dHB1dC5wcm90b3R5cGUucmVtb3ZlX2luZGVudCA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gIHZhciBvdXRwdXRfbGVuZ3RoID0gdGhpcy5fX2xpbmVzLmxlbmd0aDtcbiAgd2hpbGUgKGluZGV4IDwgb3V0cHV0X2xlbmd0aCkge1xuICAgIHRoaXMuX19saW5lc1tpbmRleF0uX3JlbW92ZV9pbmRlbnQoKTtcbiAgICBpbmRleCsrO1xuICB9XG4gIHRoaXMuY3VycmVudF9saW5lLl9yZW1vdmVfd3JhcF9pbmRlbnQoKTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUudHJpbSA9IGZ1bmN0aW9uKGVhdF9uZXdsaW5lcykge1xuICBlYXRfbmV3bGluZXMgPSAoZWF0X25ld2xpbmVzID09PSB1bmRlZmluZWQpID8gZmFsc2UgOiBlYXRfbmV3bGluZXM7XG5cbiAgdGhpcy5jdXJyZW50X2xpbmUudHJpbSgpO1xuXG4gIHdoaWxlIChlYXRfbmV3bGluZXMgJiYgdGhpcy5fX2xpbmVzLmxlbmd0aCA+IDEgJiZcbiAgICB0aGlzLmN1cnJlbnRfbGluZS5pc19lbXB0eSgpKSB7XG4gICAgdGhpcy5fX2xpbmVzLnBvcCgpO1xuICAgIHRoaXMuY3VycmVudF9saW5lID0gdGhpcy5fX2xpbmVzW3RoaXMuX19saW5lcy5sZW5ndGggLSAxXTtcbiAgICB0aGlzLmN1cnJlbnRfbGluZS50cmltKCk7XG4gIH1cblxuICB0aGlzLnByZXZpb3VzX2xpbmUgPSB0aGlzLl9fbGluZXMubGVuZ3RoID4gMSA/XG4gICAgdGhpcy5fX2xpbmVzW3RoaXMuX19saW5lcy5sZW5ndGggLSAyXSA6IG51bGw7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmp1c3RfYWRkZWRfbmV3bGluZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5jdXJyZW50X2xpbmUuaXNfZW1wdHkoKTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuanVzdF9hZGRlZF9ibGFua2xpbmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuaXNfZW1wdHkoKSB8fFxuICAgICh0aGlzLmN1cnJlbnRfbGluZS5pc19lbXB0eSgpICYmIHRoaXMucHJldmlvdXNfbGluZS5pc19lbXB0eSgpKTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuZW5zdXJlX2VtcHR5X2xpbmVfYWJvdmUgPSBmdW5jdGlvbihzdGFydHNfd2l0aCwgZW5kc193aXRoKSB7XG4gIHZhciBpbmRleCA9IHRoaXMuX19saW5lcy5sZW5ndGggLSAyO1xuICB3aGlsZSAoaW5kZXggPj0gMCkge1xuICAgIHZhciBwb3RlbnRpYWxFbXB0eUxpbmUgPSB0aGlzLl9fbGluZXNbaW5kZXhdO1xuICAgIGlmIChwb3RlbnRpYWxFbXB0eUxpbmUuaXNfZW1wdHkoKSkge1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIGlmIChwb3RlbnRpYWxFbXB0eUxpbmUuaXRlbSgwKS5pbmRleE9mKHN0YXJ0c193aXRoKSAhPT0gMCAmJlxuICAgICAgcG90ZW50aWFsRW1wdHlMaW5lLml0ZW0oLTEpICE9PSBlbmRzX3dpdGgpIHtcbiAgICAgIHRoaXMuX19saW5lcy5zcGxpY2UoaW5kZXggKyAxLCAwLCBuZXcgT3V0cHV0TGluZSh0aGlzKSk7XG4gICAgICB0aGlzLnByZXZpb3VzX2xpbmUgPSB0aGlzLl9fbGluZXNbdGhpcy5fX2xpbmVzLmxlbmd0aCAtIDJdO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGluZGV4LS07XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLk91dHB1dCA9IE91dHB1dDtcblxuXG4vKioqLyB9KSxcbi8qIDMgKi8sXG4vKiA0ICovLFxuLyogNSAqLyxcbi8qIDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG5mdW5jdGlvbiBPcHRpb25zKG9wdGlvbnMsIG1lcmdlX2NoaWxkX2ZpZWxkKSB7XG4gIHRoaXMucmF3X29wdGlvbnMgPSBfbWVyZ2VPcHRzKG9wdGlvbnMsIG1lcmdlX2NoaWxkX2ZpZWxkKTtcblxuICAvLyBTdXBwb3J0IHBhc3NpbmcgdGhlIHNvdXJjZSB0ZXh0IGJhY2sgd2l0aCBubyBjaGFuZ2VcbiAgdGhpcy5kaXNhYmxlZCA9IHRoaXMuX2dldF9ib29sZWFuKCdkaXNhYmxlZCcpO1xuXG4gIHRoaXMuZW9sID0gdGhpcy5fZ2V0X2NoYXJhY3RlcnMoJ2VvbCcsICdhdXRvJyk7XG4gIHRoaXMuZW5kX3dpdGhfbmV3bGluZSA9IHRoaXMuX2dldF9ib29sZWFuKCdlbmRfd2l0aF9uZXdsaW5lJyk7XG4gIHRoaXMuaW5kZW50X3NpemUgPSB0aGlzLl9nZXRfbnVtYmVyKCdpbmRlbnRfc2l6ZScsIDQpO1xuICB0aGlzLmluZGVudF9jaGFyID0gdGhpcy5fZ2V0X2NoYXJhY3RlcnMoJ2luZGVudF9jaGFyJywgJyAnKTtcbiAgdGhpcy5pbmRlbnRfbGV2ZWwgPSB0aGlzLl9nZXRfbnVtYmVyKCdpbmRlbnRfbGV2ZWwnKTtcblxuICB0aGlzLnByZXNlcnZlX25ld2xpbmVzID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ3ByZXNlcnZlX25ld2xpbmVzJywgdHJ1ZSk7XG4gIHRoaXMubWF4X3ByZXNlcnZlX25ld2xpbmVzID0gdGhpcy5fZ2V0X251bWJlcignbWF4X3ByZXNlcnZlX25ld2xpbmVzJywgMzI3ODYpO1xuICBpZiAoIXRoaXMucHJlc2VydmVfbmV3bGluZXMpIHtcbiAgICB0aGlzLm1heF9wcmVzZXJ2ZV9uZXdsaW5lcyA9IDA7XG4gIH1cblxuICB0aGlzLmluZGVudF93aXRoX3RhYnMgPSB0aGlzLl9nZXRfYm9vbGVhbignaW5kZW50X3dpdGhfdGFicycsIHRoaXMuaW5kZW50X2NoYXIgPT09ICdcXHQnKTtcbiAgaWYgKHRoaXMuaW5kZW50X3dpdGhfdGFicykge1xuICAgIHRoaXMuaW5kZW50X2NoYXIgPSAnXFx0JztcblxuICAgIC8vIGluZGVudF9zaXplIGJlaGF2aW9yIGNoYW5nZWQgYWZ0ZXIgMS44LjZcbiAgICAvLyBJdCB1c2VkIHRvIGJlIHRoYXQgaW5kZW50X3NpemUgd291bGQgYmVcbiAgICAvLyBzZXQgdG8gMSBmb3IgaW5kZW50X3dpdGhfdGFicy4gVGhhdCBpcyBubyBsb25nZXIgbmVlZGVkIGFuZFxuICAgIC8vIGFjdHVhbGx5IGRvZXNuJ3QgbWFrZSBzZW5zZSAtIHdoeSBub3QgdXNlIHNwYWNlcz8gRnVydGhlcixcbiAgICAvLyB0aGF0IG1pZ2h0IHByb2R1Y2UgdW5leHBlY3RlZCBiZWhhdmlvciAtIHRhYnMgYmVpbmcgdXNlZFxuICAgIC8vIGZvciBzaW5nbGUtY29sdW1uIGFsaWdubWVudC4gU28sIHdoZW4gaW5kZW50X3dpdGhfdGFicyBpcyB0cnVlXG4gICAgLy8gYW5kIGluZGVudF9zaXplIGlzIDEsIHJlc2V0IGluZGVudF9zaXplIHRvIDQuXG4gICAgaWYgKHRoaXMuaW5kZW50X3NpemUgPT09IDEpIHtcbiAgICAgIHRoaXMuaW5kZW50X3NpemUgPSA0O1xuICAgIH1cbiAgfVxuXG4gIC8vIEJhY2t3YXJkcyBjb21wYXQgd2l0aCAxLjMueFxuICB0aGlzLndyYXBfbGluZV9sZW5ndGggPSB0aGlzLl9nZXRfbnVtYmVyKCd3cmFwX2xpbmVfbGVuZ3RoJywgdGhpcy5fZ2V0X251bWJlcignbWF4X2NoYXInKSk7XG5cbiAgdGhpcy5pbmRlbnRfZW1wdHlfbGluZXMgPSB0aGlzLl9nZXRfYm9vbGVhbignaW5kZW50X2VtcHR5X2xpbmVzJyk7XG5cbiAgLy8gdmFsaWQgdGVtcGxhdGluZyBsYW5ndWFnZXMgWydkamFuZ28nLCAnZXJiJywgJ2hhbmRsZWJhcnMnLCAncGhwJywgJ3NtYXJ0eScsICdhbmd1bGFyJ11cbiAgLy8gRm9yIG5vdywgJ2F1dG8nID0gYWxsIG9mZiBmb3IgamF2YXNjcmlwdCwgYWxsIGV4Y2VwdCBhbmd1bGFyIG9uIGZvciBodG1sIChhbmQgaW5saW5lIGphdmFzY3JpcHQvY3NzKS5cbiAgLy8gb3RoZXIgdmFsdWVzIGlnbm9yZWRcbiAgdGhpcy50ZW1wbGF0aW5nID0gdGhpcy5fZ2V0X3NlbGVjdGlvbl9saXN0KCd0ZW1wbGF0aW5nJywgWydhdXRvJywgJ25vbmUnLCAnYW5ndWxhcicsICdkamFuZ28nLCAnZXJiJywgJ2hhbmRsZWJhcnMnLCAncGhwJywgJ3NtYXJ0eSddLCBbJ2F1dG8nXSk7XG59XG5cbk9wdGlvbnMucHJvdG90eXBlLl9nZXRfYXJyYXkgPSBmdW5jdGlvbihuYW1lLCBkZWZhdWx0X3ZhbHVlKSB7XG4gIHZhciBvcHRpb25fdmFsdWUgPSB0aGlzLnJhd19vcHRpb25zW25hbWVdO1xuICB2YXIgcmVzdWx0ID0gZGVmYXVsdF92YWx1ZSB8fCBbXTtcbiAgaWYgKHR5cGVvZiBvcHRpb25fdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKG9wdGlvbl92YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2Ygb3B0aW9uX3ZhbHVlLmNvbmNhdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVzdWx0ID0gb3B0aW9uX3ZhbHVlLmNvbmNhdCgpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9uX3ZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJlc3VsdCA9IG9wdGlvbl92YWx1ZS5zcGxpdCgvW15hLXpBLVowLTlfXFwvXFwtXSsvKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuT3B0aW9ucy5wcm90b3R5cGUuX2dldF9ib29sZWFuID0gZnVuY3Rpb24obmFtZSwgZGVmYXVsdF92YWx1ZSkge1xuICB2YXIgb3B0aW9uX3ZhbHVlID0gdGhpcy5yYXdfb3B0aW9uc1tuYW1lXTtcbiAgdmFyIHJlc3VsdCA9IG9wdGlvbl92YWx1ZSA9PT0gdW5kZWZpbmVkID8gISFkZWZhdWx0X3ZhbHVlIDogISFvcHRpb25fdmFsdWU7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5PcHRpb25zLnByb3RvdHlwZS5fZ2V0X2NoYXJhY3RlcnMgPSBmdW5jdGlvbihuYW1lLCBkZWZhdWx0X3ZhbHVlKSB7XG4gIHZhciBvcHRpb25fdmFsdWUgPSB0aGlzLnJhd19vcHRpb25zW25hbWVdO1xuICB2YXIgcmVzdWx0ID0gZGVmYXVsdF92YWx1ZSB8fCAnJztcbiAgaWYgKHR5cGVvZiBvcHRpb25fdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmVzdWx0ID0gb3B0aW9uX3ZhbHVlLnJlcGxhY2UoL1xcXFxyLywgJ1xccicpLnJlcGxhY2UoL1xcXFxuLywgJ1xcbicpLnJlcGxhY2UoL1xcXFx0LywgJ1xcdCcpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5PcHRpb25zLnByb3RvdHlwZS5fZ2V0X251bWJlciA9IGZ1bmN0aW9uKG5hbWUsIGRlZmF1bHRfdmFsdWUpIHtcbiAgdmFyIG9wdGlvbl92YWx1ZSA9IHRoaXMucmF3X29wdGlvbnNbbmFtZV07XG4gIGRlZmF1bHRfdmFsdWUgPSBwYXJzZUludChkZWZhdWx0X3ZhbHVlLCAxMCk7XG4gIGlmIChpc05hTihkZWZhdWx0X3ZhbHVlKSkge1xuICAgIGRlZmF1bHRfdmFsdWUgPSAwO1xuICB9XG4gIHZhciByZXN1bHQgPSBwYXJzZUludChvcHRpb25fdmFsdWUsIDEwKTtcbiAgaWYgKGlzTmFOKHJlc3VsdCkpIHtcbiAgICByZXN1bHQgPSBkZWZhdWx0X3ZhbHVlO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5PcHRpb25zLnByb3RvdHlwZS5fZ2V0X3NlbGVjdGlvbiA9IGZ1bmN0aW9uKG5hbWUsIHNlbGVjdGlvbl9saXN0LCBkZWZhdWx0X3ZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9nZXRfc2VsZWN0aW9uX2xpc3QobmFtZSwgc2VsZWN0aW9uX2xpc3QsIGRlZmF1bHRfdmFsdWUpO1xuICBpZiAocmVzdWx0Lmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiSW52YWxpZCBPcHRpb24gVmFsdWU6IFRoZSBvcHRpb24gJ1wiICsgbmFtZSArIFwiJyBjYW4gb25seSBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZyB2YWx1ZXM6XFxuXCIgK1xuICAgICAgc2VsZWN0aW9uX2xpc3QgKyBcIlxcbllvdSBwYXNzZWQgaW46ICdcIiArIHRoaXMucmF3X29wdGlvbnNbbmFtZV0gKyBcIidcIik7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0WzBdO1xufTtcblxuXG5PcHRpb25zLnByb3RvdHlwZS5fZ2V0X3NlbGVjdGlvbl9saXN0ID0gZnVuY3Rpb24obmFtZSwgc2VsZWN0aW9uX2xpc3QsIGRlZmF1bHRfdmFsdWUpIHtcbiAgaWYgKCFzZWxlY3Rpb25fbGlzdCB8fCBzZWxlY3Rpb25fbGlzdC5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZWxlY3Rpb24gbGlzdCBjYW5ub3QgYmUgZW1wdHkuXCIpO1xuICB9XG5cbiAgZGVmYXVsdF92YWx1ZSA9IGRlZmF1bHRfdmFsdWUgfHwgW3NlbGVjdGlvbl9saXN0WzBdXTtcbiAgaWYgKCF0aGlzLl9pc192YWxpZF9zZWxlY3Rpb24oZGVmYXVsdF92YWx1ZSwgc2VsZWN0aW9uX2xpc3QpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBEZWZhdWx0IFZhbHVlIVwiKTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSB0aGlzLl9nZXRfYXJyYXkobmFtZSwgZGVmYXVsdF92YWx1ZSk7XG4gIGlmICghdGhpcy5faXNfdmFsaWRfc2VsZWN0aW9uKHJlc3VsdCwgc2VsZWN0aW9uX2xpc3QpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJJbnZhbGlkIE9wdGlvbiBWYWx1ZTogVGhlIG9wdGlvbiAnXCIgKyBuYW1lICsgXCInIGNhbiBjb250YWluIG9ubHkgdGhlIGZvbGxvd2luZyB2YWx1ZXM6XFxuXCIgK1xuICAgICAgc2VsZWN0aW9uX2xpc3QgKyBcIlxcbllvdSBwYXNzZWQgaW46ICdcIiArIHRoaXMucmF3X29wdGlvbnNbbmFtZV0gKyBcIidcIik7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuT3B0aW9ucy5wcm90b3R5cGUuX2lzX3ZhbGlkX3NlbGVjdGlvbiA9IGZ1bmN0aW9uKHJlc3VsdCwgc2VsZWN0aW9uX2xpc3QpIHtcbiAgcmV0dXJuIHJlc3VsdC5sZW5ndGggJiYgc2VsZWN0aW9uX2xpc3QubGVuZ3RoICYmXG4gICAgIXJlc3VsdC5zb21lKGZ1bmN0aW9uKGl0ZW0pIHsgcmV0dXJuIHNlbGVjdGlvbl9saXN0LmluZGV4T2YoaXRlbSkgPT09IC0xOyB9KTtcbn07XG5cblxuLy8gbWVyZ2VzIGNoaWxkIG9wdGlvbnMgdXAgd2l0aCB0aGUgcGFyZW50IG9wdGlvbnMgb2JqZWN0XG4vLyBFeGFtcGxlOiBvYmogPSB7YTogMSwgYjoge2E6IDJ9fVxuLy8gICAgICAgICAgbWVyZ2VPcHRzKG9iaiwgJ2InKVxuLy9cbi8vICAgICAgICAgIFJldHVybnM6IHthOiAyfVxuZnVuY3Rpb24gX21lcmdlT3B0cyhhbGxPcHRpb25zLCBjaGlsZEZpZWxkTmFtZSkge1xuICB2YXIgZmluYWxPcHRzID0ge307XG4gIGFsbE9wdGlvbnMgPSBfbm9ybWFsaXplT3B0cyhhbGxPcHRpb25zKTtcbiAgdmFyIG5hbWU7XG5cbiAgZm9yIChuYW1lIGluIGFsbE9wdGlvbnMpIHtcbiAgICBpZiAobmFtZSAhPT0gY2hpbGRGaWVsZE5hbWUpIHtcbiAgICAgIGZpbmFsT3B0c1tuYW1lXSA9IGFsbE9wdGlvbnNbbmFtZV07XG4gICAgfVxuICB9XG5cbiAgLy9tZXJnZSBpbiB0aGUgcGVyIHR5cGUgc2V0dGluZ3MgZm9yIHRoZSBjaGlsZEZpZWxkTmFtZVxuICBpZiAoY2hpbGRGaWVsZE5hbWUgJiYgYWxsT3B0aW9uc1tjaGlsZEZpZWxkTmFtZV0pIHtcbiAgICBmb3IgKG5hbWUgaW4gYWxsT3B0aW9uc1tjaGlsZEZpZWxkTmFtZV0pIHtcbiAgICAgIGZpbmFsT3B0c1tuYW1lXSA9IGFsbE9wdGlvbnNbY2hpbGRGaWVsZE5hbWVdW25hbWVdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmluYWxPcHRzO1xufVxuXG5mdW5jdGlvbiBfbm9ybWFsaXplT3B0cyhvcHRpb25zKSB7XG4gIHZhciBjb252ZXJ0ZWRPcHRzID0ge307XG4gIHZhciBrZXk7XG5cbiAgZm9yIChrZXkgaW4gb3B0aW9ucykge1xuICAgIHZhciBuZXdLZXkgPSBrZXkucmVwbGFjZSgvLS9nLCBcIl9cIik7XG4gICAgY29udmVydGVkT3B0c1tuZXdLZXldID0gb3B0aW9uc1trZXldO1xuICB9XG4gIHJldHVybiBjb252ZXJ0ZWRPcHRzO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5PcHRpb25zID0gT3B0aW9ucztcbm1vZHVsZS5leHBvcnRzLm5vcm1hbGl6ZU9wdHMgPSBfbm9ybWFsaXplT3B0cztcbm1vZHVsZS5leHBvcnRzLm1lcmdlT3B0cyA9IF9tZXJnZU9wdHM7XG5cblxuLyoqKi8gfSksXG4vKiA3ICovLFxuLyogOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbnZhciByZWdleHBfaGFzX3N0aWNreSA9IFJlZ0V4cC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJ3N0aWNreScpO1xuXG5mdW5jdGlvbiBJbnB1dFNjYW5uZXIoaW5wdXRfc3RyaW5nKSB7XG4gIHRoaXMuX19pbnB1dCA9IGlucHV0X3N0cmluZyB8fCAnJztcbiAgdGhpcy5fX2lucHV0X2xlbmd0aCA9IHRoaXMuX19pbnB1dC5sZW5ndGg7XG4gIHRoaXMuX19wb3NpdGlvbiA9IDA7XG59XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUucmVzdGFydCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9fcG9zaXRpb24gPSAwO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5iYWNrID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9fcG9zaXRpb24gPiAwKSB7XG4gICAgdGhpcy5fX3Bvc2l0aW9uIC09IDE7XG4gIH1cbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUuaGFzTmV4dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fX3Bvc2l0aW9uIDwgdGhpcy5fX2lucHV0X2xlbmd0aDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdmFsID0gbnVsbDtcbiAgaWYgKHRoaXMuaGFzTmV4dCgpKSB7XG4gICAgdmFsID0gdGhpcy5fX2lucHV0LmNoYXJBdCh0aGlzLl9fcG9zaXRpb24pO1xuICAgIHRoaXMuX19wb3NpdGlvbiArPSAxO1xuICB9XG4gIHJldHVybiB2YWw7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbihpbmRleCkge1xuICB2YXIgdmFsID0gbnVsbDtcbiAgaW5kZXggPSBpbmRleCB8fCAwO1xuICBpbmRleCArPSB0aGlzLl9fcG9zaXRpb247XG4gIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5fX2lucHV0X2xlbmd0aCkge1xuICAgIHZhbCA9IHRoaXMuX19pbnB1dC5jaGFyQXQoaW5kZXgpO1xuICB9XG4gIHJldHVybiB2YWw7XG59O1xuXG4vLyBUaGlzIGlzIGEgSmF2YVNjcmlwdCBvbmx5IGhlbHBlciBmdW5jdGlvbiAobm90IGluIHB5dGhvbilcbi8vIEphdmFzY3JpcHQgZG9lc24ndCBoYXZlIGEgbWF0Y2ggbWV0aG9kXG4vLyBhbmQgbm90IGFsbCBpbXBsZW1lbnRhdGlvbiBzdXBwb3J0IFwic3RpY2t5XCIgZmxhZy5cbi8vIElmIHRoZXkgZG8gbm90IHN1cHBvcnQgc3RpY2t5IHRoZW4gYm90aCB0aGlzLm1hdGNoKCkgYW5kIHRoaXMudGVzdCgpIG1ldGhvZFxuLy8gbXVzdCBnZXQgdGhlIG1hdGNoIGFuZCBjaGVjayB0aGUgaW5kZXggb2YgdGhlIG1hdGNoLlxuLy8gSWYgc3RpY2t5IGlzIHN1cHBvcnRlZCBhbmQgc2V0LCB0aGlzIG1ldGhvZCB3aWxsIHVzZSBpdC5cbi8vIE90aGVyd2lzZSBpdCB3aWxsIGNoZWNrIHRoYXQgZ2xvYmFsIGlzIHNldCwgYW5kIGZhbGwgYmFjayB0byB0aGUgc2xvd2VyIG1ldGhvZC5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUuX19tYXRjaCA9IGZ1bmN0aW9uKHBhdHRlcm4sIGluZGV4KSB7XG4gIHBhdHRlcm4ubGFzdEluZGV4ID0gaW5kZXg7XG4gIHZhciBwYXR0ZXJuX21hdGNoID0gcGF0dGVybi5leGVjKHRoaXMuX19pbnB1dCk7XG5cbiAgaWYgKHBhdHRlcm5fbWF0Y2ggJiYgIShyZWdleHBfaGFzX3N0aWNreSAmJiBwYXR0ZXJuLnN0aWNreSkpIHtcbiAgICBpZiAocGF0dGVybl9tYXRjaC5pbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgIHBhdHRlcm5fbWF0Y2ggPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXR0ZXJuX21hdGNoO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS50ZXN0ID0gZnVuY3Rpb24ocGF0dGVybiwgaW5kZXgpIHtcbiAgaW5kZXggPSBpbmRleCB8fCAwO1xuICBpbmRleCArPSB0aGlzLl9fcG9zaXRpb247XG5cbiAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLl9faW5wdXRfbGVuZ3RoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fX21hdGNoKHBhdHRlcm4sIGluZGV4KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUudGVzdENoYXIgPSBmdW5jdGlvbihwYXR0ZXJuLCBpbmRleCkge1xuICAvLyB0ZXN0IG9uZSBjaGFyYWN0ZXIgcmVnZXggbWF0Y2hcbiAgdmFyIHZhbCA9IHRoaXMucGVlayhpbmRleCk7XG4gIHBhdHRlcm4ubGFzdEluZGV4ID0gMDtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiBwYXR0ZXJuLnRlc3QodmFsKTtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gIHZhciBwYXR0ZXJuX21hdGNoID0gdGhpcy5fX21hdGNoKHBhdHRlcm4sIHRoaXMuX19wb3NpdGlvbik7XG4gIGlmIChwYXR0ZXJuX21hdGNoKSB7XG4gICAgdGhpcy5fX3Bvc2l0aW9uICs9IHBhdHRlcm5fbWF0Y2hbMF0ubGVuZ3RoO1xuICB9IGVsc2Uge1xuICAgIHBhdHRlcm5fbWF0Y2ggPSBudWxsO1xuICB9XG4gIHJldHVybiBwYXR0ZXJuX21hdGNoO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24oc3RhcnRpbmdfcGF0dGVybiwgdW50aWxfcGF0dGVybiwgdW50aWxfYWZ0ZXIpIHtcbiAgdmFyIHZhbCA9ICcnO1xuICB2YXIgbWF0Y2g7XG4gIGlmIChzdGFydGluZ19wYXR0ZXJuKSB7XG4gICAgbWF0Y2ggPSB0aGlzLm1hdGNoKHN0YXJ0aW5nX3BhdHRlcm4pO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgdmFsICs9IG1hdGNoWzBdO1xuICAgIH1cbiAgfVxuICBpZiAodW50aWxfcGF0dGVybiAmJiAobWF0Y2ggfHwgIXN0YXJ0aW5nX3BhdHRlcm4pKSB7XG4gICAgdmFsICs9IHRoaXMucmVhZFVudGlsKHVudGlsX3BhdHRlcm4sIHVudGlsX2FmdGVyKTtcbiAgfVxuICByZXR1cm4gdmFsO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5yZWFkVW50aWwgPSBmdW5jdGlvbihwYXR0ZXJuLCB1bnRpbF9hZnRlcikge1xuICB2YXIgdmFsID0gJyc7XG4gIHZhciBtYXRjaF9pbmRleCA9IHRoaXMuX19wb3NpdGlvbjtcbiAgcGF0dGVybi5sYXN0SW5kZXggPSB0aGlzLl9fcG9zaXRpb247XG4gIHZhciBwYXR0ZXJuX21hdGNoID0gcGF0dGVybi5leGVjKHRoaXMuX19pbnB1dCk7XG4gIGlmIChwYXR0ZXJuX21hdGNoKSB7XG4gICAgbWF0Y2hfaW5kZXggPSBwYXR0ZXJuX21hdGNoLmluZGV4O1xuICAgIGlmICh1bnRpbF9hZnRlcikge1xuICAgICAgbWF0Y2hfaW5kZXggKz0gcGF0dGVybl9tYXRjaFswXS5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG1hdGNoX2luZGV4ID0gdGhpcy5fX2lucHV0X2xlbmd0aDtcbiAgfVxuXG4gIHZhbCA9IHRoaXMuX19pbnB1dC5zdWJzdHJpbmcodGhpcy5fX3Bvc2l0aW9uLCBtYXRjaF9pbmRleCk7XG4gIHRoaXMuX19wb3NpdGlvbiA9IG1hdGNoX2luZGV4O1xuICByZXR1cm4gdmFsO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5yZWFkVW50aWxBZnRlciA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgcmV0dXJuIHRoaXMucmVhZFVudGlsKHBhdHRlcm4sIHRydWUpO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5nZXRfcmVnZXhwID0gZnVuY3Rpb24ocGF0dGVybiwgbWF0Y2hfZnJvbSkge1xuICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgdmFyIGZsYWdzID0gJ2cnO1xuICBpZiAobWF0Y2hfZnJvbSAmJiByZWdleHBfaGFzX3N0aWNreSkge1xuICAgIGZsYWdzID0gJ3knO1xuICB9XG4gIC8vIHN0cmluZ3MgYXJlIGNvbnZlcnRlZCB0byByZWdleHBcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSBcInN0cmluZ1wiICYmIHBhdHRlcm4gIT09ICcnKSB7XG4gICAgLy8gcmVzdWx0ID0gbmV3IFJlZ0V4cChwYXR0ZXJuLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpLCBmbGFncyk7XG4gICAgcmVzdWx0ID0gbmV3IFJlZ0V4cChwYXR0ZXJuLCBmbGFncyk7XG4gIH0gZWxzZSBpZiAocGF0dGVybikge1xuICAgIHJlc3VsdCA9IG5ldyBSZWdFeHAocGF0dGVybi5zb3VyY2UsIGZsYWdzKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5nZXRfbGl0ZXJhbF9yZWdleHAgPSBmdW5jdGlvbihsaXRlcmFsX3N0cmluZykge1xuICByZXR1cm4gUmVnRXhwKGxpdGVyYWxfc3RyaW5nLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpKTtcbn07XG5cbi8qIGNzcyBiZWF1dGlmaWVyIGxlZ2FjeSBoZWxwZXJzICovXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLnBlZWtVbnRpbEFmdGVyID0gZnVuY3Rpb24ocGF0dGVybikge1xuICB2YXIgc3RhcnQgPSB0aGlzLl9fcG9zaXRpb247XG4gIHZhciB2YWwgPSB0aGlzLnJlYWRVbnRpbEFmdGVyKHBhdHRlcm4pO1xuICB0aGlzLl9fcG9zaXRpb24gPSBzdGFydDtcbiAgcmV0dXJuIHZhbDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUubG9va0JhY2sgPSBmdW5jdGlvbih0ZXN0VmFsKSB7XG4gIHZhciBzdGFydCA9IHRoaXMuX19wb3NpdGlvbiAtIDE7XG4gIHJldHVybiBzdGFydCA+PSB0ZXN0VmFsLmxlbmd0aCAmJiB0aGlzLl9faW5wdXQuc3Vic3RyaW5nKHN0YXJ0IC0gdGVzdFZhbC5sZW5ndGgsIHN0YXJ0KVxuICAgIC50b0xvd2VyQ2FzZSgpID09PSB0ZXN0VmFsO1xufTtcblxubW9kdWxlLmV4cG9ydHMuSW5wdXRTY2FubmVyID0gSW5wdXRTY2FubmVyO1xuXG5cbi8qKiovIH0pLFxuLyogOSAqLyxcbi8qIDEwICovLFxuLyogMTEgKi8sXG4vKiAxMiAqLyxcbi8qIDEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxuZnVuY3Rpb24gRGlyZWN0aXZlcyhzdGFydF9ibG9ja19wYXR0ZXJuLCBlbmRfYmxvY2tfcGF0dGVybikge1xuICBzdGFydF9ibG9ja19wYXR0ZXJuID0gdHlwZW9mIHN0YXJ0X2Jsb2NrX3BhdHRlcm4gPT09ICdzdHJpbmcnID8gc3RhcnRfYmxvY2tfcGF0dGVybiA6IHN0YXJ0X2Jsb2NrX3BhdHRlcm4uc291cmNlO1xuICBlbmRfYmxvY2tfcGF0dGVybiA9IHR5cGVvZiBlbmRfYmxvY2tfcGF0dGVybiA9PT0gJ3N0cmluZycgPyBlbmRfYmxvY2tfcGF0dGVybiA6IGVuZF9ibG9ja19wYXR0ZXJuLnNvdXJjZTtcbiAgdGhpcy5fX2RpcmVjdGl2ZXNfYmxvY2tfcGF0dGVybiA9IG5ldyBSZWdFeHAoc3RhcnRfYmxvY2tfcGF0dGVybiArIC8gYmVhdXRpZnkoIFxcdytbOl1cXHcrKSsgLy5zb3VyY2UgKyBlbmRfYmxvY2tfcGF0dGVybiwgJ2cnKTtcbiAgdGhpcy5fX2RpcmVjdGl2ZV9wYXR0ZXJuID0gLyAoXFx3KylbOl0oXFx3KykvZztcblxuICB0aGlzLl9fZGlyZWN0aXZlc19lbmRfaWdub3JlX3BhdHRlcm4gPSBuZXcgUmVnRXhwKHN0YXJ0X2Jsb2NrX3BhdHRlcm4gKyAvXFxzYmVhdXRpZnlcXHNpZ25vcmU6ZW5kXFxzLy5zb3VyY2UgKyBlbmRfYmxvY2tfcGF0dGVybiwgJ2cnKTtcbn1cblxuRGlyZWN0aXZlcy5wcm90b3R5cGUuZ2V0X2RpcmVjdGl2ZXMgPSBmdW5jdGlvbih0ZXh0KSB7XG4gIGlmICghdGV4dC5tYXRjaCh0aGlzLl9fZGlyZWN0aXZlc19ibG9ja19wYXR0ZXJuKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGRpcmVjdGl2ZXMgPSB7fTtcbiAgdGhpcy5fX2RpcmVjdGl2ZV9wYXR0ZXJuLmxhc3RJbmRleCA9IDA7XG4gIHZhciBkaXJlY3RpdmVfbWF0Y2ggPSB0aGlzLl9fZGlyZWN0aXZlX3BhdHRlcm4uZXhlYyh0ZXh0KTtcblxuICB3aGlsZSAoZGlyZWN0aXZlX21hdGNoKSB7XG4gICAgZGlyZWN0aXZlc1tkaXJlY3RpdmVfbWF0Y2hbMV1dID0gZGlyZWN0aXZlX21hdGNoWzJdO1xuICAgIGRpcmVjdGl2ZV9tYXRjaCA9IHRoaXMuX19kaXJlY3RpdmVfcGF0dGVybi5leGVjKHRleHQpO1xuICB9XG5cbiAgcmV0dXJuIGRpcmVjdGl2ZXM7XG59O1xuXG5EaXJlY3RpdmVzLnByb3RvdHlwZS5yZWFkSWdub3JlZCA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIHJldHVybiBpbnB1dC5yZWFkVW50aWxBZnRlcih0aGlzLl9fZGlyZWN0aXZlc19lbmRfaWdub3JlX3BhdHRlcm4pO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cy5EaXJlY3RpdmVzID0gRGlyZWN0aXZlcztcblxuXG4vKioqLyB9KSxcbi8qIDE0ICovLFxuLyogMTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbnZhciBCZWF1dGlmaWVyID0gKF9fd2VicGFja19yZXF1aXJlX18oMTYpLkJlYXV0aWZpZXIpLFxuICBPcHRpb25zID0gKF9fd2VicGFja19yZXF1aXJlX18oMTcpLk9wdGlvbnMpO1xuXG5mdW5jdGlvbiBjc3NfYmVhdXRpZnkoc291cmNlX3RleHQsIG9wdGlvbnMpIHtcbiAgdmFyIGJlYXV0aWZpZXIgPSBuZXcgQmVhdXRpZmllcihzb3VyY2VfdGV4dCwgb3B0aW9ucyk7XG4gIHJldHVybiBiZWF1dGlmaWVyLmJlYXV0aWZ5KCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3NzX2JlYXV0aWZ5O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBPcHRpb25zKCk7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbnZhciBPcHRpb25zID0gKF9fd2VicGFja19yZXF1aXJlX18oMTcpLk9wdGlvbnMpO1xudmFyIE91dHB1dCA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpLk91dHB1dCk7XG52YXIgSW5wdXRTY2FubmVyID0gKF9fd2VicGFja19yZXF1aXJlX18oOCkuSW5wdXRTY2FubmVyKTtcbnZhciBEaXJlY3RpdmVzID0gKF9fd2VicGFja19yZXF1aXJlX18oMTMpLkRpcmVjdGl2ZXMpO1xuXG52YXIgZGlyZWN0aXZlc19jb3JlID0gbmV3IERpcmVjdGl2ZXMoL1xcL1xcKi8sIC9cXCpcXC8vKTtcblxudmFyIGxpbmVCcmVhayA9IC9cXHJcXG58W1xcclxcbl0vO1xudmFyIGFsbExpbmVCcmVha3MgPSAvXFxyXFxufFtcXHJcXG5dL2c7XG5cbi8vIHRva2VuaXplclxudmFyIHdoaXRlc3BhY2VDaGFyID0gL1xccy87XG52YXIgd2hpdGVzcGFjZVBhdHRlcm4gPSAvKD86XFxzfFxcbikrL2c7XG52YXIgYmxvY2tfY29tbWVudF9wYXR0ZXJuID0gL1xcL1xcKig/OltcXHNcXFNdKj8pKCg/OlxcKlxcLyl8JCkvZztcbnZhciBjb21tZW50X3BhdHRlcm4gPSAvXFwvXFwvKD86W15cXG5cXHJcXHUyMDI4XFx1MjAyOV0qKS9nO1xuXG5mdW5jdGlvbiBCZWF1dGlmaWVyKHNvdXJjZV90ZXh0LCBvcHRpb25zKSB7XG4gIHRoaXMuX3NvdXJjZV90ZXh0ID0gc291cmNlX3RleHQgfHwgJyc7XG4gIC8vIEFsbG93IHRoZSBzZXR0aW5nIG9mIGxhbmd1YWdlL2ZpbGUtdHlwZSBzcGVjaWZpYyBvcHRpb25zXG4gIC8vIHdpdGggaW5oZXJpdGFuY2Ugb2Ygb3ZlcmFsbCBzZXR0aW5nc1xuICB0aGlzLl9vcHRpb25zID0gbmV3IE9wdGlvbnMob3B0aW9ucyk7XG4gIHRoaXMuX2NoID0gbnVsbDtcbiAgdGhpcy5faW5wdXQgPSBudWxsO1xuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9BdC1ydWxlXG4gIHRoaXMuTkVTVEVEX0FUX1JVTEUgPSB7XG4gICAgXCJwYWdlXCI6IHRydWUsXG4gICAgXCJmb250LWZhY2VcIjogdHJ1ZSxcbiAgICBcImtleWZyYW1lc1wiOiB0cnVlLFxuICAgIC8vIGFsc28gaW4gQ09ORElUSU9OQUxfR1JPVVBfUlVMRSBiZWxvd1xuICAgIFwibWVkaWFcIjogdHJ1ZSxcbiAgICBcInN1cHBvcnRzXCI6IHRydWUsXG4gICAgXCJkb2N1bWVudFwiOiB0cnVlXG4gIH07XG4gIHRoaXMuQ09ORElUSU9OQUxfR1JPVVBfUlVMRSA9IHtcbiAgICBcIm1lZGlhXCI6IHRydWUsXG4gICAgXCJzdXBwb3J0c1wiOiB0cnVlLFxuICAgIFwiZG9jdW1lbnRcIjogdHJ1ZVxuICB9O1xuICB0aGlzLk5PTl9TRU1JQ09MT05fTkVXTElORV9QUk9QRVJUWSA9IFtcbiAgICBcImdyaWQtdGVtcGxhdGUtYXJlYXNcIixcbiAgICBcImdyaWQtdGVtcGxhdGVcIlxuICBdO1xuXG59XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmVhdFN0cmluZyA9IGZ1bmN0aW9uKGVuZENoYXJzKSB7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgdGhpcy5fY2ggPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gIHdoaWxlICh0aGlzLl9jaCkge1xuICAgIHJlc3VsdCArPSB0aGlzLl9jaDtcbiAgICBpZiAodGhpcy5fY2ggPT09IFwiXFxcXFwiKSB7XG4gICAgICByZXN1bHQgKz0gdGhpcy5faW5wdXQubmV4dCgpO1xuICAgIH0gZWxzZSBpZiAoZW5kQ2hhcnMuaW5kZXhPZih0aGlzLl9jaCkgIT09IC0xIHx8IHRoaXMuX2NoID09PSBcIlxcblwiKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5fY2ggPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIFNraXBzIGFueSB3aGl0ZSBzcGFjZSBpbiB0aGUgc291cmNlIHRleHQgZnJvbSB0aGUgY3VycmVudCBwb3NpdGlvbi5cbi8vIFdoZW4gYWxsb3dBdExlYXN0T25lTmV3TGluZSBpcyB0cnVlLCB3aWxsIG91dHB1dCBuZXcgbGluZXMgZm9yIGVhY2hcbi8vIG5ld2xpbmUgY2hhcmFjdGVyIGZvdW5kOyBpZiB0aGUgdXNlciBoYXMgcHJlc2VydmVfbmV3bGluZXMgb2ZmLCBvbmx5XG4vLyB0aGUgZmlyc3QgbmV3bGluZSB3aWxsIGJlIG91dHB1dFxuQmVhdXRpZmllci5wcm90b3R5cGUuZWF0V2hpdGVzcGFjZSA9IGZ1bmN0aW9uKGFsbG93QXRMZWFzdE9uZU5ld0xpbmUpIHtcbiAgdmFyIHJlc3VsdCA9IHdoaXRlc3BhY2VDaGFyLnRlc3QodGhpcy5faW5wdXQucGVlaygpKTtcbiAgdmFyIG5ld2xpbmVfY291bnQgPSAwO1xuICB3aGlsZSAod2hpdGVzcGFjZUNoYXIudGVzdCh0aGlzLl9pbnB1dC5wZWVrKCkpKSB7XG4gICAgdGhpcy5fY2ggPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgaWYgKGFsbG93QXRMZWFzdE9uZU5ld0xpbmUgJiYgdGhpcy5fY2ggPT09ICdcXG4nKSB7XG4gICAgICBpZiAobmV3bGluZV9jb3VudCA9PT0gMCB8fCBuZXdsaW5lX2NvdW50IDwgdGhpcy5fb3B0aW9ucy5tYXhfcHJlc2VydmVfbmV3bGluZXMpIHtcbiAgICAgICAgbmV3bGluZV9jb3VudCsrO1xuICAgICAgICB0aGlzLl9vdXRwdXQuYWRkX25ld19saW5lKHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gTmVzdGVkIHBzZXVkby1jbGFzcyBpZiB3ZSBhcmUgaW5zaWRlUnVsZVxuLy8gYW5kIHRoZSBuZXh0IHNwZWNpYWwgY2hhcmFjdGVyIGZvdW5kIG9wZW5zXG4vLyBhIG5ldyBibG9ja1xuQmVhdXRpZmllci5wcm90b3R5cGUuZm91bmROZXN0ZWRQc2V1ZG9DbGFzcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgb3BlblBhcmVuID0gMDtcbiAgdmFyIGkgPSAxO1xuICB2YXIgY2ggPSB0aGlzLl9pbnB1dC5wZWVrKGkpO1xuICB3aGlsZSAoY2gpIHtcbiAgICBpZiAoY2ggPT09IFwie1wiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGNoID09PSAnKCcpIHtcbiAgICAgIC8vIHBzZXVkb2NsYXNzZXMgY2FuIGNvbnRhaW4gKClcbiAgICAgIG9wZW5QYXJlbiArPSAxO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09ICcpJykge1xuICAgICAgaWYgKG9wZW5QYXJlbiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvcGVuUGFyZW4gLT0gMTtcbiAgICB9IGVsc2UgaWYgKGNoID09PSBcIjtcIiB8fCBjaCA9PT0gXCJ9XCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaSsrO1xuICAgIGNoID0gdGhpcy5faW5wdXQucGVlayhpKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5wcmludF9zdHJpbmcgPSBmdW5jdGlvbihvdXRwdXRfc3RyaW5nKSB7XG4gIHRoaXMuX291dHB1dC5zZXRfaW5kZW50KHRoaXMuX2luZGVudExldmVsKTtcbiAgdGhpcy5fb3V0cHV0Lm5vbl9icmVha2luZ19zcGFjZSA9IHRydWU7XG4gIHRoaXMuX291dHB1dC5hZGRfdG9rZW4ob3V0cHV0X3N0cmluZyk7XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5wcmVzZXJ2ZVNpbmdsZVNwYWNlID0gZnVuY3Rpb24oaXNBZnRlclNwYWNlKSB7XG4gIGlmIChpc0FmdGVyU3BhY2UpIHtcbiAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgfVxufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuaW5kZW50ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2luZGVudExldmVsKys7XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5vdXRkZW50ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9pbmRlbnRMZXZlbCA+IDApIHtcbiAgICB0aGlzLl9pbmRlbnRMZXZlbC0tO1xuICB9XG59O1xuXG4vKl9fX19fX19fX19fX19fX19fX19fXy0tLS0tLS0tLS0tLS0tLS0tLS0tX19fX19fX19fX19fX19fX19fX19fKi9cblxuQmVhdXRpZmllci5wcm90b3R5cGUuYmVhdXRpZnkgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX29wdGlvbnMuZGlzYWJsZWQpIHtcbiAgICByZXR1cm4gdGhpcy5fc291cmNlX3RleHQ7XG4gIH1cblxuICB2YXIgc291cmNlX3RleHQgPSB0aGlzLl9zb3VyY2VfdGV4dDtcbiAgdmFyIGVvbCA9IHRoaXMuX29wdGlvbnMuZW9sO1xuICBpZiAoZW9sID09PSAnYXV0bycpIHtcbiAgICBlb2wgPSAnXFxuJztcbiAgICBpZiAoc291cmNlX3RleHQgJiYgbGluZUJyZWFrLnRlc3Qoc291cmNlX3RleHQgfHwgJycpKSB7XG4gICAgICBlb2wgPSBzb3VyY2VfdGV4dC5tYXRjaChsaW5lQnJlYWspWzBdO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gSEFDSzogbmV3bGluZSBwYXJzaW5nIGluY29uc2lzdGVudC4gVGhpcyBicnV0ZSBmb3JjZSBub3JtYWxpemVzIHRoZSB0aGlzLl9pbnB1dC5cbiAgc291cmNlX3RleHQgPSBzb3VyY2VfdGV4dC5yZXBsYWNlKGFsbExpbmVCcmVha3MsICdcXG4nKTtcblxuICAvLyByZXNldFxuICB2YXIgYmFzZUluZGVudFN0cmluZyA9IHNvdXJjZV90ZXh0Lm1hdGNoKC9eW1xcdCBdKi8pWzBdO1xuXG4gIHRoaXMuX291dHB1dCA9IG5ldyBPdXRwdXQodGhpcy5fb3B0aW9ucywgYmFzZUluZGVudFN0cmluZyk7XG4gIHRoaXMuX2lucHV0ID0gbmV3IElucHV0U2Nhbm5lcihzb3VyY2VfdGV4dCk7XG4gIHRoaXMuX2luZGVudExldmVsID0gMDtcbiAgdGhpcy5fbmVzdGVkTGV2ZWwgPSAwO1xuXG4gIHRoaXMuX2NoID0gbnVsbDtcbiAgdmFyIHBhcmVuTGV2ZWwgPSAwO1xuXG4gIHZhciBpbnNpZGVSdWxlID0gZmFsc2U7XG4gIC8vIFRoaXMgaXMgdGhlIHZhbHVlIHNpZGUgb2YgYSBwcm9wZXJ0eSB2YWx1ZSBwYWlyIChibHVlIGluIHRoZSBmb2xsb3dpbmcgZXgpXG4gIC8vIGxhYmVsIHsgY29udGVudDogYmx1ZSB9XG4gIHZhciBpbnNpZGVQcm9wZXJ0eVZhbHVlID0gZmFsc2U7XG4gIHZhciBlbnRlcmluZ0NvbmRpdGlvbmFsR3JvdXAgPSBmYWxzZTtcbiAgdmFyIGluc2lkZU5vbk5lc3RlZEF0UnVsZSA9IGZhbHNlO1xuICB2YXIgaW5zaWRlU2Nzc01hcCA9IGZhbHNlO1xuICB2YXIgdG9wQ2hhcmFjdGVyID0gdGhpcy5fY2g7XG4gIHZhciBpbnNpZGVOb25TZW1pQ29sb25WYWx1ZXMgPSBmYWxzZTtcbiAgdmFyIHdoaXRlc3BhY2U7XG4gIHZhciBpc0FmdGVyU3BhY2U7XG4gIHZhciBwcmV2aW91c19jaDtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHdoaXRlc3BhY2UgPSB0aGlzLl9pbnB1dC5yZWFkKHdoaXRlc3BhY2VQYXR0ZXJuKTtcbiAgICBpc0FmdGVyU3BhY2UgPSB3aGl0ZXNwYWNlICE9PSAnJztcbiAgICBwcmV2aW91c19jaCA9IHRvcENoYXJhY3RlcjtcbiAgICB0aGlzLl9jaCA9IHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICBpZiAodGhpcy5fY2ggPT09ICdcXFxcJyAmJiB0aGlzLl9pbnB1dC5oYXNOZXh0KCkpIHtcbiAgICAgIHRoaXMuX2NoICs9IHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICB9XG4gICAgdG9wQ2hhcmFjdGVyID0gdGhpcy5fY2g7XG5cbiAgICBpZiAoIXRoaXMuX2NoKSB7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2NoID09PSAnLycgJiYgdGhpcy5faW5wdXQucGVlaygpID09PSAnKicpIHtcbiAgICAgIC8vIC8qIGNzcyBjb21tZW50ICovXG4gICAgICAvLyBBbHdheXMgc3RhcnQgYmxvY2sgY29tbWVudHMgb24gYSBuZXcgbGluZS5cbiAgICAgIC8vIFRoaXMgaGFuZGxlcyBzY2VuYXJpb3Mgd2hlcmUgYSBibG9jayBjb21tZW50IGltbWVkaWF0ZWx5XG4gICAgICAvLyBmb2xsb3dzIGEgcHJvcGVydHkgZGVmaW5pdGlvbiBvbiB0aGUgc2FtZSBsaW5lIG9yIHdoZXJlXG4gICAgICAvLyBtaW5pZmllZCBjb2RlIGlzIGJlaW5nIGJlYXV0aWZpZWQuXG4gICAgICB0aGlzLl9vdXRwdXQuYWRkX25ld19saW5lKCk7XG4gICAgICB0aGlzLl9pbnB1dC5iYWNrKCk7XG5cbiAgICAgIHZhciBjb21tZW50ID0gdGhpcy5faW5wdXQucmVhZChibG9ja19jb21tZW50X3BhdHRlcm4pO1xuXG4gICAgICAvLyBIYW5kbGUgaWdub3JlIGRpcmVjdGl2ZVxuICAgICAgdmFyIGRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzX2NvcmUuZ2V0X2RpcmVjdGl2ZXMoY29tbWVudCk7XG4gICAgICBpZiAoZGlyZWN0aXZlcyAmJiBkaXJlY3RpdmVzLmlnbm9yZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICBjb21tZW50ICs9IGRpcmVjdGl2ZXNfY29yZS5yZWFkSWdub3JlZCh0aGlzLl9pbnB1dCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucHJpbnRfc3RyaW5nKGNvbW1lbnQpO1xuXG4gICAgICAvLyBFbnN1cmVzIGFueSBuZXcgbGluZXMgZm9sbG93aW5nIHRoZSBjb21tZW50IGFyZSBwcmVzZXJ2ZWRcbiAgICAgIHRoaXMuZWF0V2hpdGVzcGFjZSh0cnVlKTtcblxuICAgICAgLy8gQmxvY2sgY29tbWVudHMgYXJlIGZvbGxvd2VkIGJ5IGEgbmV3IGxpbmUgc28gdGhleSBkb24ndFxuICAgICAgLy8gc2hhcmUgYSBsaW5lIHdpdGggb3RoZXIgcHJvcGVydGllc1xuICAgICAgdGhpcy5fb3V0cHV0LmFkZF9uZXdfbGluZSgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fY2ggPT09ICcvJyAmJiB0aGlzLl9pbnB1dC5wZWVrKCkgPT09ICcvJykge1xuICAgICAgLy8gLy8gc2luZ2xlIGxpbmUgY29tbWVudFxuICAgICAgLy8gUHJlc2VydmVzIHRoZSBzcGFjZSBiZWZvcmUgYSBjb21tZW50XG4gICAgICAvLyBvbiB0aGUgc2FtZSBsaW5lIGFzIGEgcnVsZVxuICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICB0aGlzLl9pbnB1dC5iYWNrKCk7XG4gICAgICB0aGlzLnByaW50X3N0cmluZyh0aGlzLl9pbnB1dC5yZWFkKGNvbW1lbnRfcGF0dGVybikpO1xuXG4gICAgICAvLyBFbnN1cmVzIGFueSBuZXcgbGluZXMgZm9sbG93aW5nIHRoZSBjb21tZW50IGFyZSBwcmVzZXJ2ZWRcbiAgICAgIHRoaXMuZWF0V2hpdGVzcGFjZSh0cnVlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2NoID09PSAnJCcpIHtcbiAgICAgIHRoaXMucHJlc2VydmVTaW5nbGVTcGFjZShpc0FmdGVyU3BhY2UpO1xuXG4gICAgICB0aGlzLnByaW50X3N0cmluZyh0aGlzLl9jaCk7XG5cbiAgICAgIC8vIHN0cmlwIHRyYWlsaW5nIHNwYWNlLCBpZiBwcmVzZW50LCBmb3IgaGFzaCBwcm9wZXJ0eSBjaGVja3NcbiAgICAgIHZhciB2YXJpYWJsZSA9IHRoaXMuX2lucHV0LnBlZWtVbnRpbEFmdGVyKC9bOiAsO3t9KClbXFxdXFwvPSdcIl0vZyk7XG5cbiAgICAgIGlmICh2YXJpYWJsZS5tYXRjaCgvWyA6XSQvKSkge1xuICAgICAgICAvLyB3ZSBoYXZlIGEgdmFyaWFibGUgb3IgcHNldWRvLWNsYXNzLCBhZGQgaXQgYW5kIGluc2VydCBvbmUgc3BhY2UgYmVmb3JlIGNvbnRpbnVpbmdcbiAgICAgICAgdmFyaWFibGUgPSB0aGlzLmVhdFN0cmluZyhcIjogXCIpLnJlcGxhY2UoL1xccyskLywgJycpO1xuICAgICAgICB0aGlzLnByaW50X3N0cmluZyh2YXJpYWJsZSk7XG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBtaWdodCBiZSBzYXNzIHZhcmlhYmxlXG4gICAgICBpZiAocGFyZW5MZXZlbCA9PT0gMCAmJiB2YXJpYWJsZS5pbmRleE9mKCc6JykgIT09IC0xKSB7XG4gICAgICAgIGluc2lkZVByb3BlcnR5VmFsdWUgPSB0cnVlO1xuICAgICAgICB0aGlzLmluZGVudCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fY2ggPT09ICdAJykge1xuICAgICAgdGhpcy5wcmVzZXJ2ZVNpbmdsZVNwYWNlKGlzQWZ0ZXJTcGFjZSk7XG5cbiAgICAgIC8vIGRlYWwgd2l0aCBsZXNzIHByb3BlcnR5IG1peGlucyBAey4uLn1cbiAgICAgIGlmICh0aGlzLl9pbnB1dC5wZWVrKCkgPT09ICd7Jykge1xuICAgICAgICB0aGlzLnByaW50X3N0cmluZyh0aGlzLl9jaCArIHRoaXMuZWF0U3RyaW5nKCd9JykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmludF9zdHJpbmcodGhpcy5fY2gpO1xuXG4gICAgICAgIC8vIHN0cmlwIHRyYWlsaW5nIHNwYWNlLCBpZiBwcmVzZW50LCBmb3IgaGFzaCBwcm9wZXJ0eSBjaGVja3NcbiAgICAgICAgdmFyIHZhcmlhYmxlT3JSdWxlID0gdGhpcy5faW5wdXQucGVla1VudGlsQWZ0ZXIoL1s6ICw7e30oKVtcXF1cXC89J1wiXS9nKTtcblxuICAgICAgICBpZiAodmFyaWFibGVPclJ1bGUubWF0Y2goL1sgOl0kLykpIHtcbiAgICAgICAgICAvLyB3ZSBoYXZlIGEgdmFyaWFibGUgb3IgcHNldWRvLWNsYXNzLCBhZGQgaXQgYW5kIGluc2VydCBvbmUgc3BhY2UgYmVmb3JlIGNvbnRpbnVpbmdcbiAgICAgICAgICB2YXJpYWJsZU9yUnVsZSA9IHRoaXMuZWF0U3RyaW5nKFwiOiBcIikucmVwbGFjZSgvXFxzKyQvLCAnJyk7XG4gICAgICAgICAgdGhpcy5wcmludF9zdHJpbmcodmFyaWFibGVPclJ1bGUpO1xuICAgICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWlnaHQgYmUgbGVzcyB2YXJpYWJsZVxuICAgICAgICBpZiAocGFyZW5MZXZlbCA9PT0gMCAmJiB2YXJpYWJsZU9yUnVsZS5pbmRleE9mKCc6JykgIT09IC0xKSB7XG4gICAgICAgICAgaW5zaWRlUHJvcGVydHlWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgdGhpcy5pbmRlbnQoKTtcblxuICAgICAgICAgIC8vIG1pZ2h0IGJlIGEgbmVzdGluZyBhdC1ydWxlXG4gICAgICAgIH0gZWxzZSBpZiAodmFyaWFibGVPclJ1bGUgaW4gdGhpcy5ORVNURURfQVRfUlVMRSkge1xuICAgICAgICAgIHRoaXMuX25lc3RlZExldmVsICs9IDE7XG4gICAgICAgICAgaWYgKHZhcmlhYmxlT3JSdWxlIGluIHRoaXMuQ09ORElUSU9OQUxfR1JPVVBfUlVMRSkge1xuICAgICAgICAgICAgZW50ZXJpbmdDb25kaXRpb25hbEdyb3VwID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBtaWdodCBiZSBhIG5vbi1uZXN0ZWQgYXQtcnVsZVxuICAgICAgICB9IGVsc2UgaWYgKHBhcmVuTGV2ZWwgPT09IDAgJiYgIWluc2lkZVByb3BlcnR5VmFsdWUpIHtcbiAgICAgICAgICBpbnNpZGVOb25OZXN0ZWRBdFJ1bGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9jaCA9PT0gJyMnICYmIHRoaXMuX2lucHV0LnBlZWsoKSA9PT0gJ3snKSB7XG4gICAgICB0aGlzLnByZXNlcnZlU2luZ2xlU3BhY2UoaXNBZnRlclNwYWNlKTtcbiAgICAgIHRoaXMucHJpbnRfc3RyaW5nKHRoaXMuX2NoICsgdGhpcy5lYXRTdHJpbmcoJ30nKSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9jaCA9PT0gJ3snKSB7XG4gICAgICBpZiAoaW5zaWRlUHJvcGVydHlWYWx1ZSkge1xuICAgICAgICBpbnNpZGVQcm9wZXJ0eVZhbHVlID0gZmFsc2U7XG4gICAgICAgIHRoaXMub3V0ZGVudCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBub24gbmVzdGVkIGF0IHJ1bGUgYmVjb21lcyBuZXN0ZWRcbiAgICAgIGluc2lkZU5vbk5lc3RlZEF0UnVsZSA9IGZhbHNlO1xuXG4gICAgICAvLyB3aGVuIGVudGVyaW5nIGNvbmRpdGlvbmFsIGdyb3Vwcywgb25seSBydWxlc2V0cyBhcmUgYWxsb3dlZFxuICAgICAgaWYgKGVudGVyaW5nQ29uZGl0aW9uYWxHcm91cCkge1xuICAgICAgICBlbnRlcmluZ0NvbmRpdGlvbmFsR3JvdXAgPSBmYWxzZTtcbiAgICAgICAgaW5zaWRlUnVsZSA9ICh0aGlzLl9pbmRlbnRMZXZlbCA+PSB0aGlzLl9uZXN0ZWRMZXZlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBvdGhlcndpc2UsIGRlY2xhcmF0aW9ucyBhcmUgYWxzbyBhbGxvd2VkXG4gICAgICAgIGluc2lkZVJ1bGUgPSAodGhpcy5faW5kZW50TGV2ZWwgPj0gdGhpcy5fbmVzdGVkTGV2ZWwgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9vcHRpb25zLm5ld2xpbmVfYmV0d2Vlbl9ydWxlcyAmJiBpbnNpZGVSdWxlKSB7XG4gICAgICAgIGlmICh0aGlzLl9vdXRwdXQucHJldmlvdXNfbGluZSAmJiB0aGlzLl9vdXRwdXQucHJldmlvdXNfbGluZS5pdGVtKC0xKSAhPT0gJ3snKSB7XG4gICAgICAgICAgdGhpcy5fb3V0cHV0LmVuc3VyZV9lbXB0eV9saW5lX2Fib3ZlKCcvJywgJywnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcblxuICAgICAgLy8gVGhlIGRpZmZlcmVuY2UgaW4gcHJpbnRfc3RyaW5nIGFuZCBpbmRlbnQgb3JkZXIgaXMgbmVjZXNzYXJ5IHRvIGluZGVudCB0aGUgJ3snIGNvcnJlY3RseVxuICAgICAgaWYgKHRoaXMuX29wdGlvbnMuYnJhY2Vfc3R5bGUgPT09ICdleHBhbmQnKSB7XG4gICAgICAgIHRoaXMuX291dHB1dC5hZGRfbmV3X2xpbmUoKTtcbiAgICAgICAgdGhpcy5wcmludF9zdHJpbmcodGhpcy5fY2gpO1xuICAgICAgICB0aGlzLmluZGVudCgpO1xuICAgICAgICB0aGlzLl9vdXRwdXQuc2V0X2luZGVudCh0aGlzLl9pbmRlbnRMZXZlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpbnNpZGUgbWl4aW4gYW5kIGZpcnN0IHBhcmFtIGlzIG9iamVjdFxuICAgICAgICBpZiAocHJldmlvdXNfY2ggPT09ICcoJykge1xuICAgICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChwcmV2aW91c19jaCAhPT0gJywnKSB7XG4gICAgICAgICAgdGhpcy5pbmRlbnQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByaW50X3N0cmluZyh0aGlzLl9jaCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWF0V2hpdGVzcGFjZSh0cnVlKTtcbiAgICAgIHRoaXMuX291dHB1dC5hZGRfbmV3X2xpbmUoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2NoID09PSAnfScpIHtcbiAgICAgIHRoaXMub3V0ZGVudCgpO1xuICAgICAgdGhpcy5fb3V0cHV0LmFkZF9uZXdfbGluZSgpO1xuICAgICAgaWYgKHByZXZpb3VzX2NoID09PSAneycpIHtcbiAgICAgICAgdGhpcy5fb3V0cHV0LnRyaW0odHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbnNpZGVQcm9wZXJ0eVZhbHVlKSB7XG4gICAgICAgIHRoaXMub3V0ZGVudCgpO1xuICAgICAgICBpbnNpZGVQcm9wZXJ0eVZhbHVlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzLnByaW50X3N0cmluZyh0aGlzLl9jaCk7XG4gICAgICBpbnNpZGVSdWxlID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5fbmVzdGVkTGV2ZWwpIHtcbiAgICAgICAgdGhpcy5fbmVzdGVkTGV2ZWwtLTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lYXRXaGl0ZXNwYWNlKHRydWUpO1xuICAgICAgdGhpcy5fb3V0cHV0LmFkZF9uZXdfbGluZSgpO1xuXG4gICAgICBpZiAodGhpcy5fb3B0aW9ucy5uZXdsaW5lX2JldHdlZW5fcnVsZXMgJiYgIXRoaXMuX291dHB1dC5qdXN0X2FkZGVkX2JsYW5rbGluZSgpKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbnB1dC5wZWVrKCkgIT09ICd9Jykge1xuICAgICAgICAgIHRoaXMuX291dHB1dC5hZGRfbmV3X2xpbmUodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9pbnB1dC5wZWVrKCkgPT09ICcpJykge1xuICAgICAgICB0aGlzLl9vdXRwdXQudHJpbSh0cnVlKTtcbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuYnJhY2Vfc3R5bGUgPT09IFwiZXhwYW5kXCIpIHtcbiAgICAgICAgICB0aGlzLl9vdXRwdXQuYWRkX25ld19saW5lKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9jaCA9PT0gXCI6XCIpIHtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLk5PTl9TRU1JQ09MT05fTkVXTElORV9QUk9QRVJUWS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGhpcy5faW5wdXQubG9va0JhY2sodGhpcy5OT05fU0VNSUNPTE9OX05FV0xJTkVfUFJPUEVSVFlbaV0pKSB7XG4gICAgICAgICAgaW5zaWRlTm9uU2VtaUNvbG9uVmFsdWVzID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoKGluc2lkZVJ1bGUgfHwgZW50ZXJpbmdDb25kaXRpb25hbEdyb3VwKSAmJiAhKHRoaXMuX2lucHV0Lmxvb2tCYWNrKFwiJlwiKSB8fCB0aGlzLmZvdW5kTmVzdGVkUHNldWRvQ2xhc3MoKSkgJiYgIXRoaXMuX2lucHV0Lmxvb2tCYWNrKFwiKFwiKSAmJiAhaW5zaWRlTm9uTmVzdGVkQXRSdWxlICYmIHBhcmVuTGV2ZWwgPT09IDApIHtcbiAgICAgICAgLy8gJ3Byb3BlcnR5OiB2YWx1ZScgZGVsaW1pdGVyXG4gICAgICAgIC8vIHdoaWNoIGNvdWxkIGJlIGluIGEgY29uZGl0aW9uYWwgZ3JvdXAgcXVlcnlcblxuICAgICAgICB0aGlzLnByaW50X3N0cmluZygnOicpO1xuICAgICAgICBpZiAoIWluc2lkZVByb3BlcnR5VmFsdWUpIHtcbiAgICAgICAgICBpbnNpZGVQcm9wZXJ0eVZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmVhdFdoaXRlc3BhY2UodHJ1ZSk7XG4gICAgICAgICAgdGhpcy5pbmRlbnQoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc2Fzcy9sZXNzIHBhcmVudCByZWZlcmVuY2UgZG9uJ3QgdXNlIGEgc3BhY2VcbiAgICAgICAgLy8gc2FzcyBuZXN0ZWQgcHNldWRvLWNsYXNzIGRvbid0IHVzZSBhIHNwYWNlXG5cbiAgICAgICAgLy8gcHJlc2VydmUgc3BhY2UgYmVmb3JlIHBzZXVkb2NsYXNzZXMvcHNldWRvZWxlbWVudHMsIGFzIGl0IG1lYW5zIFwiaW4gYW55IGNoaWxkXCJcbiAgICAgICAgaWYgKHRoaXMuX2lucHV0Lmxvb2tCYWNrKFwiIFwiKSkge1xuICAgICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pbnB1dC5wZWVrKCkgPT09IFwiOlwiKSB7XG4gICAgICAgICAgLy8gcHNldWRvLWVsZW1lbnRcbiAgICAgICAgICB0aGlzLl9jaCA9IHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICAgICAgICB0aGlzLnByaW50X3N0cmluZyhcIjo6XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHBzZXVkby1jbGFzc1xuICAgICAgICAgIHRoaXMucHJpbnRfc3RyaW5nKCc6Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX2NoID09PSAnXCInIHx8IHRoaXMuX2NoID09PSAnXFwnJykge1xuICAgICAgdmFyIHByZXNlcnZlUXVvdGVTcGFjZSA9IHByZXZpb3VzX2NoID09PSAnXCInIHx8IHByZXZpb3VzX2NoID09PSAnXFwnJztcbiAgICAgIHRoaXMucHJlc2VydmVTaW5nbGVTcGFjZShwcmVzZXJ2ZVF1b3RlU3BhY2UgfHwgaXNBZnRlclNwYWNlKTtcbiAgICAgIHRoaXMucHJpbnRfc3RyaW5nKHRoaXMuX2NoICsgdGhpcy5lYXRTdHJpbmcodGhpcy5fY2gpKTtcbiAgICAgIHRoaXMuZWF0V2hpdGVzcGFjZSh0cnVlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2NoID09PSAnOycpIHtcbiAgICAgIGluc2lkZU5vblNlbWlDb2xvblZhbHVlcyA9IGZhbHNlO1xuICAgICAgaWYgKHBhcmVuTGV2ZWwgPT09IDApIHtcbiAgICAgICAgaWYgKGluc2lkZVByb3BlcnR5VmFsdWUpIHtcbiAgICAgICAgICB0aGlzLm91dGRlbnQoKTtcbiAgICAgICAgICBpbnNpZGVQcm9wZXJ0eVZhbHVlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaW5zaWRlTm9uTmVzdGVkQXRSdWxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHJpbnRfc3RyaW5nKHRoaXMuX2NoKTtcbiAgICAgICAgdGhpcy5lYXRXaGl0ZXNwYWNlKHRydWUpO1xuXG4gICAgICAgIC8vIFRoaXMgbWFpbnRhaW5zIHNpbmdsZSBsaW5lIGNvbW1lbnRzIG9uIHRoZSBzYW1lXG4gICAgICAgIC8vIGxpbmUuIEJsb2NrIGNvbW1lbnRzIGFyZSBhbHNvIGFmZmVjdGVkLCBidXRcbiAgICAgICAgLy8gYSBuZXcgbGluZSBpcyBhbHdheXMgb3V0cHV0IGJlZm9yZSBvbmUgaW5zaWRlXG4gICAgICAgIC8vIHRoYXQgc2VjdGlvblxuICAgICAgICBpZiAodGhpcy5faW5wdXQucGVlaygpICE9PSAnLycpIHtcbiAgICAgICAgICB0aGlzLl9vdXRwdXQuYWRkX25ld19saW5lKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJpbnRfc3RyaW5nKHRoaXMuX2NoKTtcbiAgICAgICAgdGhpcy5lYXRXaGl0ZXNwYWNlKHRydWUpO1xuICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX2NoID09PSAnKCcpIHsgLy8gbWF5IGJlIGEgdXJsXG4gICAgICBpZiAodGhpcy5faW5wdXQubG9va0JhY2soXCJ1cmxcIikpIHtcbiAgICAgICAgdGhpcy5wcmludF9zdHJpbmcodGhpcy5fY2gpO1xuICAgICAgICB0aGlzLmVhdFdoaXRlc3BhY2UoKTtcbiAgICAgICAgcGFyZW5MZXZlbCsrO1xuICAgICAgICB0aGlzLmluZGVudCgpO1xuICAgICAgICB0aGlzLl9jaCA9IHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICAgICAgaWYgKHRoaXMuX2NoID09PSAnKScgfHwgdGhpcy5fY2ggPT09ICdcIicgfHwgdGhpcy5fY2ggPT09ICdcXCcnKSB7XG4gICAgICAgICAgdGhpcy5faW5wdXQuYmFjaygpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2NoKSB7XG4gICAgICAgICAgdGhpcy5wcmludF9zdHJpbmcodGhpcy5fY2ggKyB0aGlzLmVhdFN0cmluZygnKScpKTtcbiAgICAgICAgICBpZiAocGFyZW5MZXZlbCkge1xuICAgICAgICAgICAgcGFyZW5MZXZlbC0tO1xuICAgICAgICAgICAgdGhpcy5vdXRkZW50KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc3BhY2VfbmVlZGVkID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLl9pbnB1dC5sb29rQmFjayhcIndpdGhcIikpIHtcbiAgICAgICAgICAvLyBsb29rIGJhY2sgaXMgbm90IGFuIGFjY3VyYXRlIHNvbHV0aW9uLCB3ZSBuZWVkIHRva2VucyB0byBjb25maXJtIHdpdGhvdXQgd2hpdGVzcGFjZXNcbiAgICAgICAgICBzcGFjZV9uZWVkZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJlc2VydmVTaW5nbGVTcGFjZShpc0FmdGVyU3BhY2UgfHwgc3BhY2VfbmVlZGVkKTtcbiAgICAgICAgdGhpcy5wcmludF9zdHJpbmcodGhpcy5fY2gpO1xuXG4gICAgICAgIC8vIGhhbmRsZSBzY3NzL3Nhc3MgbWFwXG4gICAgICAgIGlmIChpbnNpZGVQcm9wZXJ0eVZhbHVlICYmIHByZXZpb3VzX2NoID09PSBcIiRcIiAmJiB0aGlzLl9vcHRpb25zLnNlbGVjdG9yX3NlcGFyYXRvcl9uZXdsaW5lKSB7XG4gICAgICAgICAgdGhpcy5fb3V0cHV0LmFkZF9uZXdfbGluZSgpO1xuICAgICAgICAgIGluc2lkZVNjc3NNYXAgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZWF0V2hpdGVzcGFjZSgpO1xuICAgICAgICAgIHBhcmVuTGV2ZWwrKztcbiAgICAgICAgICB0aGlzLmluZGVudCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9jaCA9PT0gJyknKSB7XG4gICAgICBpZiAocGFyZW5MZXZlbCkge1xuICAgICAgICBwYXJlbkxldmVsLS07XG4gICAgICAgIHRoaXMub3V0ZGVudCgpO1xuICAgICAgfVxuICAgICAgaWYgKGluc2lkZVNjc3NNYXAgJiYgdGhpcy5faW5wdXQucGVlaygpID09PSBcIjtcIiAmJiB0aGlzLl9vcHRpb25zLnNlbGVjdG9yX3NlcGFyYXRvcl9uZXdsaW5lKSB7XG4gICAgICAgIGluc2lkZVNjc3NNYXAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vdXRkZW50KCk7XG4gICAgICAgIHRoaXMuX291dHB1dC5hZGRfbmV3X2xpbmUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucHJpbnRfc3RyaW5nKHRoaXMuX2NoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2NoID09PSAnLCcpIHtcbiAgICAgIHRoaXMucHJpbnRfc3RyaW5nKHRoaXMuX2NoKTtcbiAgICAgIHRoaXMuZWF0V2hpdGVzcGFjZSh0cnVlKTtcbiAgICAgIGlmICh0aGlzLl9vcHRpb25zLnNlbGVjdG9yX3NlcGFyYXRvcl9uZXdsaW5lICYmICghaW5zaWRlUHJvcGVydHlWYWx1ZSB8fCBpbnNpZGVTY3NzTWFwKSAmJiBwYXJlbkxldmVsID09PSAwICYmICFpbnNpZGVOb25OZXN0ZWRBdFJ1bGUpIHtcbiAgICAgICAgdGhpcy5fb3V0cHV0LmFkZF9uZXdfbGluZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgodGhpcy5fY2ggPT09ICc+JyB8fCB0aGlzLl9jaCA9PT0gJysnIHx8IHRoaXMuX2NoID09PSAnficpICYmICFpbnNpZGVQcm9wZXJ0eVZhbHVlICYmIHBhcmVuTGV2ZWwgPT09IDApIHtcbiAgICAgIC8vaGFuZGxlIGNvbWJpbmF0b3Igc3BhY2luZ1xuICAgICAgaWYgKHRoaXMuX29wdGlvbnMuc3BhY2VfYXJvdW5kX2NvbWJpbmF0b3IpIHtcbiAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgIHRoaXMucHJpbnRfc3RyaW5nKHRoaXMuX2NoKTtcbiAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByaW50X3N0cmluZyh0aGlzLl9jaCk7XG4gICAgICAgIHRoaXMuZWF0V2hpdGVzcGFjZSgpO1xuICAgICAgICAvLyBzcXVhc2ggZXh0cmEgd2hpdGVzcGFjZVxuICAgICAgICBpZiAodGhpcy5fY2ggJiYgd2hpdGVzcGFjZUNoYXIudGVzdCh0aGlzLl9jaCkpIHtcbiAgICAgICAgICB0aGlzLl9jaCA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9jaCA9PT0gJ10nKSB7XG4gICAgICB0aGlzLnByaW50X3N0cmluZyh0aGlzLl9jaCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9jaCA9PT0gJ1snKSB7XG4gICAgICB0aGlzLnByZXNlcnZlU2luZ2xlU3BhY2UoaXNBZnRlclNwYWNlKTtcbiAgICAgIHRoaXMucHJpbnRfc3RyaW5nKHRoaXMuX2NoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2NoID09PSAnPScpIHsgLy8gbm8gd2hpdGVzcGFjZSBiZWZvcmUgb3IgYWZ0ZXJcbiAgICAgIHRoaXMuZWF0V2hpdGVzcGFjZSgpO1xuICAgICAgdGhpcy5wcmludF9zdHJpbmcoJz0nKTtcbiAgICAgIGlmICh3aGl0ZXNwYWNlQ2hhci50ZXN0KHRoaXMuX2NoKSkge1xuICAgICAgICB0aGlzLl9jaCA9ICcnO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fY2ggPT09ICchJyAmJiAhdGhpcy5faW5wdXQubG9va0JhY2soXCJcXFxcXCIpKSB7IC8vICFpbXBvcnRhbnRcbiAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgdGhpcy5wcmludF9zdHJpbmcodGhpcy5fY2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcHJlc2VydmVBZnRlclNwYWNlID0gcHJldmlvdXNfY2ggPT09ICdcIicgfHwgcHJldmlvdXNfY2ggPT09ICdcXCcnO1xuICAgICAgdGhpcy5wcmVzZXJ2ZVNpbmdsZVNwYWNlKHByZXNlcnZlQWZ0ZXJTcGFjZSB8fCBpc0FmdGVyU3BhY2UpO1xuICAgICAgdGhpcy5wcmludF9zdHJpbmcodGhpcy5fY2gpO1xuXG4gICAgICBpZiAoIXRoaXMuX291dHB1dC5qdXN0X2FkZGVkX25ld2xpbmUoKSAmJiB0aGlzLl9pbnB1dC5wZWVrKCkgPT09ICdcXG4nICYmIGluc2lkZU5vblNlbWlDb2xvblZhbHVlcykge1xuICAgICAgICB0aGlzLl9vdXRwdXQuYWRkX25ld19saW5lKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHN3ZWV0Q29kZSA9IHRoaXMuX291dHB1dC5nZXRfY29kZShlb2wpO1xuXG4gIHJldHVybiBzd2VldENvZGU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5CZWF1dGlmaWVyID0gQmVhdXRpZmllcjtcblxuXG4vKioqLyB9KSxcbi8qIDE3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG52YXIgQmFzZU9wdGlvbnMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXyg2KS5PcHRpb25zKTtcblxuZnVuY3Rpb24gT3B0aW9ucyhvcHRpb25zKSB7XG4gIEJhc2VPcHRpb25zLmNhbGwodGhpcywgb3B0aW9ucywgJ2NzcycpO1xuXG4gIHRoaXMuc2VsZWN0b3Jfc2VwYXJhdG9yX25ld2xpbmUgPSB0aGlzLl9nZXRfYm9vbGVhbignc2VsZWN0b3Jfc2VwYXJhdG9yX25ld2xpbmUnLCB0cnVlKTtcbiAgdGhpcy5uZXdsaW5lX2JldHdlZW5fcnVsZXMgPSB0aGlzLl9nZXRfYm9vbGVhbignbmV3bGluZV9iZXR3ZWVuX3J1bGVzJywgdHJ1ZSk7XG4gIHZhciBzcGFjZV9hcm91bmRfc2VsZWN0b3Jfc2VwYXJhdG9yID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ3NwYWNlX2Fyb3VuZF9zZWxlY3Rvcl9zZXBhcmF0b3InKTtcbiAgdGhpcy5zcGFjZV9hcm91bmRfY29tYmluYXRvciA9IHRoaXMuX2dldF9ib29sZWFuKCdzcGFjZV9hcm91bmRfY29tYmluYXRvcicpIHx8IHNwYWNlX2Fyb3VuZF9zZWxlY3Rvcl9zZXBhcmF0b3I7XG5cbiAgdmFyIGJyYWNlX3N0eWxlX3NwbGl0ID0gdGhpcy5fZ2V0X3NlbGVjdGlvbl9saXN0KCdicmFjZV9zdHlsZScsIFsnY29sbGFwc2UnLCAnZXhwYW5kJywgJ2VuZC1leHBhbmQnLCAnbm9uZScsICdwcmVzZXJ2ZS1pbmxpbmUnXSk7XG4gIHRoaXMuYnJhY2Vfc3R5bGUgPSAnY29sbGFwc2UnO1xuICBmb3IgKHZhciBicyA9IDA7IGJzIDwgYnJhY2Vfc3R5bGVfc3BsaXQubGVuZ3RoOyBicysrKSB7XG4gICAgaWYgKGJyYWNlX3N0eWxlX3NwbGl0W2JzXSAhPT0gJ2V4cGFuZCcpIHtcbiAgICAgIC8vIGRlZmF1bHQgdG8gY29sbGFwc2UsIGFzIG9ubHkgY29sbGFwc2V8ZXhwYW5kIGlzIGltcGxlbWVudGVkIGZvciBub3dcbiAgICAgIHRoaXMuYnJhY2Vfc3R5bGUgPSAnY29sbGFwc2UnO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJyYWNlX3N0eWxlID0gYnJhY2Vfc3R5bGVfc3BsaXRbYnNdO1xuICAgIH1cbiAgfVxufVxuT3B0aW9ucy5wcm90b3R5cGUgPSBuZXcgQmFzZU9wdGlvbnMoKTtcblxuXG5cbm1vZHVsZS5leHBvcnRzLk9wdGlvbnMgPSBPcHRpb25zO1xuXG5cbi8qKiovIH0pXG4vKioqKioqLyBcdF0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4vKioqKioqLyBcdFx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gc3RhcnR1cFxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0Ly8gVGhpcyBlbnRyeSBtb2R1bGUgaXMgcmVmZXJlbmNlZCBieSBvdGhlciBtb2R1bGVzIHNvIGl0IGNhbid0IGJlIGlubGluZWRcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcbi8qKioqKiovIFx0bGVnYWN5X2JlYXV0aWZ5X2NzcyA9IF9fd2VicGFja19leHBvcnRzX187XG4vKioqKioqLyBcdFxuLyoqKioqKi8gfSkoKVxuO1xudmFyIGNzc19iZWF1dGlmeSA9IGxlZ2FjeV9iZWF1dGlmeV9jc3M7XG4vKiBGb290ZXIgKi9cbmlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEFkZCBzdXBwb3J0IGZvciBBTUQgKCBodHRwczovL2dpdGh1Yi5jb20vYW1kanMvYW1kanMtYXBpL3dpa2kvQU1EI2RlZmluZWFtZC1wcm9wZXJ0eS0gKVxuICAgIGRlZmluZShbXSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjc3NfYmVhdXRpZnk6IGNzc19iZWF1dGlmeVxuICAgICAgICB9O1xuICAgIH0pO1xufSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8vIEFkZCBzdXBwb3J0IGZvciBDb21tb25KUy4gSnVzdCBwdXQgdGhpcyBmaWxlIHNvbWV3aGVyZSBvbiB5b3VyIHJlcXVpcmUucGF0aHNcbiAgICAvLyBhbmQgeW91IHdpbGwgYmUgYWJsZSB0byBgdmFyIGh0bWxfYmVhdXRpZnkgPSByZXF1aXJlKFwiYmVhdXRpZnlcIikuaHRtbF9iZWF1dGlmeWAuXG4gICAgZXhwb3J0cy5jc3NfYmVhdXRpZnkgPSBjc3NfYmVhdXRpZnk7XG59IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAvLyBJZiB3ZSdyZSBydW5uaW5nIGEgd2ViIHBhZ2UgYW5kIGRvbid0IGhhdmUgZWl0aGVyIG9mIHRoZSBhYm92ZSwgYWRkIG91ciBvbmUgZ2xvYmFsXG4gICAgd2luZG93LmNzc19iZWF1dGlmeSA9IGNzc19iZWF1dGlmeTtcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8vIElmIHdlIGRvbid0IGV2ZW4gaGF2ZSB3aW5kb3csIHRyeSBnbG9iYWwuXG4gICAgZ2xvYmFsLmNzc19iZWF1dGlmeSA9IGNzc19iZWF1dGlmeTtcbn1cblxufSgpKTtcbiJdLCJuYW1lcyI6WyJsZWdhY3lfYmVhdXRpZnlfY3NzIiwiX193ZWJwYWNrX21vZHVsZXNfXyIsIm1vZHVsZSIsIk91dHB1dExpbmUiLCJwYXJlbnQiLCJfX3BhcmVudCIsIl9fY2hhcmFjdGVyX2NvdW50IiwiX19pbmRlbnRfY291bnQiLCJfX2FsaWdubWVudF9jb3VudCIsIl9fd3JhcF9wb2ludF9pbmRleCIsIl9fd3JhcF9wb2ludF9jaGFyYWN0ZXJfY291bnQiLCJfX3dyYXBfcG9pbnRfaW5kZW50X2NvdW50IiwiX193cmFwX3BvaW50X2FsaWdubWVudF9jb3VudCIsIl9faXRlbXMiLCJwcm90b3R5cGUiLCJjbG9uZV9lbXB0eSIsImxpbmUiLCJzZXRfaW5kZW50IiwiaXRlbSIsImluZGV4IiwibGVuZ3RoIiwiaGFzX21hdGNoIiwicGF0dGVybiIsImxhc3RDaGVja2VkT3V0cHV0IiwibWF0Y2giLCJpbmRlbnQiLCJhbGlnbm1lbnQiLCJpc19lbXB0eSIsImdldF9pbmRlbnRfc2l6ZSIsIl9zZXRfd3JhcF9wb2ludCIsIndyYXBfbGluZV9sZW5ndGgiLCJuZXh0X2xpbmUiLCJfc2hvdWxkX3dyYXAiLCJfYWxsb3dfd3JhcCIsImFkZF9uZXdfbGluZSIsIm5leHQiLCJjdXJyZW50X2xpbmUiLCJzbGljZSIsInNwbGljZSIsImxhc3QiLCJwdXNoIiwibGFzdF9uZXdsaW5lX2luZGV4IiwibGFzdEluZGV4T2YiLCJwb3AiLCJfcmVtb3ZlX2luZGVudCIsImluZGVudF9zaXplIiwiX3JlbW92ZV93cmFwX2luZGVudCIsInRyaW0iLCJ0b1N0cmluZyIsInJlc3VsdCIsImluZGVudF9lbXB0eV9saW5lcyIsImdldF9pbmRlbnRfc3RyaW5nIiwiam9pbiIsIkluZGVudFN0cmluZ0NhY2hlIiwib3B0aW9ucyIsImJhc2VJbmRlbnRTdHJpbmciLCJfX2NhY2hlIiwiX19pbmRlbnRfc2l6ZSIsIl9faW5kZW50X3N0cmluZyIsImluZGVudF9jaGFyIiwiaW5kZW50X3dpdGhfdGFicyIsIkFycmF5IiwiaW5kZW50X2xldmVsIiwiX19iYXNlX3N0cmluZyIsIl9fYmFzZV9zdHJpbmdfbGVuZ3RoIiwiY29sdW1uIiwiX19lbnN1cmVfY2FjaGUiLCJfX2FkZF9jb2x1bW4iLCJNYXRoIiwiZmxvb3IiLCJPdXRwdXQiLCJfX2luZGVudF9jYWNoZSIsInJhdyIsIl9lbmRfd2l0aF9uZXdsaW5lIiwiZW5kX3dpdGhfbmV3bGluZSIsIl9fbGluZXMiLCJwcmV2aW91c19saW5lIiwic3BhY2VfYmVmb3JlX3Rva2VuIiwibm9uX2JyZWFraW5nX3NwYWNlIiwicHJldmlvdXNfdG9rZW5fd3JhcHBlZCIsIl9fYWRkX291dHB1dGxpbmUiLCJnZXRfbGluZV9udW1iZXIiLCJmb3JjZV9uZXdsaW5lIiwianVzdF9hZGRlZF9uZXdsaW5lIiwiZ2V0X2NvZGUiLCJlb2wiLCJsYXN0X2l0ZW0iLCJyZXBsYWNlIiwic3dlZXRfY29kZSIsInNldF93cmFwX3BvaW50IiwiYWRkX3Jhd190b2tlbiIsInRva2VuIiwieCIsIm5ld2xpbmVzIiwid2hpdGVzcGFjZV9iZWZvcmUiLCJ0ZXh0IiwiYWRkX3Rva2VuIiwicHJpbnRhYmxlX3Rva2VuIiwiX19hZGRfc3BhY2VfYmVmb3JlX3Rva2VuIiwicmVtb3ZlX2luZGVudCIsIm91dHB1dF9sZW5ndGgiLCJlYXRfbmV3bGluZXMiLCJ1bmRlZmluZWQiLCJqdXN0X2FkZGVkX2JsYW5rbGluZSIsImVuc3VyZV9lbXB0eV9saW5lX2Fib3ZlIiwic3RhcnRzX3dpdGgiLCJlbmRzX3dpdGgiLCJwb3RlbnRpYWxFbXB0eUxpbmUiLCJpbmRleE9mIiwiZXhwb3J0cyIsIk9wdGlvbnMiLCJtZXJnZV9jaGlsZF9maWVsZCIsInJhd19vcHRpb25zIiwiX21lcmdlT3B0cyIsImRpc2FibGVkIiwiX2dldF9ib29sZWFuIiwiX2dldF9jaGFyYWN0ZXJzIiwiX2dldF9udW1iZXIiLCJwcmVzZXJ2ZV9uZXdsaW5lcyIsIm1heF9wcmVzZXJ2ZV9uZXdsaW5lcyIsInRlbXBsYXRpbmciLCJfZ2V0X3NlbGVjdGlvbl9saXN0IiwiX2dldF9hcnJheSIsIm5hbWUiLCJkZWZhdWx0X3ZhbHVlIiwib3B0aW9uX3ZhbHVlIiwiY29uY2F0Iiwic3BsaXQiLCJwYXJzZUludCIsImlzTmFOIiwiX2dldF9zZWxlY3Rpb24iLCJzZWxlY3Rpb25fbGlzdCIsIkVycm9yIiwiX2lzX3ZhbGlkX3NlbGVjdGlvbiIsInNvbWUiLCJhbGxPcHRpb25zIiwiY2hpbGRGaWVsZE5hbWUiLCJmaW5hbE9wdHMiLCJfbm9ybWFsaXplT3B0cyIsImNvbnZlcnRlZE9wdHMiLCJrZXkiLCJuZXdLZXkiLCJub3JtYWxpemVPcHRzIiwibWVyZ2VPcHRzIiwicmVnZXhwX2hhc19zdGlja3kiLCJSZWdFeHAiLCJoYXNPd25Qcm9wZXJ0eSIsIklucHV0U2Nhbm5lciIsImlucHV0X3N0cmluZyIsIl9faW5wdXQiLCJfX2lucHV0X2xlbmd0aCIsIl9fcG9zaXRpb24iLCJyZXN0YXJ0IiwiYmFjayIsImhhc05leHQiLCJ2YWwiLCJjaGFyQXQiLCJwZWVrIiwiX19tYXRjaCIsImxhc3RJbmRleCIsInBhdHRlcm5fbWF0Y2giLCJleGVjIiwic3RpY2t5IiwidGVzdCIsInRlc3RDaGFyIiwicmVhZCIsInN0YXJ0aW5nX3BhdHRlcm4iLCJ1bnRpbF9wYXR0ZXJuIiwidW50aWxfYWZ0ZXIiLCJyZWFkVW50aWwiLCJtYXRjaF9pbmRleCIsInN1YnN0cmluZyIsInJlYWRVbnRpbEFmdGVyIiwiZ2V0X3JlZ2V4cCIsIm1hdGNoX2Zyb20iLCJmbGFncyIsInNvdXJjZSIsImdldF9saXRlcmFsX3JlZ2V4cCIsImxpdGVyYWxfc3RyaW5nIiwicGVla1VudGlsQWZ0ZXIiLCJzdGFydCIsImxvb2tCYWNrIiwidGVzdFZhbCIsInRvTG93ZXJDYXNlIiwiRGlyZWN0aXZlcyIsInN0YXJ0X2Jsb2NrX3BhdHRlcm4iLCJlbmRfYmxvY2tfcGF0dGVybiIsIl9fZGlyZWN0aXZlc19ibG9ja19wYXR0ZXJuIiwiX19kaXJlY3RpdmVfcGF0dGVybiIsIl9fZGlyZWN0aXZlc19lbmRfaWdub3JlX3BhdHRlcm4iLCJnZXRfZGlyZWN0aXZlcyIsImRpcmVjdGl2ZXMiLCJkaXJlY3RpdmVfbWF0Y2giLCJyZWFkSWdub3JlZCIsImlucHV0IiwiX191bnVzZWRfd2VicGFja19leHBvcnRzIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsIkJlYXV0aWZpZXIiLCJjc3NfYmVhdXRpZnkiLCJzb3VyY2VfdGV4dCIsImJlYXV0aWZpZXIiLCJiZWF1dGlmeSIsImRlZmF1bHRPcHRpb25zIiwiZGlyZWN0aXZlc19jb3JlIiwibGluZUJyZWFrIiwiYWxsTGluZUJyZWFrcyIsIndoaXRlc3BhY2VDaGFyIiwid2hpdGVzcGFjZVBhdHRlcm4iLCJibG9ja19jb21tZW50X3BhdHRlcm4iLCJjb21tZW50X3BhdHRlcm4iLCJfc291cmNlX3RleHQiLCJfb3B0aW9ucyIsIl9jaCIsIl9pbnB1dCIsIk5FU1RFRF9BVF9SVUxFIiwiQ09ORElUSU9OQUxfR1JPVVBfUlVMRSIsIk5PTl9TRU1JQ09MT05fTkVXTElORV9QUk9QRVJUWSIsImVhdFN0cmluZyIsImVuZENoYXJzIiwiZWF0V2hpdGVzcGFjZSIsImFsbG93QXRMZWFzdE9uZU5ld0xpbmUiLCJuZXdsaW5lX2NvdW50IiwiX291dHB1dCIsImZvdW5kTmVzdGVkUHNldWRvQ2xhc3MiLCJvcGVuUGFyZW4iLCJpIiwiY2giLCJwcmludF9zdHJpbmciLCJvdXRwdXRfc3RyaW5nIiwiX2luZGVudExldmVsIiwicHJlc2VydmVTaW5nbGVTcGFjZSIsImlzQWZ0ZXJTcGFjZSIsIm91dGRlbnQiLCJfbmVzdGVkTGV2ZWwiLCJwYXJlbkxldmVsIiwiaW5zaWRlUnVsZSIsImluc2lkZVByb3BlcnR5VmFsdWUiLCJlbnRlcmluZ0NvbmRpdGlvbmFsR3JvdXAiLCJpbnNpZGVOb25OZXN0ZWRBdFJ1bGUiLCJpbnNpZGVTY3NzTWFwIiwidG9wQ2hhcmFjdGVyIiwiaW5zaWRlTm9uU2VtaUNvbG9uVmFsdWVzIiwid2hpdGVzcGFjZSIsInByZXZpb3VzX2NoIiwiY29tbWVudCIsImlnbm9yZSIsInZhcmlhYmxlIiwidmFyaWFibGVPclJ1bGUiLCJuZXdsaW5lX2JldHdlZW5fcnVsZXMiLCJicmFjZV9zdHlsZSIsInByZXNlcnZlUXVvdGVTcGFjZSIsInNwYWNlX25lZWRlZCIsInNlbGVjdG9yX3NlcGFyYXRvcl9uZXdsaW5lIiwic3BhY2VfYXJvdW5kX2NvbWJpbmF0b3IiLCJwcmVzZXJ2ZUFmdGVyU3BhY2UiLCJzd2VldENvZGUiLCJCYXNlT3B0aW9ucyIsImNhbGwiLCJzcGFjZV9hcm91bmRfc2VsZWN0b3Jfc2VwYXJhdG9yIiwiYnJhY2Vfc3R5bGVfc3BsaXQiLCJicyIsIl9fd2VicGFja19tb2R1bGVfY2FjaGVfXyIsIm1vZHVsZUlkIiwiY2FjaGVkTW9kdWxlIiwiX193ZWJwYWNrX2V4cG9ydHNfXyIsImRlZmluZSIsImFtZCIsIndpbmRvdyIsImdsb2JhbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/js-beautify/js/lib/beautify-css.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/js-beautify/js/lib/beautify-html.js":
/*!**********************************************************!*\
  !*** ./node_modules/js-beautify/js/lib/beautify-html.js ***!
  \**********************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* AUTO-GENERATED. DO NOT MODIFY. */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n\n\n Style HTML\n---------------\n\n  Written by Nochum Sossonko, (nsossonko@hotmail.com)\n\n  Based on code initially developed by: Einar Lielmanis, <einar@beautifier.io>\n    https://beautifier.io/\n\n  Usage:\n    style_html(html_source);\n\n    style_html(html_source, options);\n\n  The options are:\n    indent_inner_html (default false)  — indent <head> and <body> sections,\n    indent_size (default 4)          — indentation size,\n    indent_char (default space)      — character to indent with,\n    wrap_line_length (default 250)            -  maximum amount of characters per line (0 = disable)\n    brace_style (default \"collapse\") - \"collapse\" | \"expand\" | \"end-expand\" | \"none\"\n            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line, or attempt to keep them where they are.\n    inline (defaults to inline tags) - list of tags to be considered inline tags\n    unformatted (defaults to inline tags) - list of tags, that shouldn't be reformatted\n    content_unformatted (defaults to [\"pre\", \"textarea\"] tags) - list of tags, whose content shouldn't be reformatted\n    indent_scripts (default normal)  - \"keep\"|\"separate\"|\"normal\"\n    preserve_newlines (default true) - whether existing line breaks before elements should be preserved\n                                        Only works before elements, not inside tags or for text.\n    max_preserve_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk\n    indent_handlebars (default false) - format and indent {{#foo}} and {{/foo}}\n    end_with_newline (false)          - end with a newline\n    extra_liners (default [head,body,/html]) -List of tags that should have an extra newline before them.\n\n    e.g.\n\n    style_html(html_source, {\n      'indent_inner_html': false,\n      'indent_size': 2,\n      'indent_char': ' ',\n      'wrap_line_length': 78,\n      'brace_style': 'expand',\n      'preserve_newlines': true,\n      'max_preserve_newlines': 5,\n      'indent_handlebars': false,\n      'extra_liners': ['/html']\n    });\n*/ (function() {\n    /* GENERATED_BUILD_OUTPUT */ var legacy_beautify_html;\n    /******/ (function() {\n        /******/ \"use strict\";\n        /******/ var __webpack_modules__ = [\n            ,\n            ,\n            /* 2 */ /***/ function(module) {\n                /*jshint node:true */ /*\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ function OutputLine(parent) {\n                    this.__parent = parent;\n                    this.__character_count = 0;\n                    // use indent_count as a marker for this.__lines that have preserved indentation\n                    this.__indent_count = -1;\n                    this.__alignment_count = 0;\n                    this.__wrap_point_index = 0;\n                    this.__wrap_point_character_count = 0;\n                    this.__wrap_point_indent_count = -1;\n                    this.__wrap_point_alignment_count = 0;\n                    this.__items = [];\n                }\n                OutputLine.prototype.clone_empty = function() {\n                    var line = new OutputLine(this.__parent);\n                    line.set_indent(this.__indent_count, this.__alignment_count);\n                    return line;\n                };\n                OutputLine.prototype.item = function(index) {\n                    if (index < 0) {\n                        return this.__items[this.__items.length + index];\n                    } else {\n                        return this.__items[index];\n                    }\n                };\n                OutputLine.prototype.has_match = function(pattern) {\n                    for(var lastCheckedOutput = this.__items.length - 1; lastCheckedOutput >= 0; lastCheckedOutput--){\n                        if (this.__items[lastCheckedOutput].match(pattern)) {\n                            return true;\n                        }\n                    }\n                    return false;\n                };\n                OutputLine.prototype.set_indent = function(indent, alignment) {\n                    if (this.is_empty()) {\n                        this.__indent_count = indent || 0;\n                        this.__alignment_count = alignment || 0;\n                        this.__character_count = this.__parent.get_indent_size(this.__indent_count, this.__alignment_count);\n                    }\n                };\n                OutputLine.prototype._set_wrap_point = function() {\n                    if (this.__parent.wrap_line_length) {\n                        this.__wrap_point_index = this.__items.length;\n                        this.__wrap_point_character_count = this.__character_count;\n                        this.__wrap_point_indent_count = this.__parent.next_line.__indent_count;\n                        this.__wrap_point_alignment_count = this.__parent.next_line.__alignment_count;\n                    }\n                };\n                OutputLine.prototype._should_wrap = function() {\n                    return this.__wrap_point_index && this.__character_count > this.__parent.wrap_line_length && this.__wrap_point_character_count > this.__parent.next_line.__character_count;\n                };\n                OutputLine.prototype._allow_wrap = function() {\n                    if (this._should_wrap()) {\n                        this.__parent.add_new_line();\n                        var next = this.__parent.current_line;\n                        next.set_indent(this.__wrap_point_indent_count, this.__wrap_point_alignment_count);\n                        next.__items = this.__items.slice(this.__wrap_point_index);\n                        this.__items = this.__items.slice(0, this.__wrap_point_index);\n                        next.__character_count += this.__character_count - this.__wrap_point_character_count;\n                        this.__character_count = this.__wrap_point_character_count;\n                        if (next.__items[0] === \" \") {\n                            next.__items.splice(0, 1);\n                            next.__character_count -= 1;\n                        }\n                        return true;\n                    }\n                    return false;\n                };\n                OutputLine.prototype.is_empty = function() {\n                    return this.__items.length === 0;\n                };\n                OutputLine.prototype.last = function() {\n                    if (!this.is_empty()) {\n                        return this.__items[this.__items.length - 1];\n                    } else {\n                        return null;\n                    }\n                };\n                OutputLine.prototype.push = function(item) {\n                    this.__items.push(item);\n                    var last_newline_index = item.lastIndexOf(\"\\n\");\n                    if (last_newline_index !== -1) {\n                        this.__character_count = item.length - last_newline_index;\n                    } else {\n                        this.__character_count += item.length;\n                    }\n                };\n                OutputLine.prototype.pop = function() {\n                    var item = null;\n                    if (!this.is_empty()) {\n                        item = this.__items.pop();\n                        this.__character_count -= item.length;\n                    }\n                    return item;\n                };\n                OutputLine.prototype._remove_indent = function() {\n                    if (this.__indent_count > 0) {\n                        this.__indent_count -= 1;\n                        this.__character_count -= this.__parent.indent_size;\n                    }\n                };\n                OutputLine.prototype._remove_wrap_indent = function() {\n                    if (this.__wrap_point_indent_count > 0) {\n                        this.__wrap_point_indent_count -= 1;\n                    }\n                };\n                OutputLine.prototype.trim = function() {\n                    while(this.last() === \" \"){\n                        this.__items.pop();\n                        this.__character_count -= 1;\n                    }\n                };\n                OutputLine.prototype.toString = function() {\n                    var result = \"\";\n                    if (this.is_empty()) {\n                        if (this.__parent.indent_empty_lines) {\n                            result = this.__parent.get_indent_string(this.__indent_count);\n                        }\n                    } else {\n                        result = this.__parent.get_indent_string(this.__indent_count, this.__alignment_count);\n                        result += this.__items.join(\"\");\n                    }\n                    return result;\n                };\n                function IndentStringCache(options, baseIndentString) {\n                    this.__cache = [\n                        \"\"\n                    ];\n                    this.__indent_size = options.indent_size;\n                    this.__indent_string = options.indent_char;\n                    if (!options.indent_with_tabs) {\n                        this.__indent_string = new Array(options.indent_size + 1).join(options.indent_char);\n                    }\n                    // Set to null to continue support for auto detection of base indent\n                    baseIndentString = baseIndentString || \"\";\n                    if (options.indent_level > 0) {\n                        baseIndentString = new Array(options.indent_level + 1).join(this.__indent_string);\n                    }\n                    this.__base_string = baseIndentString;\n                    this.__base_string_length = baseIndentString.length;\n                }\n                IndentStringCache.prototype.get_indent_size = function(indent, column) {\n                    var result = this.__base_string_length;\n                    column = column || 0;\n                    if (indent < 0) {\n                        result = 0;\n                    }\n                    result += indent * this.__indent_size;\n                    result += column;\n                    return result;\n                };\n                IndentStringCache.prototype.get_indent_string = function(indent_level, column) {\n                    var result = this.__base_string;\n                    column = column || 0;\n                    if (indent_level < 0) {\n                        indent_level = 0;\n                        result = \"\";\n                    }\n                    column += indent_level * this.__indent_size;\n                    this.__ensure_cache(column);\n                    result += this.__cache[column];\n                    return result;\n                };\n                IndentStringCache.prototype.__ensure_cache = function(column) {\n                    while(column >= this.__cache.length){\n                        this.__add_column();\n                    }\n                };\n                IndentStringCache.prototype.__add_column = function() {\n                    var column = this.__cache.length;\n                    var indent = 0;\n                    var result = \"\";\n                    if (this.__indent_size && column >= this.__indent_size) {\n                        indent = Math.floor(column / this.__indent_size);\n                        column -= indent * this.__indent_size;\n                        result = new Array(indent + 1).join(this.__indent_string);\n                    }\n                    if (column) {\n                        result += new Array(column + 1).join(\" \");\n                    }\n                    this.__cache.push(result);\n                };\n                function Output(options, baseIndentString) {\n                    this.__indent_cache = new IndentStringCache(options, baseIndentString);\n                    this.raw = false;\n                    this._end_with_newline = options.end_with_newline;\n                    this.indent_size = options.indent_size;\n                    this.wrap_line_length = options.wrap_line_length;\n                    this.indent_empty_lines = options.indent_empty_lines;\n                    this.__lines = [];\n                    this.previous_line = null;\n                    this.current_line = null;\n                    this.next_line = new OutputLine(this);\n                    this.space_before_token = false;\n                    this.non_breaking_space = false;\n                    this.previous_token_wrapped = false;\n                    // initialize\n                    this.__add_outputline();\n                }\n                Output.prototype.__add_outputline = function() {\n                    this.previous_line = this.current_line;\n                    this.current_line = this.next_line.clone_empty();\n                    this.__lines.push(this.current_line);\n                };\n                Output.prototype.get_line_number = function() {\n                    return this.__lines.length;\n                };\n                Output.prototype.get_indent_string = function(indent, column) {\n                    return this.__indent_cache.get_indent_string(indent, column);\n                };\n                Output.prototype.get_indent_size = function(indent, column) {\n                    return this.__indent_cache.get_indent_size(indent, column);\n                };\n                Output.prototype.is_empty = function() {\n                    return !this.previous_line && this.current_line.is_empty();\n                };\n                Output.prototype.add_new_line = function(force_newline) {\n                    // never newline at the start of file\n                    // otherwise, newline only if we didn't just add one or we're forced\n                    if (this.is_empty() || !force_newline && this.just_added_newline()) {\n                        return false;\n                    }\n                    // if raw output is enabled, don't print additional newlines,\n                    // but still return True as though you had\n                    if (!this.raw) {\n                        this.__add_outputline();\n                    }\n                    return true;\n                };\n                Output.prototype.get_code = function(eol) {\n                    this.trim(true);\n                    // handle some edge cases where the last tokens\n                    // has text that ends with newline(s)\n                    var last_item = this.current_line.pop();\n                    if (last_item) {\n                        if (last_item[last_item.length - 1] === \"\\n\") {\n                            last_item = last_item.replace(/\\n+$/g, \"\");\n                        }\n                        this.current_line.push(last_item);\n                    }\n                    if (this._end_with_newline) {\n                        this.__add_outputline();\n                    }\n                    var sweet_code = this.__lines.join(\"\\n\");\n                    if (eol !== \"\\n\") {\n                        sweet_code = sweet_code.replace(/[\\n]/g, eol);\n                    }\n                    return sweet_code;\n                };\n                Output.prototype.set_wrap_point = function() {\n                    this.current_line._set_wrap_point();\n                };\n                Output.prototype.set_indent = function(indent, alignment) {\n                    indent = indent || 0;\n                    alignment = alignment || 0;\n                    // Next line stores alignment values\n                    this.next_line.set_indent(indent, alignment);\n                    // Never indent your first output indent at the start of the file\n                    if (this.__lines.length > 1) {\n                        this.current_line.set_indent(indent, alignment);\n                        return true;\n                    }\n                    this.current_line.set_indent();\n                    return false;\n                };\n                Output.prototype.add_raw_token = function(token) {\n                    for(var x = 0; x < token.newlines; x++){\n                        this.__add_outputline();\n                    }\n                    this.current_line.set_indent(-1);\n                    this.current_line.push(token.whitespace_before);\n                    this.current_line.push(token.text);\n                    this.space_before_token = false;\n                    this.non_breaking_space = false;\n                    this.previous_token_wrapped = false;\n                };\n                Output.prototype.add_token = function(printable_token) {\n                    this.__add_space_before_token();\n                    this.current_line.push(printable_token);\n                    this.space_before_token = false;\n                    this.non_breaking_space = false;\n                    this.previous_token_wrapped = this.current_line._allow_wrap();\n                };\n                Output.prototype.__add_space_before_token = function() {\n                    if (this.space_before_token && !this.just_added_newline()) {\n                        if (!this.non_breaking_space) {\n                            this.set_wrap_point();\n                        }\n                        this.current_line.push(\" \");\n                    }\n                };\n                Output.prototype.remove_indent = function(index) {\n                    var output_length = this.__lines.length;\n                    while(index < output_length){\n                        this.__lines[index]._remove_indent();\n                        index++;\n                    }\n                    this.current_line._remove_wrap_indent();\n                };\n                Output.prototype.trim = function(eat_newlines) {\n                    eat_newlines = eat_newlines === undefined ? false : eat_newlines;\n                    this.current_line.trim();\n                    while(eat_newlines && this.__lines.length > 1 && this.current_line.is_empty()){\n                        this.__lines.pop();\n                        this.current_line = this.__lines[this.__lines.length - 1];\n                        this.current_line.trim();\n                    }\n                    this.previous_line = this.__lines.length > 1 ? this.__lines[this.__lines.length - 2] : null;\n                };\n                Output.prototype.just_added_newline = function() {\n                    return this.current_line.is_empty();\n                };\n                Output.prototype.just_added_blankline = function() {\n                    return this.is_empty() || this.current_line.is_empty() && this.previous_line.is_empty();\n                };\n                Output.prototype.ensure_empty_line_above = function(starts_with, ends_with) {\n                    var index = this.__lines.length - 2;\n                    while(index >= 0){\n                        var potentialEmptyLine = this.__lines[index];\n                        if (potentialEmptyLine.is_empty()) {\n                            break;\n                        } else if (potentialEmptyLine.item(0).indexOf(starts_with) !== 0 && potentialEmptyLine.item(-1) !== ends_with) {\n                            this.__lines.splice(index + 1, 0, new OutputLine(this));\n                            this.previous_line = this.__lines[this.__lines.length - 2];\n                            break;\n                        }\n                        index--;\n                    }\n                };\n                module.exports.Output = Output;\n            /***/ },\n            /* 3 */ /***/ function(module) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ function Token(type, text, newlines, whitespace_before) {\n                    this.type = type;\n                    this.text = text;\n                    // comments_before are\n                    // comments that have a new line before them\n                    // and may or may not have a newline after\n                    // this is a set of comments before\n                    this.comments_before = null; /* inline comment*/ \n                    // this.comments_after =  new TokenStream(); // no new line before and newline after\n                    this.newlines = newlines || 0;\n                    this.whitespace_before = whitespace_before || \"\";\n                    this.parent = null;\n                    this.next = null;\n                    this.previous = null;\n                    this.opened = null;\n                    this.closed = null;\n                    this.directives = null;\n                }\n                module.exports.Token = Token;\n            /***/ },\n            ,\n            ,\n            /* 6 */ /***/ function(module) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ function Options(options, merge_child_field) {\n                    this.raw_options = _mergeOpts(options, merge_child_field);\n                    // Support passing the source text back with no change\n                    this.disabled = this._get_boolean(\"disabled\");\n                    this.eol = this._get_characters(\"eol\", \"auto\");\n                    this.end_with_newline = this._get_boolean(\"end_with_newline\");\n                    this.indent_size = this._get_number(\"indent_size\", 4);\n                    this.indent_char = this._get_characters(\"indent_char\", \" \");\n                    this.indent_level = this._get_number(\"indent_level\");\n                    this.preserve_newlines = this._get_boolean(\"preserve_newlines\", true);\n                    this.max_preserve_newlines = this._get_number(\"max_preserve_newlines\", 32786);\n                    if (!this.preserve_newlines) {\n                        this.max_preserve_newlines = 0;\n                    }\n                    this.indent_with_tabs = this._get_boolean(\"indent_with_tabs\", this.indent_char === \"\t\");\n                    if (this.indent_with_tabs) {\n                        this.indent_char = \"\t\";\n                        // indent_size behavior changed after 1.8.6\n                        // It used to be that indent_size would be\n                        // set to 1 for indent_with_tabs. That is no longer needed and\n                        // actually doesn't make sense - why not use spaces? Further,\n                        // that might produce unexpected behavior - tabs being used\n                        // for single-column alignment. So, when indent_with_tabs is true\n                        // and indent_size is 1, reset indent_size to 4.\n                        if (this.indent_size === 1) {\n                            this.indent_size = 4;\n                        }\n                    }\n                    // Backwards compat with 1.3.x\n                    this.wrap_line_length = this._get_number(\"wrap_line_length\", this._get_number(\"max_char\"));\n                    this.indent_empty_lines = this._get_boolean(\"indent_empty_lines\");\n                    // valid templating languages ['django', 'erb', 'handlebars', 'php', 'smarty', 'angular']\n                    // For now, 'auto' = all off for javascript, all except angular on for html (and inline javascript/css).\n                    // other values ignored\n                    this.templating = this._get_selection_list(\"templating\", [\n                        \"auto\",\n                        \"none\",\n                        \"angular\",\n                        \"django\",\n                        \"erb\",\n                        \"handlebars\",\n                        \"php\",\n                        \"smarty\"\n                    ], [\n                        \"auto\"\n                    ]);\n                }\n                Options.prototype._get_array = function(name, default_value) {\n                    var option_value = this.raw_options[name];\n                    var result = default_value || [];\n                    if (typeof option_value === \"object\") {\n                        if (option_value !== null && typeof option_value.concat === \"function\") {\n                            result = option_value.concat();\n                        }\n                    } else if (typeof option_value === \"string\") {\n                        result = option_value.split(/[^a-zA-Z0-9_\\/\\-]+/);\n                    }\n                    return result;\n                };\n                Options.prototype._get_boolean = function(name, default_value) {\n                    var option_value = this.raw_options[name];\n                    var result = option_value === undefined ? !!default_value : !!option_value;\n                    return result;\n                };\n                Options.prototype._get_characters = function(name, default_value) {\n                    var option_value = this.raw_options[name];\n                    var result = default_value || \"\";\n                    if (typeof option_value === \"string\") {\n                        result = option_value.replace(/\\\\r/, \"\\r\").replace(/\\\\n/, \"\\n\").replace(/\\\\t/, \"\t\");\n                    }\n                    return result;\n                };\n                Options.prototype._get_number = function(name, default_value) {\n                    var option_value = this.raw_options[name];\n                    default_value = parseInt(default_value, 10);\n                    if (isNaN(default_value)) {\n                        default_value = 0;\n                    }\n                    var result = parseInt(option_value, 10);\n                    if (isNaN(result)) {\n                        result = default_value;\n                    }\n                    return result;\n                };\n                Options.prototype._get_selection = function(name, selection_list, default_value) {\n                    var result = this._get_selection_list(name, selection_list, default_value);\n                    if (result.length !== 1) {\n                        throw new Error(\"Invalid Option Value: The option '\" + name + \"' can only be one of the following values:\\n\" + selection_list + \"\\nYou passed in: '\" + this.raw_options[name] + \"'\");\n                    }\n                    return result[0];\n                };\n                Options.prototype._get_selection_list = function(name, selection_list, default_value) {\n                    if (!selection_list || selection_list.length === 0) {\n                        throw new Error(\"Selection list cannot be empty.\");\n                    }\n                    default_value = default_value || [\n                        selection_list[0]\n                    ];\n                    if (!this._is_valid_selection(default_value, selection_list)) {\n                        throw new Error(\"Invalid Default Value!\");\n                    }\n                    var result = this._get_array(name, default_value);\n                    if (!this._is_valid_selection(result, selection_list)) {\n                        throw new Error(\"Invalid Option Value: The option '\" + name + \"' can contain only the following values:\\n\" + selection_list + \"\\nYou passed in: '\" + this.raw_options[name] + \"'\");\n                    }\n                    return result;\n                };\n                Options.prototype._is_valid_selection = function(result, selection_list) {\n                    return result.length && selection_list.length && !result.some(function(item) {\n                        return selection_list.indexOf(item) === -1;\n                    });\n                };\n                // merges child options up with the parent options object\n                // Example: obj = {a: 1, b: {a: 2}}\n                //          mergeOpts(obj, 'b')\n                //\n                //          Returns: {a: 2}\n                function _mergeOpts(allOptions, childFieldName) {\n                    var finalOpts = {};\n                    allOptions = _normalizeOpts(allOptions);\n                    var name;\n                    for(name in allOptions){\n                        if (name !== childFieldName) {\n                            finalOpts[name] = allOptions[name];\n                        }\n                    }\n                    //merge in the per type settings for the childFieldName\n                    if (childFieldName && allOptions[childFieldName]) {\n                        for(name in allOptions[childFieldName]){\n                            finalOpts[name] = allOptions[childFieldName][name];\n                        }\n                    }\n                    return finalOpts;\n                }\n                function _normalizeOpts(options) {\n                    var convertedOpts = {};\n                    var key;\n                    for(key in options){\n                        var newKey = key.replace(/-/g, \"_\");\n                        convertedOpts[newKey] = options[key];\n                    }\n                    return convertedOpts;\n                }\n                module.exports.Options = Options;\n                module.exports.normalizeOpts = _normalizeOpts;\n                module.exports.mergeOpts = _mergeOpts;\n            /***/ },\n            ,\n            /* 8 */ /***/ function(module) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var regexp_has_sticky = RegExp.prototype.hasOwnProperty(\"sticky\");\n                function InputScanner(input_string) {\n                    this.__input = input_string || \"\";\n                    this.__input_length = this.__input.length;\n                    this.__position = 0;\n                }\n                InputScanner.prototype.restart = function() {\n                    this.__position = 0;\n                };\n                InputScanner.prototype.back = function() {\n                    if (this.__position > 0) {\n                        this.__position -= 1;\n                    }\n                };\n                InputScanner.prototype.hasNext = function() {\n                    return this.__position < this.__input_length;\n                };\n                InputScanner.prototype.next = function() {\n                    var val = null;\n                    if (this.hasNext()) {\n                        val = this.__input.charAt(this.__position);\n                        this.__position += 1;\n                    }\n                    return val;\n                };\n                InputScanner.prototype.peek = function(index) {\n                    var val = null;\n                    index = index || 0;\n                    index += this.__position;\n                    if (index >= 0 && index < this.__input_length) {\n                        val = this.__input.charAt(index);\n                    }\n                    return val;\n                };\n                // This is a JavaScript only helper function (not in python)\n                // Javascript doesn't have a match method\n                // and not all implementation support \"sticky\" flag.\n                // If they do not support sticky then both this.match() and this.test() method\n                // must get the match and check the index of the match.\n                // If sticky is supported and set, this method will use it.\n                // Otherwise it will check that global is set, and fall back to the slower method.\n                InputScanner.prototype.__match = function(pattern, index) {\n                    pattern.lastIndex = index;\n                    var pattern_match = pattern.exec(this.__input);\n                    if (pattern_match && !(regexp_has_sticky && pattern.sticky)) {\n                        if (pattern_match.index !== index) {\n                            pattern_match = null;\n                        }\n                    }\n                    return pattern_match;\n                };\n                InputScanner.prototype.test = function(pattern, index) {\n                    index = index || 0;\n                    index += this.__position;\n                    if (index >= 0 && index < this.__input_length) {\n                        return !!this.__match(pattern, index);\n                    } else {\n                        return false;\n                    }\n                };\n                InputScanner.prototype.testChar = function(pattern, index) {\n                    // test one character regex match\n                    var val = this.peek(index);\n                    pattern.lastIndex = 0;\n                    return val !== null && pattern.test(val);\n                };\n                InputScanner.prototype.match = function(pattern) {\n                    var pattern_match = this.__match(pattern, this.__position);\n                    if (pattern_match) {\n                        this.__position += pattern_match[0].length;\n                    } else {\n                        pattern_match = null;\n                    }\n                    return pattern_match;\n                };\n                InputScanner.prototype.read = function(starting_pattern, until_pattern, until_after) {\n                    var val = \"\";\n                    var match;\n                    if (starting_pattern) {\n                        match = this.match(starting_pattern);\n                        if (match) {\n                            val += match[0];\n                        }\n                    }\n                    if (until_pattern && (match || !starting_pattern)) {\n                        val += this.readUntil(until_pattern, until_after);\n                    }\n                    return val;\n                };\n                InputScanner.prototype.readUntil = function(pattern, until_after) {\n                    var val = \"\";\n                    var match_index = this.__position;\n                    pattern.lastIndex = this.__position;\n                    var pattern_match = pattern.exec(this.__input);\n                    if (pattern_match) {\n                        match_index = pattern_match.index;\n                        if (until_after) {\n                            match_index += pattern_match[0].length;\n                        }\n                    } else {\n                        match_index = this.__input_length;\n                    }\n                    val = this.__input.substring(this.__position, match_index);\n                    this.__position = match_index;\n                    return val;\n                };\n                InputScanner.prototype.readUntilAfter = function(pattern) {\n                    return this.readUntil(pattern, true);\n                };\n                InputScanner.prototype.get_regexp = function(pattern, match_from) {\n                    var result = null;\n                    var flags = \"g\";\n                    if (match_from && regexp_has_sticky) {\n                        flags = \"y\";\n                    }\n                    // strings are converted to regexp\n                    if (typeof pattern === \"string\" && pattern !== \"\") {\n                        // result = new RegExp(pattern.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&'), flags);\n                        result = new RegExp(pattern, flags);\n                    } else if (pattern) {\n                        result = new RegExp(pattern.source, flags);\n                    }\n                    return result;\n                };\n                InputScanner.prototype.get_literal_regexp = function(literal_string) {\n                    return RegExp(literal_string.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\"));\n                };\n                /* css beautifier legacy helpers */ InputScanner.prototype.peekUntilAfter = function(pattern) {\n                    var start = this.__position;\n                    var val = this.readUntilAfter(pattern);\n                    this.__position = start;\n                    return val;\n                };\n                InputScanner.prototype.lookBack = function(testVal) {\n                    var start = this.__position - 1;\n                    return start >= testVal.length && this.__input.substring(start - testVal.length, start).toLowerCase() === testVal;\n                };\n                module.exports.InputScanner = InputScanner;\n            /***/ },\n            /* 9 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_41688__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var InputScanner = __nested_webpack_require_41688__(8).InputScanner;\n                var Token = __nested_webpack_require_41688__(3).Token;\n                var TokenStream = __nested_webpack_require_41688__(10).TokenStream;\n                var WhitespacePattern = __nested_webpack_require_41688__(11).WhitespacePattern;\n                var TOKEN = {\n                    START: \"TK_START\",\n                    RAW: \"TK_RAW\",\n                    EOF: \"TK_EOF\"\n                };\n                var Tokenizer = function(input_string, options) {\n                    this._input = new InputScanner(input_string);\n                    this._options = options || {};\n                    this.__tokens = null;\n                    this._patterns = {};\n                    this._patterns.whitespace = new WhitespacePattern(this._input);\n                };\n                Tokenizer.prototype.tokenize = function() {\n                    this._input.restart();\n                    this.__tokens = new TokenStream();\n                    this._reset();\n                    var current;\n                    var previous = new Token(TOKEN.START, \"\");\n                    var open_token = null;\n                    var open_stack = [];\n                    var comments = new TokenStream();\n                    while(previous.type !== TOKEN.EOF){\n                        current = this._get_next_token(previous, open_token);\n                        while(this._is_comment(current)){\n                            comments.add(current);\n                            current = this._get_next_token(previous, open_token);\n                        }\n                        if (!comments.isEmpty()) {\n                            current.comments_before = comments;\n                            comments = new TokenStream();\n                        }\n                        current.parent = open_token;\n                        if (this._is_opening(current)) {\n                            open_stack.push(open_token);\n                            open_token = current;\n                        } else if (open_token && this._is_closing(current, open_token)) {\n                            current.opened = open_token;\n                            open_token.closed = current;\n                            open_token = open_stack.pop();\n                            current.parent = open_token;\n                        }\n                        current.previous = previous;\n                        previous.next = current;\n                        this.__tokens.add(current);\n                        previous = current;\n                    }\n                    return this.__tokens;\n                };\n                Tokenizer.prototype._is_first_token = function() {\n                    return this.__tokens.isEmpty();\n                };\n                Tokenizer.prototype._reset = function() {};\n                Tokenizer.prototype._get_next_token = function(previous_token, open_token) {\n                    this._readWhitespace();\n                    var resulting_string = this._input.read(/.+/g);\n                    if (resulting_string) {\n                        return this._create_token(TOKEN.RAW, resulting_string);\n                    } else {\n                        return this._create_token(TOKEN.EOF, \"\");\n                    }\n                };\n                Tokenizer.prototype._is_comment = function(current_token) {\n                    return false;\n                };\n                Tokenizer.prototype._is_opening = function(current_token) {\n                    return false;\n                };\n                Tokenizer.prototype._is_closing = function(current_token, open_token) {\n                    return false;\n                };\n                Tokenizer.prototype._create_token = function(type, text) {\n                    var token = new Token(type, text, this._patterns.whitespace.newline_count, this._patterns.whitespace.whitespace_before_token);\n                    return token;\n                };\n                Tokenizer.prototype._readWhitespace = function() {\n                    return this._patterns.whitespace.read();\n                };\n                module.exports.Tokenizer = Tokenizer;\n                module.exports.TOKEN = TOKEN;\n            /***/ },\n            /* 10 */ /***/ function(module) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ function TokenStream(parent_token) {\n                    // private\n                    this.__tokens = [];\n                    this.__tokens_length = this.__tokens.length;\n                    this.__position = 0;\n                    this.__parent_token = parent_token;\n                }\n                TokenStream.prototype.restart = function() {\n                    this.__position = 0;\n                };\n                TokenStream.prototype.isEmpty = function() {\n                    return this.__tokens_length === 0;\n                };\n                TokenStream.prototype.hasNext = function() {\n                    return this.__position < this.__tokens_length;\n                };\n                TokenStream.prototype.next = function() {\n                    var val = null;\n                    if (this.hasNext()) {\n                        val = this.__tokens[this.__position];\n                        this.__position += 1;\n                    }\n                    return val;\n                };\n                TokenStream.prototype.peek = function(index) {\n                    var val = null;\n                    index = index || 0;\n                    index += this.__position;\n                    if (index >= 0 && index < this.__tokens_length) {\n                        val = this.__tokens[index];\n                    }\n                    return val;\n                };\n                TokenStream.prototype.add = function(token) {\n                    if (this.__parent_token) {\n                        token.parent = this.__parent_token;\n                    }\n                    this.__tokens.push(token);\n                    this.__tokens_length += 1;\n                };\n                module.exports.TokenStream = TokenStream;\n            /***/ },\n            /* 11 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_50222__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var Pattern = __nested_webpack_require_50222__(12).Pattern;\n                function WhitespacePattern(input_scanner, parent) {\n                    Pattern.call(this, input_scanner, parent);\n                    if (parent) {\n                        this._line_regexp = this._input.get_regexp(parent._line_regexp);\n                    } else {\n                        this.__set_whitespace_patterns(\"\", \"\");\n                    }\n                    this.newline_count = 0;\n                    this.whitespace_before_token = \"\";\n                }\n                WhitespacePattern.prototype = new Pattern();\n                WhitespacePattern.prototype.__set_whitespace_patterns = function(whitespace_chars, newline_chars) {\n                    whitespace_chars += \"\\\\t \";\n                    newline_chars += \"\\\\n\\\\r\";\n                    this._match_pattern = this._input.get_regexp(\"[\" + whitespace_chars + newline_chars + \"]+\", true);\n                    this._newline_regexp = this._input.get_regexp(\"\\\\r\\\\n|[\" + newline_chars + \"]\");\n                };\n                WhitespacePattern.prototype.read = function() {\n                    this.newline_count = 0;\n                    this.whitespace_before_token = \"\";\n                    var resulting_string = this._input.read(this._match_pattern);\n                    if (resulting_string === \" \") {\n                        this.whitespace_before_token = \" \";\n                    } else if (resulting_string) {\n                        var matches = this.__split(this._newline_regexp, resulting_string);\n                        this.newline_count = matches.length - 1;\n                        this.whitespace_before_token = matches[this.newline_count];\n                    }\n                    return resulting_string;\n                };\n                WhitespacePattern.prototype.matching = function(whitespace_chars, newline_chars) {\n                    var result = this._create();\n                    result.__set_whitespace_patterns(whitespace_chars, newline_chars);\n                    result._update();\n                    return result;\n                };\n                WhitespacePattern.prototype._create = function() {\n                    return new WhitespacePattern(this._input, this);\n                };\n                WhitespacePattern.prototype.__split = function(regexp, input_string) {\n                    regexp.lastIndex = 0;\n                    var start_index = 0;\n                    var result = [];\n                    var next_match = regexp.exec(input_string);\n                    while(next_match){\n                        result.push(input_string.substring(start_index, next_match.index));\n                        start_index = next_match.index + next_match[0].length;\n                        next_match = regexp.exec(input_string);\n                    }\n                    if (start_index < input_string.length) {\n                        result.push(input_string.substring(start_index, input_string.length));\n                    } else {\n                        result.push(\"\");\n                    }\n                    return result;\n                };\n                module.exports.WhitespacePattern = WhitespacePattern;\n            /***/ },\n            /* 12 */ /***/ function(module) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ function Pattern(input_scanner, parent) {\n                    this._input = input_scanner;\n                    this._starting_pattern = null;\n                    this._match_pattern = null;\n                    this._until_pattern = null;\n                    this._until_after = false;\n                    if (parent) {\n                        this._starting_pattern = this._input.get_regexp(parent._starting_pattern, true);\n                        this._match_pattern = this._input.get_regexp(parent._match_pattern, true);\n                        this._until_pattern = this._input.get_regexp(parent._until_pattern);\n                        this._until_after = parent._until_after;\n                    }\n                }\n                Pattern.prototype.read = function() {\n                    var result = this._input.read(this._starting_pattern);\n                    if (!this._starting_pattern || result) {\n                        result += this._input.read(this._match_pattern, this._until_pattern, this._until_after);\n                    }\n                    return result;\n                };\n                Pattern.prototype.read_match = function() {\n                    return this._input.match(this._match_pattern);\n                };\n                Pattern.prototype.until_after = function(pattern) {\n                    var result = this._create();\n                    result._until_after = true;\n                    result._until_pattern = this._input.get_regexp(pattern);\n                    result._update();\n                    return result;\n                };\n                Pattern.prototype.until = function(pattern) {\n                    var result = this._create();\n                    result._until_after = false;\n                    result._until_pattern = this._input.get_regexp(pattern);\n                    result._update();\n                    return result;\n                };\n                Pattern.prototype.starting_with = function(pattern) {\n                    var result = this._create();\n                    result._starting_pattern = this._input.get_regexp(pattern, true);\n                    result._update();\n                    return result;\n                };\n                Pattern.prototype.matching = function(pattern) {\n                    var result = this._create();\n                    result._match_pattern = this._input.get_regexp(pattern, true);\n                    result._update();\n                    return result;\n                };\n                Pattern.prototype._create = function() {\n                    return new Pattern(this._input, this);\n                };\n                Pattern.prototype._update = function() {};\n                module.exports.Pattern = Pattern;\n            /***/ },\n            /* 13 */ /***/ function(module) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ function Directives(start_block_pattern, end_block_pattern) {\n                    start_block_pattern = typeof start_block_pattern === \"string\" ? start_block_pattern : start_block_pattern.source;\n                    end_block_pattern = typeof end_block_pattern === \"string\" ? end_block_pattern : end_block_pattern.source;\n                    this.__directives_block_pattern = new RegExp(start_block_pattern + / beautify( \\w+[:]\\w+)+ /.source + end_block_pattern, \"g\");\n                    this.__directive_pattern = / (\\w+)[:](\\w+)/g;\n                    this.__directives_end_ignore_pattern = new RegExp(start_block_pattern + /\\sbeautify\\signore:end\\s/.source + end_block_pattern, \"g\");\n                }\n                Directives.prototype.get_directives = function(text) {\n                    if (!text.match(this.__directives_block_pattern)) {\n                        return null;\n                    }\n                    var directives = {};\n                    this.__directive_pattern.lastIndex = 0;\n                    var directive_match = this.__directive_pattern.exec(text);\n                    while(directive_match){\n                        directives[directive_match[1]] = directive_match[2];\n                        directive_match = this.__directive_pattern.exec(text);\n                    }\n                    return directives;\n                };\n                Directives.prototype.readIgnored = function(input) {\n                    return input.readUntilAfter(this.__directives_end_ignore_pattern);\n                };\n                module.exports.Directives = Directives;\n            /***/ },\n            /* 14 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_61614__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var Pattern = __nested_webpack_require_61614__(12).Pattern;\n                var template_names = {\n                    django: false,\n                    erb: false,\n                    handlebars: false,\n                    php: false,\n                    smarty: false,\n                    angular: false\n                };\n                // This lets templates appear anywhere we would do a readUntil\n                // The cost is higher but it is pay to play.\n                function TemplatablePattern(input_scanner, parent) {\n                    Pattern.call(this, input_scanner, parent);\n                    this.__template_pattern = null;\n                    this._disabled = Object.assign({}, template_names);\n                    this._excluded = Object.assign({}, template_names);\n                    if (parent) {\n                        this.__template_pattern = this._input.get_regexp(parent.__template_pattern);\n                        this._excluded = Object.assign(this._excluded, parent._excluded);\n                        this._disabled = Object.assign(this._disabled, parent._disabled);\n                    }\n                    var pattern = new Pattern(input_scanner);\n                    this.__patterns = {\n                        handlebars_comment: pattern.starting_with(/{{!--/).until_after(/--}}/),\n                        handlebars_unescaped: pattern.starting_with(/{{{/).until_after(/}}}/),\n                        handlebars: pattern.starting_with(/{{/).until_after(/}}/),\n                        php: pattern.starting_with(/<\\?(?:[= ]|php)/).until_after(/\\?>/),\n                        erb: pattern.starting_with(/<%[^%]/).until_after(/[^%]%>/),\n                        // django coflicts with handlebars a bit.\n                        django: pattern.starting_with(/{%/).until_after(/%}/),\n                        django_value: pattern.starting_with(/{{/).until_after(/}}/),\n                        django_comment: pattern.starting_with(/{#/).until_after(/#}/),\n                        smarty: pattern.starting_with(/{(?=[^}{\\s\\n])/).until_after(/[^\\s\\n]}/),\n                        smarty_comment: pattern.starting_with(/{\\*/).until_after(/\\*}/),\n                        smarty_literal: pattern.starting_with(/{literal}/).until_after(/{\\/literal}/)\n                    };\n                }\n                TemplatablePattern.prototype = new Pattern();\n                TemplatablePattern.prototype._create = function() {\n                    return new TemplatablePattern(this._input, this);\n                };\n                TemplatablePattern.prototype._update = function() {\n                    this.__set_templated_pattern();\n                };\n                TemplatablePattern.prototype.disable = function(language) {\n                    var result = this._create();\n                    result._disabled[language] = true;\n                    result._update();\n                    return result;\n                };\n                TemplatablePattern.prototype.read_options = function(options) {\n                    var result = this._create();\n                    for(var language in template_names){\n                        result._disabled[language] = options.templating.indexOf(language) === -1;\n                    }\n                    result._update();\n                    return result;\n                };\n                TemplatablePattern.prototype.exclude = function(language) {\n                    var result = this._create();\n                    result._excluded[language] = true;\n                    result._update();\n                    return result;\n                };\n                TemplatablePattern.prototype.read = function() {\n                    var result = \"\";\n                    if (this._match_pattern) {\n                        result = this._input.read(this._starting_pattern);\n                    } else {\n                        result = this._input.read(this._starting_pattern, this.__template_pattern);\n                    }\n                    var next = this._read_template();\n                    while(next){\n                        if (this._match_pattern) {\n                            next += this._input.read(this._match_pattern);\n                        } else {\n                            next += this._input.readUntil(this.__template_pattern);\n                        }\n                        result += next;\n                        next = this._read_template();\n                    }\n                    if (this._until_after) {\n                        result += this._input.readUntilAfter(this._until_pattern);\n                    }\n                    return result;\n                };\n                TemplatablePattern.prototype.__set_templated_pattern = function() {\n                    var items = [];\n                    if (!this._disabled.php) {\n                        items.push(this.__patterns.php._starting_pattern.source);\n                    }\n                    if (!this._disabled.handlebars) {\n                        items.push(this.__patterns.handlebars._starting_pattern.source);\n                    }\n                    if (!this._disabled.erb) {\n                        items.push(this.__patterns.erb._starting_pattern.source);\n                    }\n                    if (!this._disabled.django) {\n                        items.push(this.__patterns.django._starting_pattern.source);\n                        // The starting pattern for django is more complex because it has different\n                        // patterns for value, comment, and other sections\n                        items.push(this.__patterns.django_value._starting_pattern.source);\n                        items.push(this.__patterns.django_comment._starting_pattern.source);\n                    }\n                    if (!this._disabled.smarty) {\n                        items.push(this.__patterns.smarty._starting_pattern.source);\n                    }\n                    if (this._until_pattern) {\n                        items.push(this._until_pattern.source);\n                    }\n                    this.__template_pattern = this._input.get_regexp(\"(?:\" + items.join(\"|\") + \")\");\n                };\n                TemplatablePattern.prototype._read_template = function() {\n                    var resulting_string = \"\";\n                    var c = this._input.peek();\n                    if (c === \"<\") {\n                        var peek1 = this._input.peek(1);\n                        //if we're in a comment, do something special\n                        // We treat all comments as literals, even more than preformatted tags\n                        // we just look for the appropriate close tag\n                        if (!this._disabled.php && !this._excluded.php && peek1 === \"?\") {\n                            resulting_string = resulting_string || this.__patterns.php.read();\n                        }\n                        if (!this._disabled.erb && !this._excluded.erb && peek1 === \"%\") {\n                            resulting_string = resulting_string || this.__patterns.erb.read();\n                        }\n                    } else if (c === \"{\") {\n                        if (!this._disabled.handlebars && !this._excluded.handlebars) {\n                            resulting_string = resulting_string || this.__patterns.handlebars_comment.read();\n                            resulting_string = resulting_string || this.__patterns.handlebars_unescaped.read();\n                            resulting_string = resulting_string || this.__patterns.handlebars.read();\n                        }\n                        if (!this._disabled.django) {\n                            // django coflicts with handlebars a bit.\n                            if (!this._excluded.django && !this._excluded.handlebars) {\n                                resulting_string = resulting_string || this.__patterns.django_value.read();\n                            }\n                            if (!this._excluded.django) {\n                                resulting_string = resulting_string || this.__patterns.django_comment.read();\n                                resulting_string = resulting_string || this.__patterns.django.read();\n                            }\n                        }\n                        if (!this._disabled.smarty) {\n                            // smarty cannot be enabled with django or handlebars enabled\n                            if (this._disabled.django && this._disabled.handlebars) {\n                                resulting_string = resulting_string || this.__patterns.smarty_comment.read();\n                                resulting_string = resulting_string || this.__patterns.smarty_literal.read();\n                                resulting_string = resulting_string || this.__patterns.smarty.read();\n                            }\n                        }\n                    }\n                    return resulting_string;\n                };\n                module.exports.TemplatablePattern = TemplatablePattern;\n            /***/ },\n            ,\n            ,\n            ,\n            /* 18 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_71997__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var Beautifier = __nested_webpack_require_71997__(19).Beautifier, Options = __nested_webpack_require_71997__(20).Options;\n                function style_html(html_source, options, js_beautify, css_beautify) {\n                    var beautifier = new Beautifier(html_source, options, js_beautify, css_beautify);\n                    return beautifier.beautify();\n                }\n                module.exports = style_html;\n                module.exports.defaultOptions = function() {\n                    return new Options();\n                };\n            /***/ },\n            /* 19 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_73833__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var Options = __nested_webpack_require_73833__(20).Options;\n                var Output = __nested_webpack_require_73833__(2).Output;\n                var Tokenizer = __nested_webpack_require_73833__(21).Tokenizer;\n                var TOKEN = __nested_webpack_require_73833__(21).TOKEN;\n                var lineBreak = /\\r\\n|[\\r\\n]/;\n                var allLineBreaks = /\\r\\n|[\\r\\n]/g;\n                var Printer = function(options, base_indent_string) {\n                    this.indent_level = 0;\n                    this.alignment_size = 0;\n                    this.max_preserve_newlines = options.max_preserve_newlines;\n                    this.preserve_newlines = options.preserve_newlines;\n                    this._output = new Output(options, base_indent_string);\n                };\n                Printer.prototype.current_line_has_match = function(pattern) {\n                    return this._output.current_line.has_match(pattern);\n                };\n                Printer.prototype.set_space_before_token = function(value, non_breaking) {\n                    this._output.space_before_token = value;\n                    this._output.non_breaking_space = non_breaking;\n                };\n                Printer.prototype.set_wrap_point = function() {\n                    this._output.set_indent(this.indent_level, this.alignment_size);\n                    this._output.set_wrap_point();\n                };\n                Printer.prototype.add_raw_token = function(token) {\n                    this._output.add_raw_token(token);\n                };\n                Printer.prototype.print_preserved_newlines = function(raw_token) {\n                    var newlines = 0;\n                    if (raw_token.type !== TOKEN.TEXT && raw_token.previous.type !== TOKEN.TEXT) {\n                        newlines = raw_token.newlines ? 1 : 0;\n                    }\n                    if (this.preserve_newlines) {\n                        newlines = raw_token.newlines < this.max_preserve_newlines + 1 ? raw_token.newlines : this.max_preserve_newlines + 1;\n                    }\n                    for(var n = 0; n < newlines; n++){\n                        this.print_newline(n > 0);\n                    }\n                    return newlines !== 0;\n                };\n                Printer.prototype.traverse_whitespace = function(raw_token) {\n                    if (raw_token.whitespace_before || raw_token.newlines) {\n                        if (!this.print_preserved_newlines(raw_token)) {\n                            this._output.space_before_token = true;\n                        }\n                        return true;\n                    }\n                    return false;\n                };\n                Printer.prototype.previous_token_wrapped = function() {\n                    return this._output.previous_token_wrapped;\n                };\n                Printer.prototype.print_newline = function(force) {\n                    this._output.add_new_line(force);\n                };\n                Printer.prototype.print_token = function(token) {\n                    if (token.text) {\n                        this._output.set_indent(this.indent_level, this.alignment_size);\n                        this._output.add_token(token.text);\n                    }\n                };\n                Printer.prototype.indent = function() {\n                    this.indent_level++;\n                };\n                Printer.prototype.deindent = function() {\n                    if (this.indent_level > 0) {\n                        this.indent_level--;\n                        this._output.set_indent(this.indent_level, this.alignment_size);\n                    }\n                };\n                Printer.prototype.get_full_indent = function(level) {\n                    level = this.indent_level + (level || 0);\n                    if (level < 1) {\n                        return \"\";\n                    }\n                    return this._output.get_indent_string(level);\n                };\n                var get_type_attribute = function(start_token) {\n                    var result = null;\n                    var raw_token = start_token.next;\n                    // Search attributes for a type attribute\n                    while(raw_token.type !== TOKEN.EOF && start_token.closed !== raw_token){\n                        if (raw_token.type === TOKEN.ATTRIBUTE && raw_token.text === \"type\") {\n                            if (raw_token.next && raw_token.next.type === TOKEN.EQUALS && raw_token.next.next && raw_token.next.next.type === TOKEN.VALUE) {\n                                result = raw_token.next.next.text;\n                            }\n                            break;\n                        }\n                        raw_token = raw_token.next;\n                    }\n                    return result;\n                };\n                var get_custom_beautifier_name = function(tag_check, raw_token) {\n                    var typeAttribute = null;\n                    var result = null;\n                    if (!raw_token.closed) {\n                        return null;\n                    }\n                    if (tag_check === \"script\") {\n                        typeAttribute = \"text/javascript\";\n                    } else if (tag_check === \"style\") {\n                        typeAttribute = \"text/css\";\n                    }\n                    typeAttribute = get_type_attribute(raw_token) || typeAttribute;\n                    // For script and style tags that have a type attribute, only enable custom beautifiers for matching values\n                    // For those without a type attribute use default;\n                    if (typeAttribute.search(\"text/css\") > -1) {\n                        result = \"css\";\n                    } else if (typeAttribute.search(/module|((text|application|dojo)\\/(x-)?(javascript|ecmascript|jscript|livescript|(ld\\+)?json|method|aspect))/) > -1) {\n                        result = \"javascript\";\n                    } else if (typeAttribute.search(/(text|application|dojo)\\/(x-)?(html)/) > -1) {\n                        result = \"html\";\n                    } else if (typeAttribute.search(/test\\/null/) > -1) {\n                        // Test only mime-type for testing the beautifier when null is passed as beautifing function\n                        result = \"null\";\n                    }\n                    return result;\n                };\n                function in_array(what, arr) {\n                    return arr.indexOf(what) !== -1;\n                }\n                function TagFrame(parent, parser_token, indent_level) {\n                    this.parent = parent || null;\n                    this.tag = parser_token ? parser_token.tag_name : \"\";\n                    this.indent_level = indent_level || 0;\n                    this.parser_token = parser_token || null;\n                }\n                function TagStack(printer) {\n                    this._printer = printer;\n                    this._current_frame = null;\n                }\n                TagStack.prototype.get_parser_token = function() {\n                    return this._current_frame ? this._current_frame.parser_token : null;\n                };\n                TagStack.prototype.record_tag = function(parser_token) {\n                    var new_frame = new TagFrame(this._current_frame, parser_token, this._printer.indent_level);\n                    this._current_frame = new_frame;\n                };\n                TagStack.prototype._try_pop_frame = function(frame) {\n                    var parser_token = null;\n                    if (frame) {\n                        parser_token = frame.parser_token;\n                        this._printer.indent_level = frame.indent_level;\n                        this._current_frame = frame.parent;\n                    }\n                    return parser_token;\n                };\n                TagStack.prototype._get_frame = function(tag_list, stop_list) {\n                    var frame = this._current_frame;\n                    while(frame){\n                        if (tag_list.indexOf(frame.tag) !== -1) {\n                            break;\n                        } else if (stop_list && stop_list.indexOf(frame.tag) !== -1) {\n                            frame = null;\n                            break;\n                        }\n                        frame = frame.parent;\n                    }\n                    return frame;\n                };\n                TagStack.prototype.try_pop = function(tag, stop_list) {\n                    var frame = this._get_frame([\n                        tag\n                    ], stop_list);\n                    return this._try_pop_frame(frame);\n                };\n                TagStack.prototype.indent_to_tag = function(tag_list) {\n                    var frame = this._get_frame(tag_list);\n                    if (frame) {\n                        this._printer.indent_level = frame.indent_level;\n                    }\n                };\n                function Beautifier(source_text, options, js_beautify, css_beautify) {\n                    //Wrapper function to invoke all the necessary constructors and deal with the output.\n                    this._source_text = source_text || \"\";\n                    options = options || {};\n                    this._js_beautify = js_beautify;\n                    this._css_beautify = css_beautify;\n                    this._tag_stack = null;\n                    // Allow the setting of language/file-type specific options\n                    // with inheritance of overall settings\n                    var optionHtml = new Options(options, \"html\");\n                    this._options = optionHtml;\n                    this._is_wrap_attributes_force = this._options.wrap_attributes.substr(0, \"force\".length) === \"force\";\n                    this._is_wrap_attributes_force_expand_multiline = this._options.wrap_attributes === \"force-expand-multiline\";\n                    this._is_wrap_attributes_force_aligned = this._options.wrap_attributes === \"force-aligned\";\n                    this._is_wrap_attributes_aligned_multiple = this._options.wrap_attributes === \"aligned-multiple\";\n                    this._is_wrap_attributes_preserve = this._options.wrap_attributes.substr(0, \"preserve\".length) === \"preserve\";\n                    this._is_wrap_attributes_preserve_aligned = this._options.wrap_attributes === \"preserve-aligned\";\n                }\n                Beautifier.prototype.beautify = function() {\n                    // if disabled, return the input unchanged.\n                    if (this._options.disabled) {\n                        return this._source_text;\n                    }\n                    var source_text = this._source_text;\n                    var eol = this._options.eol;\n                    if (this._options.eol === \"auto\") {\n                        eol = \"\\n\";\n                        if (source_text && lineBreak.test(source_text)) {\n                            eol = source_text.match(lineBreak)[0];\n                        }\n                    }\n                    // HACK: newline parsing inconsistent. This brute force normalizes the input.\n                    source_text = source_text.replace(allLineBreaks, \"\\n\");\n                    var baseIndentString = source_text.match(/^[\\t ]*/)[0];\n                    var last_token = {\n                        text: \"\",\n                        type: \"\"\n                    };\n                    var last_tag_token = new TagOpenParserToken();\n                    var printer = new Printer(this._options, baseIndentString);\n                    var tokens = new Tokenizer(source_text, this._options).tokenize();\n                    this._tag_stack = new TagStack(printer);\n                    var parser_token = null;\n                    var raw_token = tokens.next();\n                    while(raw_token.type !== TOKEN.EOF){\n                        if (raw_token.type === TOKEN.TAG_OPEN || raw_token.type === TOKEN.COMMENT) {\n                            parser_token = this._handle_tag_open(printer, raw_token, last_tag_token, last_token, tokens);\n                            last_tag_token = parser_token;\n                        } else if (raw_token.type === TOKEN.ATTRIBUTE || raw_token.type === TOKEN.EQUALS || raw_token.type === TOKEN.VALUE || raw_token.type === TOKEN.TEXT && !last_tag_token.tag_complete) {\n                            parser_token = this._handle_inside_tag(printer, raw_token, last_tag_token, last_token);\n                        } else if (raw_token.type === TOKEN.TAG_CLOSE) {\n                            parser_token = this._handle_tag_close(printer, raw_token, last_tag_token);\n                        } else if (raw_token.type === TOKEN.TEXT) {\n                            parser_token = this._handle_text(printer, raw_token, last_tag_token);\n                        } else if (raw_token.type === TOKEN.CONTROL_FLOW_OPEN) {\n                            parser_token = this._handle_control_flow_open(printer, raw_token);\n                        } else if (raw_token.type === TOKEN.CONTROL_FLOW_CLOSE) {\n                            parser_token = this._handle_control_flow_close(printer, raw_token);\n                        } else {\n                            // This should never happen, but if it does. Print the raw token\n                            printer.add_raw_token(raw_token);\n                        }\n                        last_token = parser_token;\n                        raw_token = tokens.next();\n                    }\n                    var sweet_code = printer._output.get_code(eol);\n                    return sweet_code;\n                };\n                Beautifier.prototype._handle_control_flow_open = function(printer, raw_token) {\n                    var parser_token = {\n                        text: raw_token.text,\n                        type: raw_token.type\n                    };\n                    printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== \"\", true);\n                    if (raw_token.newlines) {\n                        printer.print_preserved_newlines(raw_token);\n                    } else {\n                        printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== \"\", true);\n                    }\n                    printer.print_token(raw_token);\n                    printer.indent();\n                    return parser_token;\n                };\n                Beautifier.prototype._handle_control_flow_close = function(printer, raw_token) {\n                    var parser_token = {\n                        text: raw_token.text,\n                        type: raw_token.type\n                    };\n                    printer.deindent();\n                    if (raw_token.newlines) {\n                        printer.print_preserved_newlines(raw_token);\n                    } else {\n                        printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== \"\", true);\n                    }\n                    printer.print_token(raw_token);\n                    return parser_token;\n                };\n                Beautifier.prototype._handle_tag_close = function(printer, raw_token, last_tag_token) {\n                    var parser_token = {\n                        text: raw_token.text,\n                        type: raw_token.type\n                    };\n                    printer.alignment_size = 0;\n                    last_tag_token.tag_complete = true;\n                    printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== \"\", true);\n                    if (last_tag_token.is_unformatted) {\n                        printer.add_raw_token(raw_token);\n                    } else {\n                        if (last_tag_token.tag_start_char === \"<\") {\n                            printer.set_space_before_token(raw_token.text[0] === \"/\", true); // space before />, no space before >\n                            if (this._is_wrap_attributes_force_expand_multiline && last_tag_token.has_wrapped_attrs) {\n                                printer.print_newline(false);\n                            }\n                        }\n                        printer.print_token(raw_token);\n                    }\n                    if (last_tag_token.indent_content && !(last_tag_token.is_unformatted || last_tag_token.is_content_unformatted)) {\n                        printer.indent();\n                        // only indent once per opened tag\n                        last_tag_token.indent_content = false;\n                    }\n                    if (!last_tag_token.is_inline_element && !(last_tag_token.is_unformatted || last_tag_token.is_content_unformatted)) {\n                        printer.set_wrap_point();\n                    }\n                    return parser_token;\n                };\n                Beautifier.prototype._handle_inside_tag = function(printer, raw_token, last_tag_token, last_token) {\n                    var wrapped = last_tag_token.has_wrapped_attrs;\n                    var parser_token = {\n                        text: raw_token.text,\n                        type: raw_token.type\n                    };\n                    printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== \"\", true);\n                    if (last_tag_token.is_unformatted) {\n                        printer.add_raw_token(raw_token);\n                    } else if (last_tag_token.tag_start_char === \"{\" && raw_token.type === TOKEN.TEXT) {\n                        // For the insides of handlebars allow newlines or a single space between open and contents\n                        if (printer.print_preserved_newlines(raw_token)) {\n                            raw_token.newlines = 0;\n                            printer.add_raw_token(raw_token);\n                        } else {\n                            printer.print_token(raw_token);\n                        }\n                    } else {\n                        if (raw_token.type === TOKEN.ATTRIBUTE) {\n                            printer.set_space_before_token(true);\n                        } else if (raw_token.type === TOKEN.EQUALS) {\n                            printer.set_space_before_token(false);\n                        } else if (raw_token.type === TOKEN.VALUE && raw_token.previous.type === TOKEN.EQUALS) {\n                            printer.set_space_before_token(false);\n                        }\n                        if (raw_token.type === TOKEN.ATTRIBUTE && last_tag_token.tag_start_char === \"<\") {\n                            if (this._is_wrap_attributes_preserve || this._is_wrap_attributes_preserve_aligned) {\n                                printer.traverse_whitespace(raw_token);\n                                wrapped = wrapped || raw_token.newlines !== 0;\n                            }\n                            // Wrap for 'force' options, and if the number of attributes is at least that specified in 'wrap_attributes_min_attrs':\n                            // 1. always wrap the second and beyond attributes\n                            // 2. wrap the first attribute only if 'force-expand-multiline' is specified\n                            if (this._is_wrap_attributes_force && last_tag_token.attr_count >= this._options.wrap_attributes_min_attrs && (last_token.type !== TOKEN.TAG_OPEN || // ie. second attribute and beyond\n                            this._is_wrap_attributes_force_expand_multiline)) {\n                                printer.print_newline(false);\n                                wrapped = true;\n                            }\n                        }\n                        printer.print_token(raw_token);\n                        wrapped = wrapped || printer.previous_token_wrapped();\n                        last_tag_token.has_wrapped_attrs = wrapped;\n                    }\n                    return parser_token;\n                };\n                Beautifier.prototype._handle_text = function(printer, raw_token, last_tag_token) {\n                    var parser_token = {\n                        text: raw_token.text,\n                        type: \"TK_CONTENT\"\n                    };\n                    if (last_tag_token.custom_beautifier_name) {\n                        this._print_custom_beatifier_text(printer, raw_token, last_tag_token);\n                    } else if (last_tag_token.is_unformatted || last_tag_token.is_content_unformatted) {\n                        printer.add_raw_token(raw_token);\n                    } else {\n                        printer.traverse_whitespace(raw_token);\n                        printer.print_token(raw_token);\n                    }\n                    return parser_token;\n                };\n                Beautifier.prototype._print_custom_beatifier_text = function(printer, raw_token, last_tag_token) {\n                    var local = this;\n                    if (raw_token.text !== \"\") {\n                        var text = raw_token.text, _beautifier, script_indent_level = 1, pre = \"\", post = \"\";\n                        if (last_tag_token.custom_beautifier_name === \"javascript\" && typeof this._js_beautify === \"function\") {\n                            _beautifier = this._js_beautify;\n                        } else if (last_tag_token.custom_beautifier_name === \"css\" && typeof this._css_beautify === \"function\") {\n                            _beautifier = this._css_beautify;\n                        } else if (last_tag_token.custom_beautifier_name === \"html\") {\n                            _beautifier = function(html_source, options) {\n                                var beautifier = new Beautifier(html_source, options, local._js_beautify, local._css_beautify);\n                                return beautifier.beautify();\n                            };\n                        }\n                        if (this._options.indent_scripts === \"keep\") {\n                            script_indent_level = 0;\n                        } else if (this._options.indent_scripts === \"separate\") {\n                            script_indent_level = -printer.indent_level;\n                        }\n                        var indentation = printer.get_full_indent(script_indent_level);\n                        // if there is at least one empty line at the end of this text, strip it\n                        // we'll be adding one back after the text but before the containing tag.\n                        text = text.replace(/\\n[ \\t]*$/, \"\");\n                        // Handle the case where content is wrapped in a comment or cdata.\n                        if (last_tag_token.custom_beautifier_name !== \"html\" && text[0] === \"<\" && text.match(/^(<!--|<!\\[CDATA\\[)/)) {\n                            var matched = /^(<!--[^\\n]*|<!\\[CDATA\\[)(\\n?)([ \\t\\n]*)([\\s\\S]*)(-->|]]>)$/.exec(text);\n                            // if we start to wrap but don't finish, print raw\n                            if (!matched) {\n                                printer.add_raw_token(raw_token);\n                                return;\n                            }\n                            pre = indentation + matched[1] + \"\\n\";\n                            text = matched[4];\n                            if (matched[5]) {\n                                post = indentation + matched[5];\n                            }\n                            // if there is at least one empty line at the end of this text, strip it\n                            // we'll be adding one back after the text but before the containing tag.\n                            text = text.replace(/\\n[ \\t]*$/, \"\");\n                            if (matched[2] || matched[3].indexOf(\"\\n\") !== -1) {\n                                // if the first line of the non-comment text has spaces\n                                // use that as the basis for indenting in null case.\n                                matched = matched[3].match(/[ \\t]+$/);\n                                if (matched) {\n                                    raw_token.whitespace_before = matched[0];\n                                }\n                            }\n                        }\n                        if (text) {\n                            if (_beautifier) {\n                                // call the Beautifier if avaliable\n                                var Child_options = function() {\n                                    this.eol = \"\\n\";\n                                };\n                                Child_options.prototype = this._options.raw_options;\n                                var child_options = new Child_options();\n                                text = _beautifier(indentation + text, child_options);\n                            } else {\n                                // simply indent the string otherwise\n                                var white = raw_token.whitespace_before;\n                                if (white) {\n                                    text = text.replace(new RegExp(\"\\n(\" + white + \")?\", \"g\"), \"\\n\");\n                                }\n                                text = indentation + text.replace(/\\n/g, \"\\n\" + indentation);\n                            }\n                        }\n                        if (pre) {\n                            if (!text) {\n                                text = pre + post;\n                            } else {\n                                text = pre + text + \"\\n\" + post;\n                            }\n                        }\n                        printer.print_newline(false);\n                        if (text) {\n                            raw_token.text = text;\n                            raw_token.whitespace_before = \"\";\n                            raw_token.newlines = 0;\n                            printer.add_raw_token(raw_token);\n                            printer.print_newline(true);\n                        }\n                    }\n                };\n                Beautifier.prototype._handle_tag_open = function(printer, raw_token, last_tag_token, last_token, tokens) {\n                    var parser_token = this._get_tag_open_token(raw_token);\n                    if ((last_tag_token.is_unformatted || last_tag_token.is_content_unformatted) && !last_tag_token.is_empty_element && raw_token.type === TOKEN.TAG_OPEN && !parser_token.is_start_tag) {\n                        // End element tags for unformatted or content_unformatted elements\n                        // are printed raw to keep any newlines inside them exactly the same.\n                        printer.add_raw_token(raw_token);\n                        parser_token.start_tag_token = this._tag_stack.try_pop(parser_token.tag_name);\n                    } else {\n                        printer.traverse_whitespace(raw_token);\n                        this._set_tag_position(printer, raw_token, parser_token, last_tag_token, last_token);\n                        if (!parser_token.is_inline_element) {\n                            printer.set_wrap_point();\n                        }\n                        printer.print_token(raw_token);\n                    }\n                    // count the number of attributes\n                    if (parser_token.is_start_tag && this._is_wrap_attributes_force) {\n                        var peek_index = 0;\n                        var peek_token;\n                        do {\n                            peek_token = tokens.peek(peek_index);\n                            if (peek_token.type === TOKEN.ATTRIBUTE) {\n                                parser_token.attr_count += 1;\n                            }\n                            peek_index += 1;\n                        }while (peek_token.type !== TOKEN.EOF && peek_token.type !== TOKEN.TAG_CLOSE);\n                    }\n                    //indent attributes an auto, forced, aligned or forced-align line-wrap\n                    if (this._is_wrap_attributes_force_aligned || this._is_wrap_attributes_aligned_multiple || this._is_wrap_attributes_preserve_aligned) {\n                        parser_token.alignment_size = raw_token.text.length + 1;\n                    }\n                    if (!parser_token.tag_complete && !parser_token.is_unformatted) {\n                        printer.alignment_size = parser_token.alignment_size;\n                    }\n                    return parser_token;\n                };\n                var TagOpenParserToken = function(parent, raw_token) {\n                    this.parent = parent || null;\n                    this.text = \"\";\n                    this.type = \"TK_TAG_OPEN\";\n                    this.tag_name = \"\";\n                    this.is_inline_element = false;\n                    this.is_unformatted = false;\n                    this.is_content_unformatted = false;\n                    this.is_empty_element = false;\n                    this.is_start_tag = false;\n                    this.is_end_tag = false;\n                    this.indent_content = false;\n                    this.multiline_content = false;\n                    this.custom_beautifier_name = null;\n                    this.start_tag_token = null;\n                    this.attr_count = 0;\n                    this.has_wrapped_attrs = false;\n                    this.alignment_size = 0;\n                    this.tag_complete = false;\n                    this.tag_start_char = \"\";\n                    this.tag_check = \"\";\n                    if (!raw_token) {\n                        this.tag_complete = true;\n                    } else {\n                        var tag_check_match;\n                        this.tag_start_char = raw_token.text[0];\n                        this.text = raw_token.text;\n                        if (this.tag_start_char === \"<\") {\n                            tag_check_match = raw_token.text.match(/^<([^\\s>]*)/);\n                            this.tag_check = tag_check_match ? tag_check_match[1] : \"\";\n                        } else {\n                            tag_check_match = raw_token.text.match(/^{{~?(?:[\\^]|#\\*?)?([^\\s}]+)/);\n                            this.tag_check = tag_check_match ? tag_check_match[1] : \"\";\n                            // handle \"{{#> myPartial}}\" or \"{{~#> myPartial}}\"\n                            if ((raw_token.text.startsWith(\"{{#>\") || raw_token.text.startsWith(\"{{~#>\")) && this.tag_check[0] === \">\") {\n                                if (this.tag_check === \">\" && raw_token.next !== null) {\n                                    this.tag_check = raw_token.next.text.split(\" \")[0];\n                                } else {\n                                    this.tag_check = raw_token.text.split(\">\")[1];\n                                }\n                            }\n                        }\n                        this.tag_check = this.tag_check.toLowerCase();\n                        if (raw_token.type === TOKEN.COMMENT) {\n                            this.tag_complete = true;\n                        }\n                        this.is_start_tag = this.tag_check.charAt(0) !== \"/\";\n                        this.tag_name = !this.is_start_tag ? this.tag_check.substr(1) : this.tag_check;\n                        this.is_end_tag = !this.is_start_tag || raw_token.closed && raw_token.closed.text === \"/>\";\n                        // if whitespace handler ~ included (i.e. {{~#if true}}), handlebars tags start at pos 3 not pos 2\n                        var handlebar_starts = 2;\n                        if (this.tag_start_char === \"{\" && this.text.length >= 3) {\n                            if (this.text.charAt(2) === \"~\") {\n                                handlebar_starts = 3;\n                            }\n                        }\n                        // handlebars tags that don't start with # or ^ are single_tags, and so also start and end.\n                        this.is_end_tag = this.is_end_tag || this.tag_start_char === \"{\" && (this.text.length < 3 || /[^#\\^]/.test(this.text.charAt(handlebar_starts)));\n                    }\n                };\n                Beautifier.prototype._get_tag_open_token = function(raw_token) {\n                    var parser_token = new TagOpenParserToken(this._tag_stack.get_parser_token(), raw_token);\n                    parser_token.alignment_size = this._options.wrap_attributes_indent_size;\n                    parser_token.is_end_tag = parser_token.is_end_tag || in_array(parser_token.tag_check, this._options.void_elements);\n                    parser_token.is_empty_element = parser_token.tag_complete || parser_token.is_start_tag && parser_token.is_end_tag;\n                    parser_token.is_unformatted = !parser_token.tag_complete && in_array(parser_token.tag_check, this._options.unformatted);\n                    parser_token.is_content_unformatted = !parser_token.is_empty_element && in_array(parser_token.tag_check, this._options.content_unformatted);\n                    parser_token.is_inline_element = in_array(parser_token.tag_name, this._options.inline) || this._options.inline_custom_elements && parser_token.tag_name.includes(\"-\") || parser_token.tag_start_char === \"{\";\n                    return parser_token;\n                };\n                Beautifier.prototype._set_tag_position = function(printer, raw_token, parser_token, last_tag_token, last_token) {\n                    if (!parser_token.is_empty_element) {\n                        if (parser_token.is_end_tag) {\n                            parser_token.start_tag_token = this._tag_stack.try_pop(parser_token.tag_name); //remove it and all ancestors\n                        } else {\n                            // check if this tag is starting an element that has optional end element\n                            // and do an ending needed\n                            if (this._do_optional_end_element(parser_token)) {\n                                if (!parser_token.is_inline_element) {\n                                    printer.print_newline(false);\n                                }\n                            }\n                            this._tag_stack.record_tag(parser_token); //push it on the tag stack\n                            if ((parser_token.tag_name === \"script\" || parser_token.tag_name === \"style\") && !(parser_token.is_unformatted || parser_token.is_content_unformatted)) {\n                                parser_token.custom_beautifier_name = get_custom_beautifier_name(parser_token.tag_check, raw_token);\n                            }\n                        }\n                    }\n                    if (in_array(parser_token.tag_check, this._options.extra_liners)) {\n                        printer.print_newline(false);\n                        if (!printer._output.just_added_blankline()) {\n                            printer.print_newline(true);\n                        }\n                    }\n                    if (parser_token.is_empty_element) {\n                        // if you hit an else case, reset the indent level if you are inside an:\n                        // 'if', 'unless', or 'each' block.\n                        if (parser_token.tag_start_char === \"{\" && parser_token.tag_check === \"else\") {\n                            this._tag_stack.indent_to_tag([\n                                \"if\",\n                                \"unless\",\n                                \"each\"\n                            ]);\n                            parser_token.indent_content = true;\n                            // Don't add a newline if opening {{#if}} tag is on the current line\n                            var foundIfOnCurrentLine = printer.current_line_has_match(/{{#if/);\n                            if (!foundIfOnCurrentLine) {\n                                printer.print_newline(false);\n                            }\n                        }\n                        // Don't add a newline before elements that should remain where they are.\n                        if (parser_token.tag_name === \"!--\" && last_token.type === TOKEN.TAG_CLOSE && last_tag_token.is_end_tag && parser_token.text.indexOf(\"\\n\") === -1) {\n                        //Do nothing. Leave comments on same line.\n                        } else {\n                            if (!(parser_token.is_inline_element || parser_token.is_unformatted)) {\n                                printer.print_newline(false);\n                            }\n                            this._calcluate_parent_multiline(printer, parser_token);\n                        }\n                    } else if (parser_token.is_end_tag) {\n                        var do_end_expand = false;\n                        // deciding whether a block is multiline should not be this hard\n                        do_end_expand = parser_token.start_tag_token && parser_token.start_tag_token.multiline_content;\n                        do_end_expand = do_end_expand || !parser_token.is_inline_element && !(last_tag_token.is_inline_element || last_tag_token.is_unformatted) && !(last_token.type === TOKEN.TAG_CLOSE && parser_token.start_tag_token === last_tag_token) && last_token.type !== \"TK_CONTENT\";\n                        if (parser_token.is_content_unformatted || parser_token.is_unformatted) {\n                            do_end_expand = false;\n                        }\n                        if (do_end_expand) {\n                            printer.print_newline(false);\n                        }\n                    } else {\n                        parser_token.indent_content = !parser_token.custom_beautifier_name;\n                        if (parser_token.tag_start_char === \"<\") {\n                            if (parser_token.tag_name === \"html\") {\n                                parser_token.indent_content = this._options.indent_inner_html;\n                            } else if (parser_token.tag_name === \"head\") {\n                                parser_token.indent_content = this._options.indent_head_inner_html;\n                            } else if (parser_token.tag_name === \"body\") {\n                                parser_token.indent_content = this._options.indent_body_inner_html;\n                            }\n                        }\n                        if (!(parser_token.is_inline_element || parser_token.is_unformatted) && (last_token.type !== \"TK_CONTENT\" || parser_token.is_content_unformatted)) {\n                            printer.print_newline(false);\n                        }\n                        this._calcluate_parent_multiline(printer, parser_token);\n                    }\n                };\n                Beautifier.prototype._calcluate_parent_multiline = function(printer, parser_token) {\n                    if (parser_token.parent && printer._output.just_added_newline() && !((parser_token.is_inline_element || parser_token.is_unformatted) && parser_token.parent.is_inline_element)) {\n                        parser_token.parent.multiline_content = true;\n                    }\n                };\n                //To be used for <p> tag special case:\n                var p_closers = [\n                    \"address\",\n                    \"article\",\n                    \"aside\",\n                    \"blockquote\",\n                    \"details\",\n                    \"div\",\n                    \"dl\",\n                    \"fieldset\",\n                    \"figcaption\",\n                    \"figure\",\n                    \"footer\",\n                    \"form\",\n                    \"h1\",\n                    \"h2\",\n                    \"h3\",\n                    \"h4\",\n                    \"h5\",\n                    \"h6\",\n                    \"header\",\n                    \"hr\",\n                    \"main\",\n                    \"menu\",\n                    \"nav\",\n                    \"ol\",\n                    \"p\",\n                    \"pre\",\n                    \"section\",\n                    \"table\",\n                    \"ul\"\n                ];\n                var p_parent_excludes = [\n                    \"a\",\n                    \"audio\",\n                    \"del\",\n                    \"ins\",\n                    \"map\",\n                    \"noscript\",\n                    \"video\"\n                ];\n                Beautifier.prototype._do_optional_end_element = function(parser_token) {\n                    var result = null;\n                    // NOTE: cases of \"if there is no more content in the parent element\"\n                    // are handled automatically by the beautifier.\n                    // It assumes parent or ancestor close tag closes all children.\n                    // https://www.w3.org/TR/html5/syntax.html#optional-tags\n                    if (parser_token.is_empty_element || !parser_token.is_start_tag || !parser_token.parent) {\n                        return;\n                    }\n                    if (parser_token.tag_name === \"body\") {\n                        // A head element’s end tag may be omitted if the head element is not immediately followed by a space character or a comment.\n                        result = result || this._tag_stack.try_pop(\"head\");\n                    //} else if (parser_token.tag_name === 'body') {\n                    // DONE: A body element’s end tag may be omitted if the body element is not immediately followed by a comment.\n                    } else if (parser_token.tag_name === \"li\") {\n                        // An li element’s end tag may be omitted if the li element is immediately followed by another li element or if there is no more content in the parent element.\n                        result = result || this._tag_stack.try_pop(\"li\", [\n                            \"ol\",\n                            \"ul\",\n                            \"menu\"\n                        ]);\n                    } else if (parser_token.tag_name === \"dd\" || parser_token.tag_name === \"dt\") {\n                        // A dd element’s end tag may be omitted if the dd element is immediately followed by another dd element or a dt element, or if there is no more content in the parent element.\n                        // A dt element’s end tag may be omitted if the dt element is immediately followed by another dt element or a dd element.\n                        result = result || this._tag_stack.try_pop(\"dt\", [\n                            \"dl\"\n                        ]);\n                        result = result || this._tag_stack.try_pop(\"dd\", [\n                            \"dl\"\n                        ]);\n                    } else if (parser_token.parent.tag_name === \"p\" && p_closers.indexOf(parser_token.tag_name) !== -1) {\n                        // IMPORTANT: this else-if works because p_closers has no overlap with any other element we look for in this method\n                        // check for the parent element is an HTML element that is not an <a>, <audio>, <del>, <ins>, <map>, <noscript>, or <video> element,  or an autonomous custom element.\n                        // To do this right, this needs to be coded as an inclusion of the inverse of the exclusion above.\n                        // But to start with (if we ignore \"autonomous custom elements\") the exclusion would be fine.\n                        var p_parent = parser_token.parent.parent;\n                        if (!p_parent || p_parent_excludes.indexOf(p_parent.tag_name) === -1) {\n                            result = result || this._tag_stack.try_pop(\"p\");\n                        }\n                    } else if (parser_token.tag_name === \"rp\" || parser_token.tag_name === \"rt\") {\n                        // An rt element’s end tag may be omitted if the rt element is immediately followed by an rt or rp element, or if there is no more content in the parent element.\n                        // An rp element’s end tag may be omitted if the rp element is immediately followed by an rt or rp element, or if there is no more content in the parent element.\n                        result = result || this._tag_stack.try_pop(\"rt\", [\n                            \"ruby\",\n                            \"rtc\"\n                        ]);\n                        result = result || this._tag_stack.try_pop(\"rp\", [\n                            \"ruby\",\n                            \"rtc\"\n                        ]);\n                    } else if (parser_token.tag_name === \"optgroup\") {\n                        // An optgroup element’s end tag may be omitted if the optgroup element is immediately followed by another optgroup element, or if there is no more content in the parent element.\n                        // An option element’s end tag may be omitted if the option element is immediately followed by another option element, or if it is immediately followed by an optgroup element, or if there is no more content in the parent element.\n                        result = result || this._tag_stack.try_pop(\"optgroup\", [\n                            \"select\"\n                        ]);\n                    //result = result || this._tag_stack.try_pop('option', ['select']);\n                    } else if (parser_token.tag_name === \"option\") {\n                        // An option element’s end tag may be omitted if the option element is immediately followed by another option element, or if it is immediately followed by an optgroup element, or if there is no more content in the parent element.\n                        result = result || this._tag_stack.try_pop(\"option\", [\n                            \"select\",\n                            \"datalist\",\n                            \"optgroup\"\n                        ]);\n                    } else if (parser_token.tag_name === \"colgroup\") {\n                        // DONE: A colgroup element’s end tag may be omitted if the colgroup element is not immediately followed by a space character or a comment.\n                        // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.\n                        result = result || this._tag_stack.try_pop(\"caption\", [\n                            \"table\"\n                        ]);\n                    } else if (parser_token.tag_name === \"thead\") {\n                        // A colgroup element's end tag may be ommitted if a thead, tfoot, tbody, or tr element is started.\n                        // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.\n                        result = result || this._tag_stack.try_pop(\"caption\", [\n                            \"table\"\n                        ]);\n                        result = result || this._tag_stack.try_pop(\"colgroup\", [\n                            \"table\"\n                        ]);\n                    //} else if (parser_token.tag_name === 'caption') {\n                    // DONE: A caption element’s end tag may be omitted if the caption element is not immediately followed by a space character or a comment.\n                    } else if (parser_token.tag_name === \"tbody\" || parser_token.tag_name === \"tfoot\") {\n                        // A thead element’s end tag may be omitted if the thead element is immediately followed by a tbody or tfoot element.\n                        // A tbody element’s end tag may be omitted if the tbody element is immediately followed by a tbody or tfoot element, or if there is no more content in the parent element.\n                        // A colgroup element's end tag may be ommitted if a thead, tfoot, tbody, or tr element is started.\n                        // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.\n                        result = result || this._tag_stack.try_pop(\"caption\", [\n                            \"table\"\n                        ]);\n                        result = result || this._tag_stack.try_pop(\"colgroup\", [\n                            \"table\"\n                        ]);\n                        result = result || this._tag_stack.try_pop(\"thead\", [\n                            \"table\"\n                        ]);\n                        result = result || this._tag_stack.try_pop(\"tbody\", [\n                            \"table\"\n                        ]);\n                    //} else if (parser_token.tag_name === 'tfoot') {\n                    // DONE: A tfoot element’s end tag may be omitted if there is no more content in the parent element.\n                    } else if (parser_token.tag_name === \"tr\") {\n                        // A tr element’s end tag may be omitted if the tr element is immediately followed by another tr element, or if there is no more content in the parent element.\n                        // A colgroup element's end tag may be ommitted if a thead, tfoot, tbody, or tr element is started.\n                        // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.\n                        result = result || this._tag_stack.try_pop(\"caption\", [\n                            \"table\"\n                        ]);\n                        result = result || this._tag_stack.try_pop(\"colgroup\", [\n                            \"table\"\n                        ]);\n                        result = result || this._tag_stack.try_pop(\"tr\", [\n                            \"table\",\n                            \"thead\",\n                            \"tbody\",\n                            \"tfoot\"\n                        ]);\n                    } else if (parser_token.tag_name === \"th\" || parser_token.tag_name === \"td\") {\n                        // A td element’s end tag may be omitted if the td element is immediately followed by a td or th element, or if there is no more content in the parent element.\n                        // A th element’s end tag may be omitted if the th element is immediately followed by a td or th element, or if there is no more content in the parent element.\n                        result = result || this._tag_stack.try_pop(\"td\", [\n                            \"table\",\n                            \"thead\",\n                            \"tbody\",\n                            \"tfoot\",\n                            \"tr\"\n                        ]);\n                        result = result || this._tag_stack.try_pop(\"th\", [\n                            \"table\",\n                            \"thead\",\n                            \"tbody\",\n                            \"tfoot\",\n                            \"tr\"\n                        ]);\n                    }\n                    // Start element omission not handled currently\n                    // A head element’s start tag may be omitted if the element is empty, or if the first thing inside the head element is an element.\n                    // A tbody element’s start tag may be omitted if the first thing inside the tbody element is a tr element, and if the element is not immediately preceded by a tbody, thead, or tfoot element whose end tag has been omitted. (It can’t be omitted if the element is empty.)\n                    // A colgroup element’s start tag may be omitted if the first thing inside the colgroup element is a col element, and if the element is not immediately preceded by another colgroup element whose end tag has been omitted. (It can’t be omitted if the element is empty.)\n                    // Fix up the parent of the parser token\n                    parser_token.parent = this._tag_stack.get_parser_token();\n                    return result;\n                };\n                module.exports.Beautifier = Beautifier;\n            /***/ },\n            /* 20 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_126544__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var BaseOptions = __nested_webpack_require_126544__(6).Options;\n                function Options(options) {\n                    BaseOptions.call(this, options, \"html\");\n                    if (this.templating.length === 1 && this.templating[0] === \"auto\") {\n                        this.templating = [\n                            \"django\",\n                            \"erb\",\n                            \"handlebars\",\n                            \"php\"\n                        ];\n                    }\n                    this.indent_inner_html = this._get_boolean(\"indent_inner_html\");\n                    this.indent_body_inner_html = this._get_boolean(\"indent_body_inner_html\", true);\n                    this.indent_head_inner_html = this._get_boolean(\"indent_head_inner_html\", true);\n                    this.indent_handlebars = this._get_boolean(\"indent_handlebars\", true);\n                    this.wrap_attributes = this._get_selection(\"wrap_attributes\", [\n                        \"auto\",\n                        \"force\",\n                        \"force-aligned\",\n                        \"force-expand-multiline\",\n                        \"aligned-multiple\",\n                        \"preserve\",\n                        \"preserve-aligned\"\n                    ]);\n                    this.wrap_attributes_min_attrs = this._get_number(\"wrap_attributes_min_attrs\", 2);\n                    this.wrap_attributes_indent_size = this._get_number(\"wrap_attributes_indent_size\", this.indent_size);\n                    this.extra_liners = this._get_array(\"extra_liners\", [\n                        \"head\",\n                        \"body\",\n                        \"/html\"\n                    ]);\n                    // Block vs inline elements\n                    // https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements\n                    // https://developer.mozilla.org/en-US/docs/Web/HTML/Inline_elements\n                    // https://www.w3.org/TR/html5/dom.html#phrasing-content\n                    this.inline = this._get_array(\"inline\", [\n                        \"a\",\n                        \"abbr\",\n                        \"area\",\n                        \"audio\",\n                        \"b\",\n                        \"bdi\",\n                        \"bdo\",\n                        \"br\",\n                        \"button\",\n                        \"canvas\",\n                        \"cite\",\n                        \"code\",\n                        \"data\",\n                        \"datalist\",\n                        \"del\",\n                        \"dfn\",\n                        \"em\",\n                        \"embed\",\n                        \"i\",\n                        \"iframe\",\n                        \"img\",\n                        \"input\",\n                        \"ins\",\n                        \"kbd\",\n                        \"keygen\",\n                        \"label\",\n                        \"map\",\n                        \"mark\",\n                        \"math\",\n                        \"meter\",\n                        \"noscript\",\n                        \"object\",\n                        \"output\",\n                        \"progress\",\n                        \"q\",\n                        \"ruby\",\n                        \"s\",\n                        \"samp\",\n                        /* 'script', */ \"select\",\n                        \"small\",\n                        \"span\",\n                        \"strong\",\n                        \"sub\",\n                        \"sup\",\n                        \"svg\",\n                        \"template\",\n                        \"textarea\",\n                        \"time\",\n                        \"u\",\n                        \"var\",\n                        \"video\",\n                        \"wbr\",\n                        \"text\",\n                        // obsolete inline tags\n                        \"acronym\",\n                        \"big\",\n                        \"strike\",\n                        \"tt\"\n                    ]);\n                    this.inline_custom_elements = this._get_boolean(\"inline_custom_elements\", true);\n                    this.void_elements = this._get_array(\"void_elements\", [\n                        // HTLM void elements - aka self-closing tags - aka singletons\n                        // https://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements\n                        \"area\",\n                        \"base\",\n                        \"br\",\n                        \"col\",\n                        \"embed\",\n                        \"hr\",\n                        \"img\",\n                        \"input\",\n                        \"keygen\",\n                        \"link\",\n                        \"menuitem\",\n                        \"meta\",\n                        \"param\",\n                        \"source\",\n                        \"track\",\n                        \"wbr\",\n                        // NOTE: Optional tags are too complex for a simple list\n                        // they are hard coded in _do_optional_end_element\n                        // Doctype and xml elements\n                        \"!doctype\",\n                        \"?xml\",\n                        // obsolete tags\n                        // basefont: https://www.computerhope.com/jargon/h/html-basefont-tag.htm\n                        // isndex: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/isindex\n                        \"basefont\",\n                        \"isindex\"\n                    ]);\n                    this.unformatted = this._get_array(\"unformatted\", []);\n                    this.content_unformatted = this._get_array(\"content_unformatted\", [\n                        \"pre\",\n                        \"textarea\"\n                    ]);\n                    this.unformatted_content_delimiter = this._get_characters(\"unformatted_content_delimiter\");\n                    this.indent_scripts = this._get_selection(\"indent_scripts\", [\n                        \"normal\",\n                        \"keep\",\n                        \"separate\"\n                    ]);\n                }\n                Options.prototype = new BaseOptions();\n                module.exports.Options = Options;\n            /***/ },\n            /* 21 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_134005__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var BaseTokenizer = __nested_webpack_require_134005__(9).Tokenizer;\n                var BASETOKEN = __nested_webpack_require_134005__(9).TOKEN;\n                var Directives = __nested_webpack_require_134005__(13).Directives;\n                var TemplatablePattern = __nested_webpack_require_134005__(14).TemplatablePattern;\n                var Pattern = __nested_webpack_require_134005__(12).Pattern;\n                var TOKEN = {\n                    TAG_OPEN: \"TK_TAG_OPEN\",\n                    TAG_CLOSE: \"TK_TAG_CLOSE\",\n                    CONTROL_FLOW_OPEN: \"TK_CONTROL_FLOW_OPEN\",\n                    CONTROL_FLOW_CLOSE: \"TK_CONTROL_FLOW_CLOSE\",\n                    ATTRIBUTE: \"TK_ATTRIBUTE\",\n                    EQUALS: \"TK_EQUALS\",\n                    VALUE: \"TK_VALUE\",\n                    COMMENT: \"TK_COMMENT\",\n                    TEXT: \"TK_TEXT\",\n                    UNKNOWN: \"TK_UNKNOWN\",\n                    START: BASETOKEN.START,\n                    RAW: BASETOKEN.RAW,\n                    EOF: BASETOKEN.EOF\n                };\n                var directives_core = new Directives(/<\\!--/, /-->/);\n                var Tokenizer = function(input_string, options) {\n                    BaseTokenizer.call(this, input_string, options);\n                    this._current_tag_name = \"\";\n                    // Words end at whitespace or when a tag starts\n                    // if we are indenting handlebars, they are considered tags\n                    var templatable_reader = new TemplatablePattern(this._input).read_options(this._options);\n                    var pattern_reader = new Pattern(this._input);\n                    this.__patterns = {\n                        word: templatable_reader.until(/[\\n\\r\\t <]/),\n                        word_control_flow_close_excluded: templatable_reader.until(/[\\n\\r\\t <}]/),\n                        single_quote: templatable_reader.until_after(/'/),\n                        double_quote: templatable_reader.until_after(/\"/),\n                        attribute: templatable_reader.until(/[\\n\\r\\t =>]|\\/>/),\n                        element_name: templatable_reader.until(/[\\n\\r\\t >\\/]/),\n                        angular_control_flow_start: pattern_reader.matching(/\\@[a-zA-Z]+[^({]*[({]/),\n                        handlebars_comment: pattern_reader.starting_with(/{{!--/).until_after(/--}}/),\n                        handlebars: pattern_reader.starting_with(/{{/).until_after(/}}/),\n                        handlebars_open: pattern_reader.until(/[\\n\\r\\t }]/),\n                        handlebars_raw_close: pattern_reader.until(/}}/),\n                        comment: pattern_reader.starting_with(/<!--/).until_after(/-->/),\n                        cdata: pattern_reader.starting_with(/<!\\[CDATA\\[/).until_after(/]]>/),\n                        // https://en.wikipedia.org/wiki/Conditional_comment\n                        conditional_comment: pattern_reader.starting_with(/<!\\[/).until_after(/]>/),\n                        processing: pattern_reader.starting_with(/<\\?/).until_after(/\\?>/)\n                    };\n                    if (this._options.indent_handlebars) {\n                        this.__patterns.word = this.__patterns.word.exclude(\"handlebars\");\n                        this.__patterns.word_control_flow_close_excluded = this.__patterns.word_control_flow_close_excluded.exclude(\"handlebars\");\n                    }\n                    this._unformatted_content_delimiter = null;\n                    if (this._options.unformatted_content_delimiter) {\n                        var literal_regexp = this._input.get_literal_regexp(this._options.unformatted_content_delimiter);\n                        this.__patterns.unformatted_content_delimiter = pattern_reader.matching(literal_regexp).until_after(literal_regexp);\n                    }\n                };\n                Tokenizer.prototype = new BaseTokenizer();\n                Tokenizer.prototype._is_comment = function(current_token) {\n                    return false; //current_token.type === TOKEN.COMMENT || current_token.type === TOKEN.UNKNOWN;\n                };\n                Tokenizer.prototype._is_opening = function(current_token) {\n                    return current_token.type === TOKEN.TAG_OPEN || current_token.type === TOKEN.CONTROL_FLOW_OPEN;\n                };\n                Tokenizer.prototype._is_closing = function(current_token, open_token) {\n                    return current_token.type === TOKEN.TAG_CLOSE && open_token && ((current_token.text === \">\" || current_token.text === \"/>\") && open_token.text[0] === \"<\" || current_token.text === \"}}\" && open_token.text[0] === \"{\" && open_token.text[1] === \"{\") || current_token.type === TOKEN.CONTROL_FLOW_CLOSE && current_token.text === \"}\" && open_token.text.endsWith(\"{\");\n                };\n                Tokenizer.prototype._reset = function() {\n                    this._current_tag_name = \"\";\n                };\n                Tokenizer.prototype._get_next_token = function(previous_token, open_token) {\n                    var token = null;\n                    this._readWhitespace();\n                    var c = this._input.peek();\n                    if (c === null) {\n                        return this._create_token(TOKEN.EOF, \"\");\n                    }\n                    token = token || this._read_open_handlebars(c, open_token);\n                    token = token || this._read_attribute(c, previous_token, open_token);\n                    token = token || this._read_close(c, open_token);\n                    token = token || this._read_control_flows(c, open_token);\n                    token = token || this._read_raw_content(c, previous_token, open_token);\n                    token = token || this._read_content_word(c, open_token);\n                    token = token || this._read_comment_or_cdata(c);\n                    token = token || this._read_processing(c);\n                    token = token || this._read_open(c, open_token);\n                    token = token || this._create_token(TOKEN.UNKNOWN, this._input.next());\n                    return token;\n                };\n                Tokenizer.prototype._read_comment_or_cdata = function(c) {\n                    var token = null;\n                    var resulting_string = null;\n                    var directives = null;\n                    if (c === \"<\") {\n                        var peek1 = this._input.peek(1);\n                        // We treat all comments as literals, even more than preformatted tags\n                        // we only look for the appropriate closing marker\n                        if (peek1 === \"!\") {\n                            resulting_string = this.__patterns.comment.read();\n                            // only process directive on html comments\n                            if (resulting_string) {\n                                directives = directives_core.get_directives(resulting_string);\n                                if (directives && directives.ignore === \"start\") {\n                                    resulting_string += directives_core.readIgnored(this._input);\n                                }\n                            } else {\n                                resulting_string = this.__patterns.cdata.read();\n                            }\n                        }\n                        if (resulting_string) {\n                            token = this._create_token(TOKEN.COMMENT, resulting_string);\n                            token.directives = directives;\n                        }\n                    }\n                    return token;\n                };\n                Tokenizer.prototype._read_processing = function(c) {\n                    var token = null;\n                    var resulting_string = null;\n                    var directives = null;\n                    if (c === \"<\") {\n                        var peek1 = this._input.peek(1);\n                        if (peek1 === \"!\" || peek1 === \"?\") {\n                            resulting_string = this.__patterns.conditional_comment.read();\n                            resulting_string = resulting_string || this.__patterns.processing.read();\n                        }\n                        if (resulting_string) {\n                            token = this._create_token(TOKEN.COMMENT, resulting_string);\n                            token.directives = directives;\n                        }\n                    }\n                    return token;\n                };\n                Tokenizer.prototype._read_open = function(c, open_token) {\n                    var resulting_string = null;\n                    var token = null;\n                    if (!open_token || open_token.type === TOKEN.CONTROL_FLOW_OPEN) {\n                        if (c === \"<\") {\n                            resulting_string = this._input.next();\n                            if (this._input.peek() === \"/\") {\n                                resulting_string += this._input.next();\n                            }\n                            resulting_string += this.__patterns.element_name.read();\n                            token = this._create_token(TOKEN.TAG_OPEN, resulting_string);\n                        }\n                    }\n                    return token;\n                };\n                Tokenizer.prototype._read_open_handlebars = function(c, open_token) {\n                    var resulting_string = null;\n                    var token = null;\n                    if (!open_token || open_token.type === TOKEN.CONTROL_FLOW_OPEN) {\n                        if (this._options.indent_handlebars && c === \"{\" && this._input.peek(1) === \"{\") {\n                            if (this._input.peek(2) === \"!\") {\n                                resulting_string = this.__patterns.handlebars_comment.read();\n                                resulting_string = resulting_string || this.__patterns.handlebars.read();\n                                token = this._create_token(TOKEN.COMMENT, resulting_string);\n                            } else {\n                                resulting_string = this.__patterns.handlebars_open.read();\n                                token = this._create_token(TOKEN.TAG_OPEN, resulting_string);\n                            }\n                        }\n                    }\n                    return token;\n                };\n                Tokenizer.prototype._read_control_flows = function(c, open_token) {\n                    var resulting_string = \"\";\n                    var token = null;\n                    // Only check for control flows if angular templating is set AND indenting is set\n                    if (!this._options.templating.includes(\"angular\") || !this._options.indent_handlebars) {\n                        return token;\n                    }\n                    if (c === \"@\") {\n                        resulting_string = this.__patterns.angular_control_flow_start.read();\n                        if (resulting_string === \"\") {\n                            return token;\n                        }\n                        var opening_parentheses_count = resulting_string.endsWith(\"(\") ? 1 : 0;\n                        var closing_parentheses_count = 0;\n                        // The opening brace of the control flow is where the number of opening and closing parentheses equal\n                        // e.g. @if({value: true} !== null) { \n                        while(!(resulting_string.endsWith(\"{\") && opening_parentheses_count === closing_parentheses_count)){\n                            var next_char = this._input.next();\n                            if (next_char === null) {\n                                break;\n                            } else if (next_char === \"(\") {\n                                opening_parentheses_count++;\n                            } else if (next_char === \")\") {\n                                closing_parentheses_count++;\n                            }\n                            resulting_string += next_char;\n                        }\n                        token = this._create_token(TOKEN.CONTROL_FLOW_OPEN, resulting_string);\n                    } else if (c === \"}\" && open_token && open_token.type === TOKEN.CONTROL_FLOW_OPEN) {\n                        resulting_string = this._input.next();\n                        token = this._create_token(TOKEN.CONTROL_FLOW_CLOSE, resulting_string);\n                    }\n                    return token;\n                };\n                Tokenizer.prototype._read_close = function(c, open_token) {\n                    var resulting_string = null;\n                    var token = null;\n                    if (open_token && open_token.type === TOKEN.TAG_OPEN) {\n                        if (open_token.text[0] === \"<\" && (c === \">\" || c === \"/\" && this._input.peek(1) === \">\")) {\n                            resulting_string = this._input.next();\n                            if (c === \"/\") {\n                                resulting_string += this._input.next();\n                            }\n                            token = this._create_token(TOKEN.TAG_CLOSE, resulting_string);\n                        } else if (open_token.text[0] === \"{\" && c === \"}\" && this._input.peek(1) === \"}\") {\n                            this._input.next();\n                            this._input.next();\n                            token = this._create_token(TOKEN.TAG_CLOSE, \"}}\");\n                        }\n                    }\n                    return token;\n                };\n                Tokenizer.prototype._read_attribute = function(c, previous_token, open_token) {\n                    var token = null;\n                    var resulting_string = \"\";\n                    if (open_token && open_token.text[0] === \"<\") {\n                        if (c === \"=\") {\n                            token = this._create_token(TOKEN.EQUALS, this._input.next());\n                        } else if (c === '\"' || c === \"'\") {\n                            var content = this._input.next();\n                            if (c === '\"') {\n                                content += this.__patterns.double_quote.read();\n                            } else {\n                                content += this.__patterns.single_quote.read();\n                            }\n                            token = this._create_token(TOKEN.VALUE, content);\n                        } else {\n                            resulting_string = this.__patterns.attribute.read();\n                            if (resulting_string) {\n                                if (previous_token.type === TOKEN.EQUALS) {\n                                    token = this._create_token(TOKEN.VALUE, resulting_string);\n                                } else {\n                                    token = this._create_token(TOKEN.ATTRIBUTE, resulting_string);\n                                }\n                            }\n                        }\n                    }\n                    return token;\n                };\n                Tokenizer.prototype._is_content_unformatted = function(tag_name) {\n                    // void_elements have no content and so cannot have unformatted content\n                    // script and style tags should always be read as unformatted content\n                    // finally content_unformatted and unformatted element contents are unformatted\n                    return this._options.void_elements.indexOf(tag_name) === -1 && (this._options.content_unformatted.indexOf(tag_name) !== -1 || this._options.unformatted.indexOf(tag_name) !== -1);\n                };\n                Tokenizer.prototype._read_raw_content = function(c, previous_token, open_token) {\n                    var resulting_string = \"\";\n                    if (open_token && open_token.text[0] === \"{\") {\n                        resulting_string = this.__patterns.handlebars_raw_close.read();\n                    } else if (previous_token.type === TOKEN.TAG_CLOSE && previous_token.opened.text[0] === \"<\" && previous_token.text[0] !== \"/\") {\n                        // ^^ empty tag has no content \n                        var tag_name = previous_token.opened.text.substr(1).toLowerCase();\n                        if (tag_name === \"script\" || tag_name === \"style\") {\n                            // Script and style tags are allowed to have comments wrapping their content\n                            // or just have regular content.\n                            var token = this._read_comment_or_cdata(c);\n                            if (token) {\n                                token.type = TOKEN.TEXT;\n                                return token;\n                            }\n                            resulting_string = this._input.readUntil(new RegExp(\"</\" + tag_name + \"[\\\\n\\\\r\\\\t ]*?>\", \"ig\"));\n                        } else if (this._is_content_unformatted(tag_name)) {\n                            resulting_string = this._input.readUntil(new RegExp(\"</\" + tag_name + \"[\\\\n\\\\r\\\\t ]*?>\", \"ig\"));\n                        }\n                    }\n                    if (resulting_string) {\n                        return this._create_token(TOKEN.TEXT, resulting_string);\n                    }\n                    return null;\n                };\n                Tokenizer.prototype._read_content_word = function(c, open_token) {\n                    var resulting_string = \"\";\n                    if (this._options.unformatted_content_delimiter) {\n                        if (c === this._options.unformatted_content_delimiter[0]) {\n                            resulting_string = this.__patterns.unformatted_content_delimiter.read();\n                        }\n                    }\n                    if (!resulting_string) {\n                        resulting_string = open_token && open_token.type === TOKEN.CONTROL_FLOW_OPEN ? this.__patterns.word_control_flow_close_excluded.read() : this.__patterns.word.read();\n                    }\n                    if (resulting_string) {\n                        return this._create_token(TOKEN.TEXT, resulting_string);\n                    }\n                };\n                module.exports.Tokenizer = Tokenizer;\n                module.exports.TOKEN = TOKEN;\n            /***/ }\n        ];\n        /************************************************************************/ /******/ // The module cache\n        /******/ var __webpack_module_cache__ = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_153612__(moduleId) {\n            /******/ // Check if module is in cache\n            /******/ var cachedModule = __webpack_module_cache__[moduleId];\n            /******/ if (cachedModule !== undefined) {\n                /******/ return cachedModule.exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module = __webpack_module_cache__[moduleId] = {\n                /******/ // no module.id needed\n                /******/ // no module.loaded needed\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ __webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_153612__);\n            /******/ /******/ // Return the exports of the module\n            /******/ return module.exports;\n        /******/ }\n        /******/ /************************************************************************/ /******/ /******/ // startup\n        /******/ // Load entry module and return exports\n        /******/ // This entry module is referenced by other modules so it can't be inlined\n        /******/ var __nested_webpack_exports__ = __nested_webpack_require_153612__(18);\n        /******/ legacy_beautify_html = __nested_webpack_exports__;\n    /******/ /******/ })();\n    var style_html = legacy_beautify_html;\n    /* Footer */ if (true) {\n        // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n            __webpack_require__,\n            __webpack_require__(/*! ./beautify */ \"(rsc)/./node_modules/js-beautify/js/lib/beautify.js\"),\n            __webpack_require__(/*! ./beautify-css */ \"(rsc)/./node_modules/js-beautify/js/lib/beautify-css.js\")\n        ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(requireamd) {\n            var js_beautify = __webpack_require__(/*! ./beautify */ \"(rsc)/./node_modules/js-beautify/js/lib/beautify.js\");\n            var css_beautify = __webpack_require__(/*! ./beautify-css */ \"(rsc)/./node_modules/js-beautify/js/lib/beautify-css.js\");\n            return {\n                html_beautify: function(html_source, options) {\n                    return style_html(html_source, options, js_beautify.js_beautify, css_beautify.css_beautify);\n                }\n            };\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else { var css_beautify, js_beautify; }\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanMtYmVhdXRpZnkvanMvbGliL2JlYXV0aWZ5LWh0bWwuanMiLCJtYXBwaW5ncyI6IkFBQUEsa0dBQWtDLEdBQ2xDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVFQSxHQUVDO0lBRUQsMEJBQTBCLEdBQzFCLElBQUlBO0lBQ0osTUFBTSxHQUFJO1FBQ1YsTUFBTSxHQUFJO1FBQ1YsTUFBTSxHQUFJLElBQUlDLHNCQUF1Qjs7O1lBR3JDLEtBQUssR0FDTCxHQUFHLEdBQUksU0FBU0MsTUFBTTtnQkFFdEIsbUJBQW1CLEdBQ25COzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3QkEsR0FJQSxTQUFTQyxXQUFXQyxNQUFNO29CQUN4QixJQUFJLENBQUNDLFFBQVEsR0FBR0Q7b0JBQ2hCLElBQUksQ0FBQ0UsaUJBQWlCLEdBQUc7b0JBQ3pCLGdGQUFnRjtvQkFDaEYsSUFBSSxDQUFDQyxjQUFjLEdBQUcsQ0FBQztvQkFDdkIsSUFBSSxDQUFDQyxpQkFBaUIsR0FBRztvQkFDekIsSUFBSSxDQUFDQyxrQkFBa0IsR0FBRztvQkFDMUIsSUFBSSxDQUFDQyw0QkFBNEIsR0FBRztvQkFDcEMsSUFBSSxDQUFDQyx5QkFBeUIsR0FBRyxDQUFDO29CQUNsQyxJQUFJLENBQUNDLDRCQUE0QixHQUFHO29CQUVwQyxJQUFJLENBQUNDLE9BQU8sR0FBRyxFQUFFO2dCQUNuQjtnQkFFQVYsV0FBV1csU0FBUyxDQUFDQyxXQUFXLEdBQUc7b0JBQ2pDLElBQUlDLE9BQU8sSUFBSWIsV0FBVyxJQUFJLENBQUNFLFFBQVE7b0JBQ3ZDVyxLQUFLQyxVQUFVLENBQUMsSUFBSSxDQUFDVixjQUFjLEVBQUUsSUFBSSxDQUFDQyxpQkFBaUI7b0JBQzNELE9BQU9RO2dCQUNUO2dCQUVBYixXQUFXVyxTQUFTLENBQUNJLElBQUksR0FBRyxTQUFTQyxLQUFLO29CQUN4QyxJQUFJ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QUNwQixNQUFNLEdBQUksdUNBQXVDO1FBQ2pELE1BQU0sR0FBSSwwRUFBMEU7UUFDcEYsTUFBTSxHQUFJLElBQUk4VywwQkFBbUJBLEdBQUczUixpQ0FBbUJBLENBQUM7UUFDeEQsTUFBTSxHQUFJaE0sdUJBQXVCMmQsMEJBQW1CQTtJQUNwRCxNQUFNLEdBQ04sTUFBTSxHQUFHO0lBRVQsSUFBSXhMLGFBQWFuUztJQUNqQixVQUFVLEdBQ1YsSUFBSSxJQUEwQyxFQUFFO1FBQzVDLDBGQUEwRjtRQUMxRjRkLGlDQUFPO1lBQUMsbUJBQVM7WUFBRSw0RkFBWTtZQUFFLG9HQUFnQjtTQUFDLG1DQUFFLFNBQVNFLFVBQVU7WUFDbkUsSUFBSXpMLGNBQWN5TCxtQkFBVUEsQ0FBQyx1RUFBWTtZQUN6QyxJQUFJeEwsZUFBZXdMLG1CQUFVQSxDQUFDLCtFQUFnQjtZQUU5QyxPQUFPO2dCQUNIQyxlQUFlLFNBQVMzTCxXQUFXLEVBQUU5TyxPQUFPO29CQUN4QyxPQUFPNk8sV0FBV0MsYUFBYTlPLFNBQVMrTyxZQUFZQSxXQUFXLEVBQUVDLGFBQWFBLFlBQVk7Z0JBQzlGO1lBQ0o7UUFDSixDQUFDO0FBQUEsa0dBQUM7SUFDTixPQUFPLGtDQW1CTjtBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWJjbGVhbnMvLi9ub2RlX21vZHVsZXMvanMtYmVhdXRpZnkvanMvbGliL2JlYXV0aWZ5LWh0bWwuanM/ODEyMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBBVVRPLUdFTkVSQVRFRC4gRE8gTk9UIE1PRElGWS4gKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuXG5cbiBTdHlsZSBIVE1MXG4tLS0tLS0tLS0tLS0tLS1cblxuICBXcml0dGVuIGJ5IE5vY2h1bSBTb3Nzb25rbywgKG5zb3Nzb25rb0Bob3RtYWlsLmNvbSlcblxuICBCYXNlZCBvbiBjb2RlIGluaXRpYWxseSBkZXZlbG9wZWQgYnk6IEVpbmFyIExpZWxtYW5pcywgPGVpbmFyQGJlYXV0aWZpZXIuaW8+XG4gICAgaHR0cHM6Ly9iZWF1dGlmaWVyLmlvL1xuXG4gIFVzYWdlOlxuICAgIHN0eWxlX2h0bWwoaHRtbF9zb3VyY2UpO1xuXG4gICAgc3R5bGVfaHRtbChodG1sX3NvdXJjZSwgb3B0aW9ucyk7XG5cbiAgVGhlIG9wdGlvbnMgYXJlOlxuICAgIGluZGVudF9pbm5lcl9odG1sIChkZWZhdWx0IGZhbHNlKSAg4oCUIGluZGVudCA8aGVhZD4gYW5kIDxib2R5PiBzZWN0aW9ucyxcbiAgICBpbmRlbnRfc2l6ZSAoZGVmYXVsdCA0KSAgICAgICAgICDigJQgaW5kZW50YXRpb24gc2l6ZSxcbiAgICBpbmRlbnRfY2hhciAoZGVmYXVsdCBzcGFjZSkgICAgICDigJQgY2hhcmFjdGVyIHRvIGluZGVudCB3aXRoLFxuICAgIHdyYXBfbGluZV9sZW5ndGggKGRlZmF1bHQgMjUwKSAgICAgICAgICAgIC0gIG1heGltdW0gYW1vdW50IG9mIGNoYXJhY3RlcnMgcGVyIGxpbmUgKDAgPSBkaXNhYmxlKVxuICAgIGJyYWNlX3N0eWxlIChkZWZhdWx0IFwiY29sbGFwc2VcIikgLSBcImNvbGxhcHNlXCIgfCBcImV4cGFuZFwiIHwgXCJlbmQtZXhwYW5kXCIgfCBcIm5vbmVcIlxuICAgICAgICAgICAgcHV0IGJyYWNlcyBvbiB0aGUgc2FtZSBsaW5lIGFzIGNvbnRyb2wgc3RhdGVtZW50cyAoZGVmYXVsdCksIG9yIHB1dCBicmFjZXMgb24gb3duIGxpbmUgKEFsbG1hbiAvIEFOU0kgc3R5bGUpLCBvciBqdXN0IHB1dCBlbmQgYnJhY2VzIG9uIG93biBsaW5lLCBvciBhdHRlbXB0IHRvIGtlZXAgdGhlbSB3aGVyZSB0aGV5IGFyZS5cbiAgICBpbmxpbmUgKGRlZmF1bHRzIHRvIGlubGluZSB0YWdzKSAtIGxpc3Qgb2YgdGFncyB0byBiZSBjb25zaWRlcmVkIGlubGluZSB0YWdzXG4gICAgdW5mb3JtYXR0ZWQgKGRlZmF1bHRzIHRvIGlubGluZSB0YWdzKSAtIGxpc3Qgb2YgdGFncywgdGhhdCBzaG91bGRuJ3QgYmUgcmVmb3JtYXR0ZWRcbiAgICBjb250ZW50X3VuZm9ybWF0dGVkIChkZWZhdWx0cyB0byBbXCJwcmVcIiwgXCJ0ZXh0YXJlYVwiXSB0YWdzKSAtIGxpc3Qgb2YgdGFncywgd2hvc2UgY29udGVudCBzaG91bGRuJ3QgYmUgcmVmb3JtYXR0ZWRcbiAgICBpbmRlbnRfc2NyaXB0cyAoZGVmYXVsdCBub3JtYWwpICAtIFwia2VlcFwifFwic2VwYXJhdGVcInxcIm5vcm1hbFwiXG4gICAgcHJlc2VydmVfbmV3bGluZXMgKGRlZmF1bHQgdHJ1ZSkgLSB3aGV0aGVyIGV4aXN0aW5nIGxpbmUgYnJlYWtzIGJlZm9yZSBlbGVtZW50cyBzaG91bGQgYmUgcHJlc2VydmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT25seSB3b3JrcyBiZWZvcmUgZWxlbWVudHMsIG5vdCBpbnNpZGUgdGFncyBvciBmb3IgdGV4dC5cbiAgICBtYXhfcHJlc2VydmVfbmV3bGluZXMgKGRlZmF1bHQgdW5saW1pdGVkKSAtIG1heGltdW0gbnVtYmVyIG9mIGxpbmUgYnJlYWtzIHRvIGJlIHByZXNlcnZlZCBpbiBvbmUgY2h1bmtcbiAgICBpbmRlbnRfaGFuZGxlYmFycyAoZGVmYXVsdCBmYWxzZSkgLSBmb3JtYXQgYW5kIGluZGVudCB7eyNmb299fSBhbmQge3svZm9vfX1cbiAgICBlbmRfd2l0aF9uZXdsaW5lIChmYWxzZSkgICAgICAgICAgLSBlbmQgd2l0aCBhIG5ld2xpbmVcbiAgICBleHRyYV9saW5lcnMgKGRlZmF1bHQgW2hlYWQsYm9keSwvaHRtbF0pIC1MaXN0IG9mIHRhZ3MgdGhhdCBzaG91bGQgaGF2ZSBhbiBleHRyYSBuZXdsaW5lIGJlZm9yZSB0aGVtLlxuXG4gICAgZS5nLlxuXG4gICAgc3R5bGVfaHRtbChodG1sX3NvdXJjZSwge1xuICAgICAgJ2luZGVudF9pbm5lcl9odG1sJzogZmFsc2UsXG4gICAgICAnaW5kZW50X3NpemUnOiAyLFxuICAgICAgJ2luZGVudF9jaGFyJzogJyAnLFxuICAgICAgJ3dyYXBfbGluZV9sZW5ndGgnOiA3OCxcbiAgICAgICdicmFjZV9zdHlsZSc6ICdleHBhbmQnLFxuICAgICAgJ3ByZXNlcnZlX25ld2xpbmVzJzogdHJ1ZSxcbiAgICAgICdtYXhfcHJlc2VydmVfbmV3bGluZXMnOiA1LFxuICAgICAgJ2luZGVudF9oYW5kbGViYXJzJzogZmFsc2UsXG4gICAgICAnZXh0cmFfbGluZXJzJzogWycvaHRtbCddXG4gICAgfSk7XG4qL1xuXG4oZnVuY3Rpb24oKSB7XG5cbi8qIEdFTkVSQVRFRF9CVUlMRF9PVVRQVVQgKi9cbnZhciBsZWdhY3lfYmVhdXRpZnlfaHRtbDtcbi8qKioqKiovIChmdW5jdGlvbigpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHRcInVzZSBzdHJpY3RcIjtcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoW1xuLyogMCAqLyxcbi8qIDEgKi8sXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbmZ1bmN0aW9uIE91dHB1dExpbmUocGFyZW50KSB7XG4gIHRoaXMuX19wYXJlbnQgPSBwYXJlbnQ7XG4gIHRoaXMuX19jaGFyYWN0ZXJfY291bnQgPSAwO1xuICAvLyB1c2UgaW5kZW50X2NvdW50IGFzIGEgbWFya2VyIGZvciB0aGlzLl9fbGluZXMgdGhhdCBoYXZlIHByZXNlcnZlZCBpbmRlbnRhdGlvblxuICB0aGlzLl9faW5kZW50X2NvdW50ID0gLTE7XG4gIHRoaXMuX19hbGlnbm1lbnRfY291bnQgPSAwO1xuICB0aGlzLl9fd3JhcF9wb2ludF9pbmRleCA9IDA7XG4gIHRoaXMuX193cmFwX3BvaW50X2NoYXJhY3Rlcl9jb3VudCA9IDA7XG4gIHRoaXMuX193cmFwX3BvaW50X2luZGVudF9jb3VudCA9IC0xO1xuICB0aGlzLl9fd3JhcF9wb2ludF9hbGlnbm1lbnRfY291bnQgPSAwO1xuXG4gIHRoaXMuX19pdGVtcyA9IFtdO1xufVxuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5jbG9uZV9lbXB0eSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbGluZSA9IG5ldyBPdXRwdXRMaW5lKHRoaXMuX19wYXJlbnQpO1xuICBsaW5lLnNldF9pbmRlbnQodGhpcy5fX2luZGVudF9jb3VudCwgdGhpcy5fX2FsaWdubWVudF9jb3VudCk7XG4gIHJldHVybiBsaW5lO1xufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUuaXRlbSA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gdGhpcy5fX2l0ZW1zW3RoaXMuX19pdGVtcy5sZW5ndGggKyBpbmRleF07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMuX19pdGVtc1tpbmRleF07XG4gIH1cbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLmhhc19tYXRjaCA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgZm9yICh2YXIgbGFzdENoZWNrZWRPdXRwdXQgPSB0aGlzLl9faXRlbXMubGVuZ3RoIC0gMTsgbGFzdENoZWNrZWRPdXRwdXQgPj0gMDsgbGFzdENoZWNrZWRPdXRwdXQtLSkge1xuICAgIGlmICh0aGlzLl9faXRlbXNbbGFzdENoZWNrZWRPdXRwdXRdLm1hdGNoKHBhdHRlcm4pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUuc2V0X2luZGVudCA9IGZ1bmN0aW9uKGluZGVudCwgYWxpZ25tZW50KSB7XG4gIGlmICh0aGlzLmlzX2VtcHR5KCkpIHtcbiAgICB0aGlzLl9faW5kZW50X2NvdW50ID0gaW5kZW50IHx8IDA7XG4gICAgdGhpcy5fX2FsaWdubWVudF9jb3VudCA9IGFsaWdubWVudCB8fCAwO1xuICAgIHRoaXMuX19jaGFyYWN0ZXJfY291bnQgPSB0aGlzLl9fcGFyZW50LmdldF9pbmRlbnRfc2l6ZSh0aGlzLl9faW5kZW50X2NvdW50LCB0aGlzLl9fYWxpZ25tZW50X2NvdW50KTtcbiAgfVxufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUuX3NldF93cmFwX3BvaW50ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9fcGFyZW50LndyYXBfbGluZV9sZW5ndGgpIHtcbiAgICB0aGlzLl9fd3JhcF9wb2ludF9pbmRleCA9IHRoaXMuX19pdGVtcy5sZW5ndGg7XG4gICAgdGhpcy5fX3dyYXBfcG9pbnRfY2hhcmFjdGVyX2NvdW50ID0gdGhpcy5fX2NoYXJhY3Rlcl9jb3VudDtcbiAgICB0aGlzLl9fd3JhcF9wb2ludF9pbmRlbnRfY291bnQgPSB0aGlzLl9fcGFyZW50Lm5leHRfbGluZS5fX2luZGVudF9jb3VudDtcbiAgICB0aGlzLl9fd3JhcF9wb2ludF9hbGlnbm1lbnRfY291bnQgPSB0aGlzLl9fcGFyZW50Lm5leHRfbGluZS5fX2FsaWdubWVudF9jb3VudDtcbiAgfVxufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUuX3Nob3VsZF93cmFwID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9fd3JhcF9wb2ludF9pbmRleCAmJlxuICAgIHRoaXMuX19jaGFyYWN0ZXJfY291bnQgPiB0aGlzLl9fcGFyZW50LndyYXBfbGluZV9sZW5ndGggJiZcbiAgICB0aGlzLl9fd3JhcF9wb2ludF9jaGFyYWN0ZXJfY291bnQgPiB0aGlzLl9fcGFyZW50Lm5leHRfbGluZS5fX2NoYXJhY3Rlcl9jb3VudDtcbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLl9hbGxvd193cmFwID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9zaG91bGRfd3JhcCgpKSB7XG4gICAgdGhpcy5fX3BhcmVudC5hZGRfbmV3X2xpbmUoKTtcbiAgICB2YXIgbmV4dCA9IHRoaXMuX19wYXJlbnQuY3VycmVudF9saW5lO1xuICAgIG5leHQuc2V0X2luZGVudCh0aGlzLl9fd3JhcF9wb2ludF9pbmRlbnRfY291bnQsIHRoaXMuX193cmFwX3BvaW50X2FsaWdubWVudF9jb3VudCk7XG4gICAgbmV4dC5fX2l0ZW1zID0gdGhpcy5fX2l0ZW1zLnNsaWNlKHRoaXMuX193cmFwX3BvaW50X2luZGV4KTtcbiAgICB0aGlzLl9faXRlbXMgPSB0aGlzLl9faXRlbXMuc2xpY2UoMCwgdGhpcy5fX3dyYXBfcG9pbnRfaW5kZXgpO1xuXG4gICAgbmV4dC5fX2NoYXJhY3Rlcl9jb3VudCArPSB0aGlzLl9fY2hhcmFjdGVyX2NvdW50IC0gdGhpcy5fX3dyYXBfcG9pbnRfY2hhcmFjdGVyX2NvdW50O1xuICAgIHRoaXMuX19jaGFyYWN0ZXJfY291bnQgPSB0aGlzLl9fd3JhcF9wb2ludF9jaGFyYWN0ZXJfY291bnQ7XG5cbiAgICBpZiAobmV4dC5fX2l0ZW1zWzBdID09PSBcIiBcIikge1xuICAgICAgbmV4dC5fX2l0ZW1zLnNwbGljZSgwLCAxKTtcbiAgICAgIG5leHQuX19jaGFyYWN0ZXJfY291bnQgLT0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUuaXNfZW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX19pdGVtcy5sZW5ndGggPT09IDA7XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5sYXN0ID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5pc19lbXB0eSgpKSB7XG4gICAgcmV0dXJuIHRoaXMuX19pdGVtc1t0aGlzLl9faXRlbXMubGVuZ3RoIC0gMV07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihpdGVtKSB7XG4gIHRoaXMuX19pdGVtcy5wdXNoKGl0ZW0pO1xuICB2YXIgbGFzdF9uZXdsaW5lX2luZGV4ID0gaXRlbS5sYXN0SW5kZXhPZignXFxuJyk7XG4gIGlmIChsYXN0X25ld2xpbmVfaW5kZXggIT09IC0xKSB7XG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCA9IGl0ZW0ubGVuZ3RoIC0gbGFzdF9uZXdsaW5lX2luZGV4O1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX19jaGFyYWN0ZXJfY291bnQgKz0gaXRlbS5sZW5ndGg7XG4gIH1cbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaXRlbSA9IG51bGw7XG4gIGlmICghdGhpcy5pc19lbXB0eSgpKSB7XG4gICAgaXRlbSA9IHRoaXMuX19pdGVtcy5wb3AoKTtcbiAgICB0aGlzLl9fY2hhcmFjdGVyX2NvdW50IC09IGl0ZW0ubGVuZ3RoO1xuICB9XG4gIHJldHVybiBpdGVtO1xufTtcblxuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5fcmVtb3ZlX2luZGVudCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fX2luZGVudF9jb3VudCA+IDApIHtcbiAgICB0aGlzLl9faW5kZW50X2NvdW50IC09IDE7XG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCAtPSB0aGlzLl9fcGFyZW50LmluZGVudF9zaXplO1xuICB9XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5fcmVtb3ZlX3dyYXBfaW5kZW50ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9fd3JhcF9wb2ludF9pbmRlbnRfY291bnQgPiAwKSB7XG4gICAgdGhpcy5fX3dyYXBfcG9pbnRfaW5kZW50X2NvdW50IC09IDE7XG4gIH1cbn07XG5PdXRwdXRMaW5lLnByb3RvdHlwZS50cmltID0gZnVuY3Rpb24oKSB7XG4gIHdoaWxlICh0aGlzLmxhc3QoKSA9PT0gJyAnKSB7XG4gICAgdGhpcy5fX2l0ZW1zLnBvcCgpO1xuICAgIHRoaXMuX19jaGFyYWN0ZXJfY291bnQgLT0gMTtcbiAgfVxufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBpZiAodGhpcy5pc19lbXB0eSgpKSB7XG4gICAgaWYgKHRoaXMuX19wYXJlbnQuaW5kZW50X2VtcHR5X2xpbmVzKSB7XG4gICAgICByZXN1bHQgPSB0aGlzLl9fcGFyZW50LmdldF9pbmRlbnRfc3RyaW5nKHRoaXMuX19pbmRlbnRfY291bnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSB0aGlzLl9fcGFyZW50LmdldF9pbmRlbnRfc3RyaW5nKHRoaXMuX19pbmRlbnRfY291bnQsIHRoaXMuX19hbGlnbm1lbnRfY291bnQpO1xuICAgIHJlc3VsdCArPSB0aGlzLl9faXRlbXMuam9pbignJyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmZ1bmN0aW9uIEluZGVudFN0cmluZ0NhY2hlKG9wdGlvbnMsIGJhc2VJbmRlbnRTdHJpbmcpIHtcbiAgdGhpcy5fX2NhY2hlID0gWycnXTtcbiAgdGhpcy5fX2luZGVudF9zaXplID0gb3B0aW9ucy5pbmRlbnRfc2l6ZTtcbiAgdGhpcy5fX2luZGVudF9zdHJpbmcgPSBvcHRpb25zLmluZGVudF9jaGFyO1xuICBpZiAoIW9wdGlvbnMuaW5kZW50X3dpdGhfdGFicykge1xuICAgIHRoaXMuX19pbmRlbnRfc3RyaW5nID0gbmV3IEFycmF5KG9wdGlvbnMuaW5kZW50X3NpemUgKyAxKS5qb2luKG9wdGlvbnMuaW5kZW50X2NoYXIpO1xuICB9XG5cbiAgLy8gU2V0IHRvIG51bGwgdG8gY29udGludWUgc3VwcG9ydCBmb3IgYXV0byBkZXRlY3Rpb24gb2YgYmFzZSBpbmRlbnRcbiAgYmFzZUluZGVudFN0cmluZyA9IGJhc2VJbmRlbnRTdHJpbmcgfHwgJyc7XG4gIGlmIChvcHRpb25zLmluZGVudF9sZXZlbCA+IDApIHtcbiAgICBiYXNlSW5kZW50U3RyaW5nID0gbmV3IEFycmF5KG9wdGlvbnMuaW5kZW50X2xldmVsICsgMSkuam9pbih0aGlzLl9faW5kZW50X3N0cmluZyk7XG4gIH1cblxuICB0aGlzLl9fYmFzZV9zdHJpbmcgPSBiYXNlSW5kZW50U3RyaW5nO1xuICB0aGlzLl9fYmFzZV9zdHJpbmdfbGVuZ3RoID0gYmFzZUluZGVudFN0cmluZy5sZW5ndGg7XG59XG5cbkluZGVudFN0cmluZ0NhY2hlLnByb3RvdHlwZS5nZXRfaW5kZW50X3NpemUgPSBmdW5jdGlvbihpbmRlbnQsIGNvbHVtbikge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fX2Jhc2Vfc3RyaW5nX2xlbmd0aDtcbiAgY29sdW1uID0gY29sdW1uIHx8IDA7XG4gIGlmIChpbmRlbnQgPCAwKSB7XG4gICAgcmVzdWx0ID0gMDtcbiAgfVxuICByZXN1bHQgKz0gaW5kZW50ICogdGhpcy5fX2luZGVudF9zaXplO1xuICByZXN1bHQgKz0gY29sdW1uO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuSW5kZW50U3RyaW5nQ2FjaGUucHJvdG90eXBlLmdldF9pbmRlbnRfc3RyaW5nID0gZnVuY3Rpb24oaW5kZW50X2xldmVsLCBjb2x1bW4pIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuX19iYXNlX3N0cmluZztcbiAgY29sdW1uID0gY29sdW1uIHx8IDA7XG4gIGlmIChpbmRlbnRfbGV2ZWwgPCAwKSB7XG4gICAgaW5kZW50X2xldmVsID0gMDtcbiAgICByZXN1bHQgPSAnJztcbiAgfVxuICBjb2x1bW4gKz0gaW5kZW50X2xldmVsICogdGhpcy5fX2luZGVudF9zaXplO1xuICB0aGlzLl9fZW5zdXJlX2NhY2hlKGNvbHVtbik7XG4gIHJlc3VsdCArPSB0aGlzLl9fY2FjaGVbY29sdW1uXTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbkluZGVudFN0cmluZ0NhY2hlLnByb3RvdHlwZS5fX2Vuc3VyZV9jYWNoZSA9IGZ1bmN0aW9uKGNvbHVtbikge1xuICB3aGlsZSAoY29sdW1uID49IHRoaXMuX19jYWNoZS5sZW5ndGgpIHtcbiAgICB0aGlzLl9fYWRkX2NvbHVtbigpO1xuICB9XG59O1xuXG5JbmRlbnRTdHJpbmdDYWNoZS5wcm90b3R5cGUuX19hZGRfY29sdW1uID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjb2x1bW4gPSB0aGlzLl9fY2FjaGUubGVuZ3RoO1xuICB2YXIgaW5kZW50ID0gMDtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBpZiAodGhpcy5fX2luZGVudF9zaXplICYmIGNvbHVtbiA+PSB0aGlzLl9faW5kZW50X3NpemUpIHtcbiAgICBpbmRlbnQgPSBNYXRoLmZsb29yKGNvbHVtbiAvIHRoaXMuX19pbmRlbnRfc2l6ZSk7XG4gICAgY29sdW1uIC09IGluZGVudCAqIHRoaXMuX19pbmRlbnRfc2l6ZTtcbiAgICByZXN1bHQgPSBuZXcgQXJyYXkoaW5kZW50ICsgMSkuam9pbih0aGlzLl9faW5kZW50X3N0cmluZyk7XG4gIH1cbiAgaWYgKGNvbHVtbikge1xuICAgIHJlc3VsdCArPSBuZXcgQXJyYXkoY29sdW1uICsgMSkuam9pbignICcpO1xuICB9XG5cbiAgdGhpcy5fX2NhY2hlLnB1c2gocmVzdWx0KTtcbn07XG5cbmZ1bmN0aW9uIE91dHB1dChvcHRpb25zLCBiYXNlSW5kZW50U3RyaW5nKSB7XG4gIHRoaXMuX19pbmRlbnRfY2FjaGUgPSBuZXcgSW5kZW50U3RyaW5nQ2FjaGUob3B0aW9ucywgYmFzZUluZGVudFN0cmluZyk7XG4gIHRoaXMucmF3ID0gZmFsc2U7XG4gIHRoaXMuX2VuZF93aXRoX25ld2xpbmUgPSBvcHRpb25zLmVuZF93aXRoX25ld2xpbmU7XG4gIHRoaXMuaW5kZW50X3NpemUgPSBvcHRpb25zLmluZGVudF9zaXplO1xuICB0aGlzLndyYXBfbGluZV9sZW5ndGggPSBvcHRpb25zLndyYXBfbGluZV9sZW5ndGg7XG4gIHRoaXMuaW5kZW50X2VtcHR5X2xpbmVzID0gb3B0aW9ucy5pbmRlbnRfZW1wdHlfbGluZXM7XG4gIHRoaXMuX19saW5lcyA9IFtdO1xuICB0aGlzLnByZXZpb3VzX2xpbmUgPSBudWxsO1xuICB0aGlzLmN1cnJlbnRfbGluZSA9IG51bGw7XG4gIHRoaXMubmV4dF9saW5lID0gbmV3IE91dHB1dExpbmUodGhpcyk7XG4gIHRoaXMuc3BhY2VfYmVmb3JlX3Rva2VuID0gZmFsc2U7XG4gIHRoaXMubm9uX2JyZWFraW5nX3NwYWNlID0gZmFsc2U7XG4gIHRoaXMucHJldmlvdXNfdG9rZW5fd3JhcHBlZCA9IGZhbHNlO1xuICAvLyBpbml0aWFsaXplXG4gIHRoaXMuX19hZGRfb3V0cHV0bGluZSgpO1xufVxuXG5PdXRwdXQucHJvdG90eXBlLl9fYWRkX291dHB1dGxpbmUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5wcmV2aW91c19saW5lID0gdGhpcy5jdXJyZW50X2xpbmU7XG4gIHRoaXMuY3VycmVudF9saW5lID0gdGhpcy5uZXh0X2xpbmUuY2xvbmVfZW1wdHkoKTtcbiAgdGhpcy5fX2xpbmVzLnB1c2godGhpcy5jdXJyZW50X2xpbmUpO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5nZXRfbGluZV9udW1iZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX19saW5lcy5sZW5ndGg7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmdldF9pbmRlbnRfc3RyaW5nID0gZnVuY3Rpb24oaW5kZW50LCBjb2x1bW4pIHtcbiAgcmV0dXJuIHRoaXMuX19pbmRlbnRfY2FjaGUuZ2V0X2luZGVudF9zdHJpbmcoaW5kZW50LCBjb2x1bW4pO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5nZXRfaW5kZW50X3NpemUgPSBmdW5jdGlvbihpbmRlbnQsIGNvbHVtbikge1xuICByZXR1cm4gdGhpcy5fX2luZGVudF9jYWNoZS5nZXRfaW5kZW50X3NpemUoaW5kZW50LCBjb2x1bW4pO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5pc19lbXB0eSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gIXRoaXMucHJldmlvdXNfbGluZSAmJiB0aGlzLmN1cnJlbnRfbGluZS5pc19lbXB0eSgpO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5hZGRfbmV3X2xpbmUgPSBmdW5jdGlvbihmb3JjZV9uZXdsaW5lKSB7XG4gIC8vIG5ldmVyIG5ld2xpbmUgYXQgdGhlIHN0YXJ0IG9mIGZpbGVcbiAgLy8gb3RoZXJ3aXNlLCBuZXdsaW5lIG9ubHkgaWYgd2UgZGlkbid0IGp1c3QgYWRkIG9uZSBvciB3ZSdyZSBmb3JjZWRcbiAgaWYgKHRoaXMuaXNfZW1wdHkoKSB8fFxuICAgICghZm9yY2VfbmV3bGluZSAmJiB0aGlzLmp1c3RfYWRkZWRfbmV3bGluZSgpKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGlmIHJhdyBvdXRwdXQgaXMgZW5hYmxlZCwgZG9uJ3QgcHJpbnQgYWRkaXRpb25hbCBuZXdsaW5lcyxcbiAgLy8gYnV0IHN0aWxsIHJldHVybiBUcnVlIGFzIHRob3VnaCB5b3UgaGFkXG4gIGlmICghdGhpcy5yYXcpIHtcbiAgICB0aGlzLl9fYWRkX291dHB1dGxpbmUoKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuZ2V0X2NvZGUgPSBmdW5jdGlvbihlb2wpIHtcbiAgdGhpcy50cmltKHRydWUpO1xuXG4gIC8vIGhhbmRsZSBzb21lIGVkZ2UgY2FzZXMgd2hlcmUgdGhlIGxhc3QgdG9rZW5zXG4gIC8vIGhhcyB0ZXh0IHRoYXQgZW5kcyB3aXRoIG5ld2xpbmUocylcbiAgdmFyIGxhc3RfaXRlbSA9IHRoaXMuY3VycmVudF9saW5lLnBvcCgpO1xuICBpZiAobGFzdF9pdGVtKSB7XG4gICAgaWYgKGxhc3RfaXRlbVtsYXN0X2l0ZW0ubGVuZ3RoIC0gMV0gPT09ICdcXG4nKSB7XG4gICAgICBsYXN0X2l0ZW0gPSBsYXN0X2l0ZW0ucmVwbGFjZSgvXFxuKyQvZywgJycpO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRfbGluZS5wdXNoKGxhc3RfaXRlbSk7XG4gIH1cblxuICBpZiAodGhpcy5fZW5kX3dpdGhfbmV3bGluZSkge1xuICAgIHRoaXMuX19hZGRfb3V0cHV0bGluZSgpO1xuICB9XG5cbiAgdmFyIHN3ZWV0X2NvZGUgPSB0aGlzLl9fbGluZXMuam9pbignXFxuJyk7XG5cbiAgaWYgKGVvbCAhPT0gJ1xcbicpIHtcbiAgICBzd2VldF9jb2RlID0gc3dlZXRfY29kZS5yZXBsYWNlKC9bXFxuXS9nLCBlb2wpO1xuICB9XG4gIHJldHVybiBzd2VldF9jb2RlO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5zZXRfd3JhcF9wb2ludCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmN1cnJlbnRfbGluZS5fc2V0X3dyYXBfcG9pbnQoKTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuc2V0X2luZGVudCA9IGZ1bmN0aW9uKGluZGVudCwgYWxpZ25tZW50KSB7XG4gIGluZGVudCA9IGluZGVudCB8fCAwO1xuICBhbGlnbm1lbnQgPSBhbGlnbm1lbnQgfHwgMDtcblxuICAvLyBOZXh0IGxpbmUgc3RvcmVzIGFsaWdubWVudCB2YWx1ZXNcbiAgdGhpcy5uZXh0X2xpbmUuc2V0X2luZGVudChpbmRlbnQsIGFsaWdubWVudCk7XG5cbiAgLy8gTmV2ZXIgaW5kZW50IHlvdXIgZmlyc3Qgb3V0cHV0IGluZGVudCBhdCB0aGUgc3RhcnQgb2YgdGhlIGZpbGVcbiAgaWYgKHRoaXMuX19saW5lcy5sZW5ndGggPiAxKSB7XG4gICAgdGhpcy5jdXJyZW50X2xpbmUuc2V0X2luZGVudChpbmRlbnQsIGFsaWdubWVudCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB0aGlzLmN1cnJlbnRfbGluZS5zZXRfaW5kZW50KCk7XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuYWRkX3Jhd190b2tlbiA9IGZ1bmN0aW9uKHRva2VuKSB7XG4gIGZvciAodmFyIHggPSAwOyB4IDwgdG9rZW4ubmV3bGluZXM7IHgrKykge1xuICAgIHRoaXMuX19hZGRfb3V0cHV0bGluZSgpO1xuICB9XG4gIHRoaXMuY3VycmVudF9saW5lLnNldF9pbmRlbnQoLTEpO1xuICB0aGlzLmN1cnJlbnRfbGluZS5wdXNoKHRva2VuLndoaXRlc3BhY2VfYmVmb3JlKTtcbiAgdGhpcy5jdXJyZW50X2xpbmUucHVzaCh0b2tlbi50ZXh0KTtcbiAgdGhpcy5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcbiAgdGhpcy5ub25fYnJlYWtpbmdfc3BhY2UgPSBmYWxzZTtcbiAgdGhpcy5wcmV2aW91c190b2tlbl93cmFwcGVkID0gZmFsc2U7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmFkZF90b2tlbiA9IGZ1bmN0aW9uKHByaW50YWJsZV90b2tlbikge1xuICB0aGlzLl9fYWRkX3NwYWNlX2JlZm9yZV90b2tlbigpO1xuICB0aGlzLmN1cnJlbnRfbGluZS5wdXNoKHByaW50YWJsZV90b2tlbik7XG4gIHRoaXMuc3BhY2VfYmVmb3JlX3Rva2VuID0gZmFsc2U7XG4gIHRoaXMubm9uX2JyZWFraW5nX3NwYWNlID0gZmFsc2U7XG4gIHRoaXMucHJldmlvdXNfdG9rZW5fd3JhcHBlZCA9IHRoaXMuY3VycmVudF9saW5lLl9hbGxvd193cmFwKCk7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLl9fYWRkX3NwYWNlX2JlZm9yZV90b2tlbiA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5zcGFjZV9iZWZvcmVfdG9rZW4gJiYgIXRoaXMuanVzdF9hZGRlZF9uZXdsaW5lKCkpIHtcbiAgICBpZiAoIXRoaXMubm9uX2JyZWFraW5nX3NwYWNlKSB7XG4gICAgICB0aGlzLnNldF93cmFwX3BvaW50KCk7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudF9saW5lLnB1c2goJyAnKTtcbiAgfVxufTtcblxuT3V0cHV0LnByb3RvdHlwZS5yZW1vdmVfaW5kZW50ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgdmFyIG91dHB1dF9sZW5ndGggPSB0aGlzLl9fbGluZXMubGVuZ3RoO1xuICB3aGlsZSAoaW5kZXggPCBvdXRwdXRfbGVuZ3RoKSB7XG4gICAgdGhpcy5fX2xpbmVzW2luZGV4XS5fcmVtb3ZlX2luZGVudCgpO1xuICAgIGluZGV4Kys7XG4gIH1cbiAgdGhpcy5jdXJyZW50X2xpbmUuX3JlbW92ZV93cmFwX2luZGVudCgpO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS50cmltID0gZnVuY3Rpb24oZWF0X25ld2xpbmVzKSB7XG4gIGVhdF9uZXdsaW5lcyA9IChlYXRfbmV3bGluZXMgPT09IHVuZGVmaW5lZCkgPyBmYWxzZSA6IGVhdF9uZXdsaW5lcztcblxuICB0aGlzLmN1cnJlbnRfbGluZS50cmltKCk7XG5cbiAgd2hpbGUgKGVhdF9uZXdsaW5lcyAmJiB0aGlzLl9fbGluZXMubGVuZ3RoID4gMSAmJlxuICAgIHRoaXMuY3VycmVudF9saW5lLmlzX2VtcHR5KCkpIHtcbiAgICB0aGlzLl9fbGluZXMucG9wKCk7XG4gICAgdGhpcy5jdXJyZW50X2xpbmUgPSB0aGlzLl9fbGluZXNbdGhpcy5fX2xpbmVzLmxlbmd0aCAtIDFdO1xuICAgIHRoaXMuY3VycmVudF9saW5lLnRyaW0oKTtcbiAgfVxuXG4gIHRoaXMucHJldmlvdXNfbGluZSA9IHRoaXMuX19saW5lcy5sZW5ndGggPiAxID9cbiAgICB0aGlzLl9fbGluZXNbdGhpcy5fX2xpbmVzLmxlbmd0aCAtIDJdIDogbnVsbDtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuanVzdF9hZGRlZF9uZXdsaW5lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmN1cnJlbnRfbGluZS5pc19lbXB0eSgpO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5qdXN0X2FkZGVkX2JsYW5rbGluZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5pc19lbXB0eSgpIHx8XG4gICAgKHRoaXMuY3VycmVudF9saW5lLmlzX2VtcHR5KCkgJiYgdGhpcy5wcmV2aW91c19saW5lLmlzX2VtcHR5KCkpO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5lbnN1cmVfZW1wdHlfbGluZV9hYm92ZSA9IGZ1bmN0aW9uKHN0YXJ0c193aXRoLCBlbmRzX3dpdGgpIHtcbiAgdmFyIGluZGV4ID0gdGhpcy5fX2xpbmVzLmxlbmd0aCAtIDI7XG4gIHdoaWxlIChpbmRleCA+PSAwKSB7XG4gICAgdmFyIHBvdGVudGlhbEVtcHR5TGluZSA9IHRoaXMuX19saW5lc1tpbmRleF07XG4gICAgaWYgKHBvdGVudGlhbEVtcHR5TGluZS5pc19lbXB0eSgpKSB7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2UgaWYgKHBvdGVudGlhbEVtcHR5TGluZS5pdGVtKDApLmluZGV4T2Yoc3RhcnRzX3dpdGgpICE9PSAwICYmXG4gICAgICBwb3RlbnRpYWxFbXB0eUxpbmUuaXRlbSgtMSkgIT09IGVuZHNfd2l0aCkge1xuICAgICAgdGhpcy5fX2xpbmVzLnNwbGljZShpbmRleCArIDEsIDAsIG5ldyBPdXRwdXRMaW5lKHRoaXMpKTtcbiAgICAgIHRoaXMucHJldmlvdXNfbGluZSA9IHRoaXMuX19saW5lc1t0aGlzLl9fbGluZXMubGVuZ3RoIC0gMl07XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaW5kZXgtLTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuT3V0cHV0ID0gT3V0cHV0O1xuXG5cbi8qKiovIH0pLFxuLyogMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbmZ1bmN0aW9uIFRva2VuKHR5cGUsIHRleHQsIG5ld2xpbmVzLCB3aGl0ZXNwYWNlX2JlZm9yZSkge1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnRleHQgPSB0ZXh0O1xuXG4gIC8vIGNvbW1lbnRzX2JlZm9yZSBhcmVcbiAgLy8gY29tbWVudHMgdGhhdCBoYXZlIGEgbmV3IGxpbmUgYmVmb3JlIHRoZW1cbiAgLy8gYW5kIG1heSBvciBtYXkgbm90IGhhdmUgYSBuZXdsaW5lIGFmdGVyXG4gIC8vIHRoaXMgaXMgYSBzZXQgb2YgY29tbWVudHMgYmVmb3JlXG4gIHRoaXMuY29tbWVudHNfYmVmb3JlID0gbnVsbDsgLyogaW5saW5lIGNvbW1lbnQqL1xuXG5cbiAgLy8gdGhpcy5jb21tZW50c19hZnRlciA9ICBuZXcgVG9rZW5TdHJlYW0oKTsgLy8gbm8gbmV3IGxpbmUgYmVmb3JlIGFuZCBuZXdsaW5lIGFmdGVyXG4gIHRoaXMubmV3bGluZXMgPSBuZXdsaW5lcyB8fCAwO1xuICB0aGlzLndoaXRlc3BhY2VfYmVmb3JlID0gd2hpdGVzcGFjZV9iZWZvcmUgfHwgJyc7XG4gIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5wcmV2aW91cyA9IG51bGw7XG4gIHRoaXMub3BlbmVkID0gbnVsbDtcbiAgdGhpcy5jbG9zZWQgPSBudWxsO1xuICB0aGlzLmRpcmVjdGl2ZXMgPSBudWxsO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzLlRva2VuID0gVG9rZW47XG5cblxuLyoqKi8gfSksXG4vKiA0ICovLFxuLyogNSAqLyxcbi8qIDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG5mdW5jdGlvbiBPcHRpb25zKG9wdGlvbnMsIG1lcmdlX2NoaWxkX2ZpZWxkKSB7XG4gIHRoaXMucmF3X29wdGlvbnMgPSBfbWVyZ2VPcHRzKG9wdGlvbnMsIG1lcmdlX2NoaWxkX2ZpZWxkKTtcblxuICAvLyBTdXBwb3J0IHBhc3NpbmcgdGhlIHNvdXJjZSB0ZXh0IGJhY2sgd2l0aCBubyBjaGFuZ2VcbiAgdGhpcy5kaXNhYmxlZCA9IHRoaXMuX2dldF9ib29sZWFuKCdkaXNhYmxlZCcpO1xuXG4gIHRoaXMuZW9sID0gdGhpcy5fZ2V0X2NoYXJhY3RlcnMoJ2VvbCcsICdhdXRvJyk7XG4gIHRoaXMuZW5kX3dpdGhfbmV3bGluZSA9IHRoaXMuX2dldF9ib29sZWFuKCdlbmRfd2l0aF9uZXdsaW5lJyk7XG4gIHRoaXMuaW5kZW50X3NpemUgPSB0aGlzLl9nZXRfbnVtYmVyKCdpbmRlbnRfc2l6ZScsIDQpO1xuICB0aGlzLmluZGVudF9jaGFyID0gdGhpcy5fZ2V0X2NoYXJhY3RlcnMoJ2luZGVudF9jaGFyJywgJyAnKTtcbiAgdGhpcy5pbmRlbnRfbGV2ZWwgPSB0aGlzLl9nZXRfbnVtYmVyKCdpbmRlbnRfbGV2ZWwnKTtcblxuICB0aGlzLnByZXNlcnZlX25ld2xpbmVzID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ3ByZXNlcnZlX25ld2xpbmVzJywgdHJ1ZSk7XG4gIHRoaXMubWF4X3ByZXNlcnZlX25ld2xpbmVzID0gdGhpcy5fZ2V0X251bWJlcignbWF4X3ByZXNlcnZlX25ld2xpbmVzJywgMzI3ODYpO1xuICBpZiAoIXRoaXMucHJlc2VydmVfbmV3bGluZXMpIHtcbiAgICB0aGlzLm1heF9wcmVzZXJ2ZV9uZXdsaW5lcyA9IDA7XG4gIH1cblxuICB0aGlzLmluZGVudF93aXRoX3RhYnMgPSB0aGlzLl9nZXRfYm9vbGVhbignaW5kZW50X3dpdGhfdGFicycsIHRoaXMuaW5kZW50X2NoYXIgPT09ICdcXHQnKTtcbiAgaWYgKHRoaXMuaW5kZW50X3dpdGhfdGFicykge1xuICAgIHRoaXMuaW5kZW50X2NoYXIgPSAnXFx0JztcblxuICAgIC8vIGluZGVudF9zaXplIGJlaGF2aW9yIGNoYW5nZWQgYWZ0ZXIgMS44LjZcbiAgICAvLyBJdCB1c2VkIHRvIGJlIHRoYXQgaW5kZW50X3NpemUgd291bGQgYmVcbiAgICAvLyBzZXQgdG8gMSBmb3IgaW5kZW50X3dpdGhfdGFicy4gVGhhdCBpcyBubyBsb25nZXIgbmVlZGVkIGFuZFxuICAgIC8vIGFjdHVhbGx5IGRvZXNuJ3QgbWFrZSBzZW5zZSAtIHdoeSBub3QgdXNlIHNwYWNlcz8gRnVydGhlcixcbiAgICAvLyB0aGF0IG1pZ2h0IHByb2R1Y2UgdW5leHBlY3RlZCBiZWhhdmlvciAtIHRhYnMgYmVpbmcgdXNlZFxuICAgIC8vIGZvciBzaW5nbGUtY29sdW1uIGFsaWdubWVudC4gU28sIHdoZW4gaW5kZW50X3dpdGhfdGFicyBpcyB0cnVlXG4gICAgLy8gYW5kIGluZGVudF9zaXplIGlzIDEsIHJlc2V0IGluZGVudF9zaXplIHRvIDQuXG4gICAgaWYgKHRoaXMuaW5kZW50X3NpemUgPT09IDEpIHtcbiAgICAgIHRoaXMuaW5kZW50X3NpemUgPSA0O1xuICAgIH1cbiAgfVxuXG4gIC8vIEJhY2t3YXJkcyBjb21wYXQgd2l0aCAxLjMueFxuICB0aGlzLndyYXBfbGluZV9sZW5ndGggPSB0aGlzLl9nZXRfbnVtYmVyKCd3cmFwX2xpbmVfbGVuZ3RoJywgdGhpcy5fZ2V0X251bWJlcignbWF4X2NoYXInKSk7XG5cbiAgdGhpcy5pbmRlbnRfZW1wdHlfbGluZXMgPSB0aGlzLl9nZXRfYm9vbGVhbignaW5kZW50X2VtcHR5X2xpbmVzJyk7XG5cbiAgLy8gdmFsaWQgdGVtcGxhdGluZyBsYW5ndWFnZXMgWydkamFuZ28nLCAnZXJiJywgJ2hhbmRsZWJhcnMnLCAncGhwJywgJ3NtYXJ0eScsICdhbmd1bGFyJ11cbiAgLy8gRm9yIG5vdywgJ2F1dG8nID0gYWxsIG9mZiBmb3IgamF2YXNjcmlwdCwgYWxsIGV4Y2VwdCBhbmd1bGFyIG9uIGZvciBodG1sIChhbmQgaW5saW5lIGphdmFzY3JpcHQvY3NzKS5cbiAgLy8gb3RoZXIgdmFsdWVzIGlnbm9yZWRcbiAgdGhpcy50ZW1wbGF0aW5nID0gdGhpcy5fZ2V0X3NlbGVjdGlvbl9saXN0KCd0ZW1wbGF0aW5nJywgWydhdXRvJywgJ25vbmUnLCAnYW5ndWxhcicsICdkamFuZ28nLCAnZXJiJywgJ2hhbmRsZWJhcnMnLCAncGhwJywgJ3NtYXJ0eSddLCBbJ2F1dG8nXSk7XG59XG5cbk9wdGlvbnMucHJvdG90eXBlLl9nZXRfYXJyYXkgPSBmdW5jdGlvbihuYW1lLCBkZWZhdWx0X3ZhbHVlKSB7XG4gIHZhciBvcHRpb25fdmFsdWUgPSB0aGlzLnJhd19vcHRpb25zW25hbWVdO1xuICB2YXIgcmVzdWx0ID0gZGVmYXVsdF92YWx1ZSB8fCBbXTtcbiAgaWYgKHR5cGVvZiBvcHRpb25fdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKG9wdGlvbl92YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2Ygb3B0aW9uX3ZhbHVlLmNvbmNhdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVzdWx0ID0gb3B0aW9uX3ZhbHVlLmNvbmNhdCgpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9uX3ZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJlc3VsdCA9IG9wdGlvbl92YWx1ZS5zcGxpdCgvW15hLXpBLVowLTlfXFwvXFwtXSsvKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuT3B0aW9ucy5wcm90b3R5cGUuX2dldF9ib29sZWFuID0gZnVuY3Rpb24obmFtZSwgZGVmYXVsdF92YWx1ZSkge1xuICB2YXIgb3B0aW9uX3ZhbHVlID0gdGhpcy5yYXdfb3B0aW9uc1tuYW1lXTtcbiAgdmFyIHJlc3VsdCA9IG9wdGlvbl92YWx1ZSA9PT0gdW5kZWZpbmVkID8gISFkZWZhdWx0X3ZhbHVlIDogISFvcHRpb25fdmFsdWU7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5PcHRpb25zLnByb3RvdHlwZS5fZ2V0X2NoYXJhY3RlcnMgPSBmdW5jdGlvbihuYW1lLCBkZWZhdWx0X3ZhbHVlKSB7XG4gIHZhciBvcHRpb25fdmFsdWUgPSB0aGlzLnJhd19vcHRpb25zW25hbWVdO1xuICB2YXIgcmVzdWx0ID0gZGVmYXVsdF92YWx1ZSB8fCAnJztcbiAgaWYgKHR5cGVvZiBvcHRpb25fdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmVzdWx0ID0gb3B0aW9uX3ZhbHVlLnJlcGxhY2UoL1xcXFxyLywgJ1xccicpLnJlcGxhY2UoL1xcXFxuLywgJ1xcbicpLnJlcGxhY2UoL1xcXFx0LywgJ1xcdCcpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5PcHRpb25zLnByb3RvdHlwZS5fZ2V0X251bWJlciA9IGZ1bmN0aW9uKG5hbWUsIGRlZmF1bHRfdmFsdWUpIHtcbiAgdmFyIG9wdGlvbl92YWx1ZSA9IHRoaXMucmF3X29wdGlvbnNbbmFtZV07XG4gIGRlZmF1bHRfdmFsdWUgPSBwYXJzZUludChkZWZhdWx0X3ZhbHVlLCAxMCk7XG4gIGlmIChpc05hTihkZWZhdWx0X3ZhbHVlKSkge1xuICAgIGRlZmF1bHRfdmFsdWUgPSAwO1xuICB9XG4gIHZhciByZXN1bHQgPSBwYXJzZUludChvcHRpb25fdmFsdWUsIDEwKTtcbiAgaWYgKGlzTmFOKHJlc3VsdCkpIHtcbiAgICByZXN1bHQgPSBkZWZhdWx0X3ZhbHVlO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5PcHRpb25zLnByb3RvdHlwZS5fZ2V0X3NlbGVjdGlvbiA9IGZ1bmN0aW9uKG5hbWUsIHNlbGVjdGlvbl9saXN0LCBkZWZhdWx0X3ZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9nZXRfc2VsZWN0aW9uX2xpc3QobmFtZSwgc2VsZWN0aW9uX2xpc3QsIGRlZmF1bHRfdmFsdWUpO1xuICBpZiAocmVzdWx0Lmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiSW52YWxpZCBPcHRpb24gVmFsdWU6IFRoZSBvcHRpb24gJ1wiICsgbmFtZSArIFwiJyBjYW4gb25seSBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZyB2YWx1ZXM6XFxuXCIgK1xuICAgICAgc2VsZWN0aW9uX2xpc3QgKyBcIlxcbllvdSBwYXNzZWQgaW46ICdcIiArIHRoaXMucmF3X29wdGlvbnNbbmFtZV0gKyBcIidcIik7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0WzBdO1xufTtcblxuXG5PcHRpb25zLnByb3RvdHlwZS5fZ2V0X3NlbGVjdGlvbl9saXN0ID0gZnVuY3Rpb24obmFtZSwgc2VsZWN0aW9uX2xpc3QsIGRlZmF1bHRfdmFsdWUpIHtcbiAgaWYgKCFzZWxlY3Rpb25fbGlzdCB8fCBzZWxlY3Rpb25fbGlzdC5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZWxlY3Rpb24gbGlzdCBjYW5ub3QgYmUgZW1wdHkuXCIpO1xuICB9XG5cbiAgZGVmYXVsdF92YWx1ZSA9IGRlZmF1bHRfdmFsdWUgfHwgW3NlbGVjdGlvbl9saXN0WzBdXTtcbiAgaWYgKCF0aGlzLl9pc192YWxpZF9zZWxlY3Rpb24oZGVmYXVsdF92YWx1ZSwgc2VsZWN0aW9uX2xpc3QpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBEZWZhdWx0IFZhbHVlIVwiKTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSB0aGlzLl9nZXRfYXJyYXkobmFtZSwgZGVmYXVsdF92YWx1ZSk7XG4gIGlmICghdGhpcy5faXNfdmFsaWRfc2VsZWN0aW9uKHJlc3VsdCwgc2VsZWN0aW9uX2xpc3QpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJJbnZhbGlkIE9wdGlvbiBWYWx1ZTogVGhlIG9wdGlvbiAnXCIgKyBuYW1lICsgXCInIGNhbiBjb250YWluIG9ubHkgdGhlIGZvbGxvd2luZyB2YWx1ZXM6XFxuXCIgK1xuICAgICAgc2VsZWN0aW9uX2xpc3QgKyBcIlxcbllvdSBwYXNzZWQgaW46ICdcIiArIHRoaXMucmF3X29wdGlvbnNbbmFtZV0gKyBcIidcIik7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuT3B0aW9ucy5wcm90b3R5cGUuX2lzX3ZhbGlkX3NlbGVjdGlvbiA9IGZ1bmN0aW9uKHJlc3VsdCwgc2VsZWN0aW9uX2xpc3QpIHtcbiAgcmV0dXJuIHJlc3VsdC5sZW5ndGggJiYgc2VsZWN0aW9uX2xpc3QubGVuZ3RoICYmXG4gICAgIXJlc3VsdC5zb21lKGZ1bmN0aW9uKGl0ZW0pIHsgcmV0dXJuIHNlbGVjdGlvbl9saXN0LmluZGV4T2YoaXRlbSkgPT09IC0xOyB9KTtcbn07XG5cblxuLy8gbWVyZ2VzIGNoaWxkIG9wdGlvbnMgdXAgd2l0aCB0aGUgcGFyZW50IG9wdGlvbnMgb2JqZWN0XG4vLyBFeGFtcGxlOiBvYmogPSB7YTogMSwgYjoge2E6IDJ9fVxuLy8gICAgICAgICAgbWVyZ2VPcHRzKG9iaiwgJ2InKVxuLy9cbi8vICAgICAgICAgIFJldHVybnM6IHthOiAyfVxuZnVuY3Rpb24gX21lcmdlT3B0cyhhbGxPcHRpb25zLCBjaGlsZEZpZWxkTmFtZSkge1xuICB2YXIgZmluYWxPcHRzID0ge307XG4gIGFsbE9wdGlvbnMgPSBfbm9ybWFsaXplT3B0cyhhbGxPcHRpb25zKTtcbiAgdmFyIG5hbWU7XG5cbiAgZm9yIChuYW1lIGluIGFsbE9wdGlvbnMpIHtcbiAgICBpZiAobmFtZSAhPT0gY2hpbGRGaWVsZE5hbWUpIHtcbiAgICAgIGZpbmFsT3B0c1tuYW1lXSA9IGFsbE9wdGlvbnNbbmFtZV07XG4gICAgfVxuICB9XG5cbiAgLy9tZXJnZSBpbiB0aGUgcGVyIHR5cGUgc2V0dGluZ3MgZm9yIHRoZSBjaGlsZEZpZWxkTmFtZVxuICBpZiAoY2hpbGRGaWVsZE5hbWUgJiYgYWxsT3B0aW9uc1tjaGlsZEZpZWxkTmFtZV0pIHtcbiAgICBmb3IgKG5hbWUgaW4gYWxsT3B0aW9uc1tjaGlsZEZpZWxkTmFtZV0pIHtcbiAgICAgIGZpbmFsT3B0c1tuYW1lXSA9IGFsbE9wdGlvbnNbY2hpbGRGaWVsZE5hbWVdW25hbWVdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmluYWxPcHRzO1xufVxuXG5mdW5jdGlvbiBfbm9ybWFsaXplT3B0cyhvcHRpb25zKSB7XG4gIHZhciBjb252ZXJ0ZWRPcHRzID0ge307XG4gIHZhciBrZXk7XG5cbiAgZm9yIChrZXkgaW4gb3B0aW9ucykge1xuICAgIHZhciBuZXdLZXkgPSBrZXkucmVwbGFjZSgvLS9nLCBcIl9cIik7XG4gICAgY29udmVydGVkT3B0c1tuZXdLZXldID0gb3B0aW9uc1trZXldO1xuICB9XG4gIHJldHVybiBjb252ZXJ0ZWRPcHRzO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5PcHRpb25zID0gT3B0aW9ucztcbm1vZHVsZS5leHBvcnRzLm5vcm1hbGl6ZU9wdHMgPSBfbm9ybWFsaXplT3B0cztcbm1vZHVsZS5leHBvcnRzLm1lcmdlT3B0cyA9IF9tZXJnZU9wdHM7XG5cblxuLyoqKi8gfSksXG4vKiA3ICovLFxuLyogOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbnZhciByZWdleHBfaGFzX3N0aWNreSA9IFJlZ0V4cC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJ3N0aWNreScpO1xuXG5mdW5jdGlvbiBJbnB1dFNjYW5uZXIoaW5wdXRfc3RyaW5nKSB7XG4gIHRoaXMuX19pbnB1dCA9IGlucHV0X3N0cmluZyB8fCAnJztcbiAgdGhpcy5fX2lucHV0X2xlbmd0aCA9IHRoaXMuX19pbnB1dC5sZW5ndGg7XG4gIHRoaXMuX19wb3NpdGlvbiA9IDA7XG59XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUucmVzdGFydCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9fcG9zaXRpb24gPSAwO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5iYWNrID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9fcG9zaXRpb24gPiAwKSB7XG4gICAgdGhpcy5fX3Bvc2l0aW9uIC09IDE7XG4gIH1cbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUuaGFzTmV4dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fX3Bvc2l0aW9uIDwgdGhpcy5fX2lucHV0X2xlbmd0aDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdmFsID0gbnVsbDtcbiAgaWYgKHRoaXMuaGFzTmV4dCgpKSB7XG4gICAgdmFsID0gdGhpcy5fX2lucHV0LmNoYXJBdCh0aGlzLl9fcG9zaXRpb24pO1xuICAgIHRoaXMuX19wb3NpdGlvbiArPSAxO1xuICB9XG4gIHJldHVybiB2YWw7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbihpbmRleCkge1xuICB2YXIgdmFsID0gbnVsbDtcbiAgaW5kZXggPSBpbmRleCB8fCAwO1xuICBpbmRleCArPSB0aGlzLl9fcG9zaXRpb247XG4gIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5fX2lucHV0X2xlbmd0aCkge1xuICAgIHZhbCA9IHRoaXMuX19pbnB1dC5jaGFyQXQoaW5kZXgpO1xuICB9XG4gIHJldHVybiB2YWw7XG59O1xuXG4vLyBUaGlzIGlzIGEgSmF2YVNjcmlwdCBvbmx5IGhlbHBlciBmdW5jdGlvbiAobm90IGluIHB5dGhvbilcbi8vIEphdmFzY3JpcHQgZG9lc24ndCBoYXZlIGEgbWF0Y2ggbWV0aG9kXG4vLyBhbmQgbm90IGFsbCBpbXBsZW1lbnRhdGlvbiBzdXBwb3J0IFwic3RpY2t5XCIgZmxhZy5cbi8vIElmIHRoZXkgZG8gbm90IHN1cHBvcnQgc3RpY2t5IHRoZW4gYm90aCB0aGlzLm1hdGNoKCkgYW5kIHRoaXMudGVzdCgpIG1ldGhvZFxuLy8gbXVzdCBnZXQgdGhlIG1hdGNoIGFuZCBjaGVjayB0aGUgaW5kZXggb2YgdGhlIG1hdGNoLlxuLy8gSWYgc3RpY2t5IGlzIHN1cHBvcnRlZCBhbmQgc2V0LCB0aGlzIG1ldGhvZCB3aWxsIHVzZSBpdC5cbi8vIE90aGVyd2lzZSBpdCB3aWxsIGNoZWNrIHRoYXQgZ2xvYmFsIGlzIHNldCwgYW5kIGZhbGwgYmFjayB0byB0aGUgc2xvd2VyIG1ldGhvZC5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUuX19tYXRjaCA9IGZ1bmN0aW9uKHBhdHRlcm4sIGluZGV4KSB7XG4gIHBhdHRlcm4ubGFzdEluZGV4ID0gaW5kZXg7XG4gIHZhciBwYXR0ZXJuX21hdGNoID0gcGF0dGVybi5leGVjKHRoaXMuX19pbnB1dCk7XG5cbiAgaWYgKHBhdHRlcm5fbWF0Y2ggJiYgIShyZWdleHBfaGFzX3N0aWNreSAmJiBwYXR0ZXJuLnN0aWNreSkpIHtcbiAgICBpZiAocGF0dGVybl9tYXRjaC5pbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgIHBhdHRlcm5fbWF0Y2ggPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXR0ZXJuX21hdGNoO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS50ZXN0ID0gZnVuY3Rpb24ocGF0dGVybiwgaW5kZXgpIHtcbiAgaW5kZXggPSBpbmRleCB8fCAwO1xuICBpbmRleCArPSB0aGlzLl9fcG9zaXRpb247XG5cbiAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLl9faW5wdXRfbGVuZ3RoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fX21hdGNoKHBhdHRlcm4sIGluZGV4KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUudGVzdENoYXIgPSBmdW5jdGlvbihwYXR0ZXJuLCBpbmRleCkge1xuICAvLyB0ZXN0IG9uZSBjaGFyYWN0ZXIgcmVnZXggbWF0Y2hcbiAgdmFyIHZhbCA9IHRoaXMucGVlayhpbmRleCk7XG4gIHBhdHRlcm4ubGFzdEluZGV4ID0gMDtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiBwYXR0ZXJuLnRlc3QodmFsKTtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gIHZhciBwYXR0ZXJuX21hdGNoID0gdGhpcy5fX21hdGNoKHBhdHRlcm4sIHRoaXMuX19wb3NpdGlvbik7XG4gIGlmIChwYXR0ZXJuX21hdGNoKSB7XG4gICAgdGhpcy5fX3Bvc2l0aW9uICs9IHBhdHRlcm5fbWF0Y2hbMF0ubGVuZ3RoO1xuICB9IGVsc2Uge1xuICAgIHBhdHRlcm5fbWF0Y2ggPSBudWxsO1xuICB9XG4gIHJldHVybiBwYXR0ZXJuX21hdGNoO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24oc3RhcnRpbmdfcGF0dGVybiwgdW50aWxfcGF0dGVybiwgdW50aWxfYWZ0ZXIpIHtcbiAgdmFyIHZhbCA9ICcnO1xuICB2YXIgbWF0Y2g7XG4gIGlmIChzdGFydGluZ19wYXR0ZXJuKSB7XG4gICAgbWF0Y2ggPSB0aGlzLm1hdGNoKHN0YXJ0aW5nX3BhdHRlcm4pO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgdmFsICs9IG1hdGNoWzBdO1xuICAgIH1cbiAgfVxuICBpZiAodW50aWxfcGF0dGVybiAmJiAobWF0Y2ggfHwgIXN0YXJ0aW5nX3BhdHRlcm4pKSB7XG4gICAgdmFsICs9IHRoaXMucmVhZFVudGlsKHVudGlsX3BhdHRlcm4sIHVudGlsX2FmdGVyKTtcbiAgfVxuICByZXR1cm4gdmFsO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5yZWFkVW50aWwgPSBmdW5jdGlvbihwYXR0ZXJuLCB1bnRpbF9hZnRlcikge1xuICB2YXIgdmFsID0gJyc7XG4gIHZhciBtYXRjaF9pbmRleCA9IHRoaXMuX19wb3NpdGlvbjtcbiAgcGF0dGVybi5sYXN0SW5kZXggPSB0aGlzLl9fcG9zaXRpb247XG4gIHZhciBwYXR0ZXJuX21hdGNoID0gcGF0dGVybi5leGVjKHRoaXMuX19pbnB1dCk7XG4gIGlmIChwYXR0ZXJuX21hdGNoKSB7XG4gICAgbWF0Y2hfaW5kZXggPSBwYXR0ZXJuX21hdGNoLmluZGV4O1xuICAgIGlmICh1bnRpbF9hZnRlcikge1xuICAgICAgbWF0Y2hfaW5kZXggKz0gcGF0dGVybl9tYXRjaFswXS5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG1hdGNoX2luZGV4ID0gdGhpcy5fX2lucHV0X2xlbmd0aDtcbiAgfVxuXG4gIHZhbCA9IHRoaXMuX19pbnB1dC5zdWJzdHJpbmcodGhpcy5fX3Bvc2l0aW9uLCBtYXRjaF9pbmRleCk7XG4gIHRoaXMuX19wb3NpdGlvbiA9IG1hdGNoX2luZGV4O1xuICByZXR1cm4gdmFsO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5yZWFkVW50aWxBZnRlciA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgcmV0dXJuIHRoaXMucmVhZFVudGlsKHBhdHRlcm4sIHRydWUpO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5nZXRfcmVnZXhwID0gZnVuY3Rpb24ocGF0dGVybiwgbWF0Y2hfZnJvbSkge1xuICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgdmFyIGZsYWdzID0gJ2cnO1xuICBpZiAobWF0Y2hfZnJvbSAmJiByZWdleHBfaGFzX3N0aWNreSkge1xuICAgIGZsYWdzID0gJ3knO1xuICB9XG4gIC8vIHN0cmluZ3MgYXJlIGNvbnZlcnRlZCB0byByZWdleHBcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSBcInN0cmluZ1wiICYmIHBhdHRlcm4gIT09ICcnKSB7XG4gICAgLy8gcmVzdWx0ID0gbmV3IFJlZ0V4cChwYXR0ZXJuLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpLCBmbGFncyk7XG4gICAgcmVzdWx0ID0gbmV3IFJlZ0V4cChwYXR0ZXJuLCBmbGFncyk7XG4gIH0gZWxzZSBpZiAocGF0dGVybikge1xuICAgIHJlc3VsdCA9IG5ldyBSZWdFeHAocGF0dGVybi5zb3VyY2UsIGZsYWdzKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5nZXRfbGl0ZXJhbF9yZWdleHAgPSBmdW5jdGlvbihsaXRlcmFsX3N0cmluZykge1xuICByZXR1cm4gUmVnRXhwKGxpdGVyYWxfc3RyaW5nLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpKTtcbn07XG5cbi8qIGNzcyBiZWF1dGlmaWVyIGxlZ2FjeSBoZWxwZXJzICovXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLnBlZWtVbnRpbEFmdGVyID0gZnVuY3Rpb24ocGF0dGVybikge1xuICB2YXIgc3RhcnQgPSB0aGlzLl9fcG9zaXRpb247XG4gIHZhciB2YWwgPSB0aGlzLnJlYWRVbnRpbEFmdGVyKHBhdHRlcm4pO1xuICB0aGlzLl9fcG9zaXRpb24gPSBzdGFydDtcbiAgcmV0dXJuIHZhbDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUubG9va0JhY2sgPSBmdW5jdGlvbih0ZXN0VmFsKSB7XG4gIHZhciBzdGFydCA9IHRoaXMuX19wb3NpdGlvbiAtIDE7XG4gIHJldHVybiBzdGFydCA+PSB0ZXN0VmFsLmxlbmd0aCAmJiB0aGlzLl9faW5wdXQuc3Vic3RyaW5nKHN0YXJ0IC0gdGVzdFZhbC5sZW5ndGgsIHN0YXJ0KVxuICAgIC50b0xvd2VyQ2FzZSgpID09PSB0ZXN0VmFsO1xufTtcblxubW9kdWxlLmV4cG9ydHMuSW5wdXRTY2FubmVyID0gSW5wdXRTY2FubmVyO1xuXG5cbi8qKiovIH0pLFxuLyogOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxudmFyIElucHV0U2Nhbm5lciA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDgpLklucHV0U2Nhbm5lcik7XG52YXIgVG9rZW4gPSAoX193ZWJwYWNrX3JlcXVpcmVfXygzKS5Ub2tlbik7XG52YXIgVG9rZW5TdHJlYW0gPSAoX193ZWJwYWNrX3JlcXVpcmVfXygxMCkuVG9rZW5TdHJlYW0pO1xudmFyIFdoaXRlc3BhY2VQYXR0ZXJuID0gKF9fd2VicGFja19yZXF1aXJlX18oMTEpLldoaXRlc3BhY2VQYXR0ZXJuKTtcblxudmFyIFRPS0VOID0ge1xuICBTVEFSVDogJ1RLX1NUQVJUJyxcbiAgUkFXOiAnVEtfUkFXJyxcbiAgRU9GOiAnVEtfRU9GJ1xufTtcblxudmFyIFRva2VuaXplciA9IGZ1bmN0aW9uKGlucHV0X3N0cmluZywgb3B0aW9ucykge1xuICB0aGlzLl9pbnB1dCA9IG5ldyBJbnB1dFNjYW5uZXIoaW5wdXRfc3RyaW5nKTtcbiAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMuX190b2tlbnMgPSBudWxsO1xuXG4gIHRoaXMuX3BhdHRlcm5zID0ge307XG4gIHRoaXMuX3BhdHRlcm5zLndoaXRlc3BhY2UgPSBuZXcgV2hpdGVzcGFjZVBhdHRlcm4odGhpcy5faW5wdXQpO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS50b2tlbml6ZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9pbnB1dC5yZXN0YXJ0KCk7XG4gIHRoaXMuX190b2tlbnMgPSBuZXcgVG9rZW5TdHJlYW0oKTtcblxuICB0aGlzLl9yZXNldCgpO1xuXG4gIHZhciBjdXJyZW50O1xuICB2YXIgcHJldmlvdXMgPSBuZXcgVG9rZW4oVE9LRU4uU1RBUlQsICcnKTtcbiAgdmFyIG9wZW5fdG9rZW4gPSBudWxsO1xuICB2YXIgb3Blbl9zdGFjayA9IFtdO1xuICB2YXIgY29tbWVudHMgPSBuZXcgVG9rZW5TdHJlYW0oKTtcblxuICB3aGlsZSAocHJldmlvdXMudHlwZSAhPT0gVE9LRU4uRU9GKSB7XG4gICAgY3VycmVudCA9IHRoaXMuX2dldF9uZXh0X3Rva2VuKHByZXZpb3VzLCBvcGVuX3Rva2VuKTtcbiAgICB3aGlsZSAodGhpcy5faXNfY29tbWVudChjdXJyZW50KSkge1xuICAgICAgY29tbWVudHMuYWRkKGN1cnJlbnQpO1xuICAgICAgY3VycmVudCA9IHRoaXMuX2dldF9uZXh0X3Rva2VuKHByZXZpb3VzLCBvcGVuX3Rva2VuKTtcbiAgICB9XG5cbiAgICBpZiAoIWNvbW1lbnRzLmlzRW1wdHkoKSkge1xuICAgICAgY3VycmVudC5jb21tZW50c19iZWZvcmUgPSBjb21tZW50cztcbiAgICAgIGNvbW1lbnRzID0gbmV3IFRva2VuU3RyZWFtKCk7XG4gICAgfVxuXG4gICAgY3VycmVudC5wYXJlbnQgPSBvcGVuX3Rva2VuO1xuXG4gICAgaWYgKHRoaXMuX2lzX29wZW5pbmcoY3VycmVudCkpIHtcbiAgICAgIG9wZW5fc3RhY2sucHVzaChvcGVuX3Rva2VuKTtcbiAgICAgIG9wZW5fdG9rZW4gPSBjdXJyZW50O1xuICAgIH0gZWxzZSBpZiAob3Blbl90b2tlbiAmJiB0aGlzLl9pc19jbG9zaW5nKGN1cnJlbnQsIG9wZW5fdG9rZW4pKSB7XG4gICAgICBjdXJyZW50Lm9wZW5lZCA9IG9wZW5fdG9rZW47XG4gICAgICBvcGVuX3Rva2VuLmNsb3NlZCA9IGN1cnJlbnQ7XG4gICAgICBvcGVuX3Rva2VuID0gb3Blbl9zdGFjay5wb3AoKTtcbiAgICAgIGN1cnJlbnQucGFyZW50ID0gb3Blbl90b2tlbjtcbiAgICB9XG5cbiAgICBjdXJyZW50LnByZXZpb3VzID0gcHJldmlvdXM7XG4gICAgcHJldmlvdXMubmV4dCA9IGN1cnJlbnQ7XG5cbiAgICB0aGlzLl9fdG9rZW5zLmFkZChjdXJyZW50KTtcbiAgICBwcmV2aW91cyA9IGN1cnJlbnQ7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fX3Rva2Vucztcbn07XG5cblxuVG9rZW5pemVyLnByb3RvdHlwZS5faXNfZmlyc3RfdG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX190b2tlbnMuaXNFbXB0eSgpO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fcmVzZXQgPSBmdW5jdGlvbigpIHt9O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9nZXRfbmV4dF90b2tlbiA9IGZ1bmN0aW9uKHByZXZpb3VzX3Rva2VuLCBvcGVuX3Rva2VuKSB7IC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbiAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcbiAgdmFyIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9pbnB1dC5yZWFkKC8uKy9nKTtcbiAgaWYgKHJlc3VsdGluZ19zdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLlJBVywgcmVzdWx0aW5nX3N0cmluZyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5FT0YsICcnKTtcbiAgfVxufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5faXNfY29tbWVudCA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4pIHsgLy8ganNoaW50IHVudXNlZDpmYWxzZVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9pc19vcGVuaW5nID0gZnVuY3Rpb24oY3VycmVudF90b2tlbikgeyAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXG4gIHJldHVybiBmYWxzZTtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX2lzX2Nsb3NpbmcgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuLCBvcGVuX3Rva2VuKSB7IC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fY3JlYXRlX3Rva2VuID0gZnVuY3Rpb24odHlwZSwgdGV4dCkge1xuICB2YXIgdG9rZW4gPSBuZXcgVG9rZW4odHlwZSwgdGV4dCxcbiAgICB0aGlzLl9wYXR0ZXJucy53aGl0ZXNwYWNlLm5ld2xpbmVfY291bnQsXG4gICAgdGhpcy5fcGF0dGVybnMud2hpdGVzcGFjZS53aGl0ZXNwYWNlX2JlZm9yZV90b2tlbik7XG4gIHJldHVybiB0b2tlbjtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3JlYWRXaGl0ZXNwYWNlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9wYXR0ZXJucy53aGl0ZXNwYWNlLnJlYWQoKTtcbn07XG5cblxuXG5tb2R1bGUuZXhwb3J0cy5Ub2tlbml6ZXIgPSBUb2tlbml6ZXI7XG5tb2R1bGUuZXhwb3J0cy5UT0tFTiA9IFRPS0VOO1xuXG5cbi8qKiovIH0pLFxuLyogMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG5mdW5jdGlvbiBUb2tlblN0cmVhbShwYXJlbnRfdG9rZW4pIHtcbiAgLy8gcHJpdmF0ZVxuICB0aGlzLl9fdG9rZW5zID0gW107XG4gIHRoaXMuX190b2tlbnNfbGVuZ3RoID0gdGhpcy5fX3Rva2Vucy5sZW5ndGg7XG4gIHRoaXMuX19wb3NpdGlvbiA9IDA7XG4gIHRoaXMuX19wYXJlbnRfdG9rZW4gPSBwYXJlbnRfdG9rZW47XG59XG5cblRva2VuU3RyZWFtLnByb3RvdHlwZS5yZXN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX19wb3NpdGlvbiA9IDA7XG59O1xuXG5Ub2tlblN0cmVhbS5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fX3Rva2Vuc19sZW5ndGggPT09IDA7XG59O1xuXG5Ub2tlblN0cmVhbS5wcm90b3R5cGUuaGFzTmV4dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fX3Bvc2l0aW9uIDwgdGhpcy5fX3Rva2Vuc19sZW5ndGg7XG59O1xuXG5Ub2tlblN0cmVhbS5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdmFsID0gbnVsbDtcbiAgaWYgKHRoaXMuaGFzTmV4dCgpKSB7XG4gICAgdmFsID0gdGhpcy5fX3Rva2Vuc1t0aGlzLl9fcG9zaXRpb25dO1xuICAgIHRoaXMuX19wb3NpdGlvbiArPSAxO1xuICB9XG4gIHJldHVybiB2YWw7XG59O1xuXG5Ub2tlblN0cmVhbS5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gIHZhciB2YWwgPSBudWxsO1xuICBpbmRleCA9IGluZGV4IHx8IDA7XG4gIGluZGV4ICs9IHRoaXMuX19wb3NpdGlvbjtcbiAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLl9fdG9rZW5zX2xlbmd0aCkge1xuICAgIHZhbCA9IHRoaXMuX190b2tlbnNbaW5kZXhdO1xuICB9XG4gIHJldHVybiB2YWw7XG59O1xuXG5Ub2tlblN0cmVhbS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24odG9rZW4pIHtcbiAgaWYgKHRoaXMuX19wYXJlbnRfdG9rZW4pIHtcbiAgICB0b2tlbi5wYXJlbnQgPSB0aGlzLl9fcGFyZW50X3Rva2VuO1xuICB9XG4gIHRoaXMuX190b2tlbnMucHVzaCh0b2tlbik7XG4gIHRoaXMuX190b2tlbnNfbGVuZ3RoICs9IDE7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5Ub2tlblN0cmVhbSA9IFRva2VuU3RyZWFtO1xuXG5cbi8qKiovIH0pLFxuLyogMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbnZhciBQYXR0ZXJuID0gKF9fd2VicGFja19yZXF1aXJlX18oMTIpLlBhdHRlcm4pO1xuXG5mdW5jdGlvbiBXaGl0ZXNwYWNlUGF0dGVybihpbnB1dF9zY2FubmVyLCBwYXJlbnQpIHtcbiAgUGF0dGVybi5jYWxsKHRoaXMsIGlucHV0X3NjYW5uZXIsIHBhcmVudCk7XG4gIGlmIChwYXJlbnQpIHtcbiAgICB0aGlzLl9saW5lX3JlZ2V4cCA9IHRoaXMuX2lucHV0LmdldF9yZWdleHAocGFyZW50Ll9saW5lX3JlZ2V4cCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fX3NldF93aGl0ZXNwYWNlX3BhdHRlcm5zKCcnLCAnJyk7XG4gIH1cblxuICB0aGlzLm5ld2xpbmVfY291bnQgPSAwO1xuICB0aGlzLndoaXRlc3BhY2VfYmVmb3JlX3Rva2VuID0gJyc7XG59XG5XaGl0ZXNwYWNlUGF0dGVybi5wcm90b3R5cGUgPSBuZXcgUGF0dGVybigpO1xuXG5XaGl0ZXNwYWNlUGF0dGVybi5wcm90b3R5cGUuX19zZXRfd2hpdGVzcGFjZV9wYXR0ZXJucyA9IGZ1bmN0aW9uKHdoaXRlc3BhY2VfY2hhcnMsIG5ld2xpbmVfY2hhcnMpIHtcbiAgd2hpdGVzcGFjZV9jaGFycyArPSAnXFxcXHQgJztcbiAgbmV3bGluZV9jaGFycyArPSAnXFxcXG5cXFxccic7XG5cbiAgdGhpcy5fbWF0Y2hfcGF0dGVybiA9IHRoaXMuX2lucHV0LmdldF9yZWdleHAoXG4gICAgJ1snICsgd2hpdGVzcGFjZV9jaGFycyArIG5ld2xpbmVfY2hhcnMgKyAnXSsnLCB0cnVlKTtcbiAgdGhpcy5fbmV3bGluZV9yZWdleHAgPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKFxuICAgICdcXFxcclxcXFxufFsnICsgbmV3bGluZV9jaGFycyArICddJyk7XG59O1xuXG5XaGl0ZXNwYWNlUGF0dGVybi5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLm5ld2xpbmVfY291bnQgPSAwO1xuICB0aGlzLndoaXRlc3BhY2VfYmVmb3JlX3Rva2VuID0gJyc7XG5cbiAgdmFyIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9pbnB1dC5yZWFkKHRoaXMuX21hdGNoX3BhdHRlcm4pO1xuICBpZiAocmVzdWx0aW5nX3N0cmluZyA9PT0gJyAnKSB7XG4gICAgdGhpcy53aGl0ZXNwYWNlX2JlZm9yZV90b2tlbiA9ICcgJztcbiAgfSBlbHNlIGlmIChyZXN1bHRpbmdfc3RyaW5nKSB7XG4gICAgdmFyIG1hdGNoZXMgPSB0aGlzLl9fc3BsaXQodGhpcy5fbmV3bGluZV9yZWdleHAsIHJlc3VsdGluZ19zdHJpbmcpO1xuICAgIHRoaXMubmV3bGluZV9jb3VudCA9IG1hdGNoZXMubGVuZ3RoIC0gMTtcbiAgICB0aGlzLndoaXRlc3BhY2VfYmVmb3JlX3Rva2VuID0gbWF0Y2hlc1t0aGlzLm5ld2xpbmVfY291bnRdO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdGluZ19zdHJpbmc7XG59O1xuXG5XaGl0ZXNwYWNlUGF0dGVybi5wcm90b3R5cGUubWF0Y2hpbmcgPSBmdW5jdGlvbih3aGl0ZXNwYWNlX2NoYXJzLCBuZXdsaW5lX2NoYXJzKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9jcmVhdGUoKTtcbiAgcmVzdWx0Ll9fc2V0X3doaXRlc3BhY2VfcGF0dGVybnMod2hpdGVzcGFjZV9jaGFycywgbmV3bGluZV9jaGFycyk7XG4gIHJlc3VsdC5fdXBkYXRlKCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5XaGl0ZXNwYWNlUGF0dGVybi5wcm90b3R5cGUuX2NyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFdoaXRlc3BhY2VQYXR0ZXJuKHRoaXMuX2lucHV0LCB0aGlzKTtcbn07XG5cbldoaXRlc3BhY2VQYXR0ZXJuLnByb3RvdHlwZS5fX3NwbGl0ID0gZnVuY3Rpb24ocmVnZXhwLCBpbnB1dF9zdHJpbmcpIHtcbiAgcmVnZXhwLmxhc3RJbmRleCA9IDA7XG4gIHZhciBzdGFydF9pbmRleCA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIG5leHRfbWF0Y2ggPSByZWdleHAuZXhlYyhpbnB1dF9zdHJpbmcpO1xuICB3aGlsZSAobmV4dF9tYXRjaCkge1xuICAgIHJlc3VsdC5wdXNoKGlucHV0X3N0cmluZy5zdWJzdHJpbmcoc3RhcnRfaW5kZXgsIG5leHRfbWF0Y2guaW5kZXgpKTtcbiAgICBzdGFydF9pbmRleCA9IG5leHRfbWF0Y2guaW5kZXggKyBuZXh0X21hdGNoWzBdLmxlbmd0aDtcbiAgICBuZXh0X21hdGNoID0gcmVnZXhwLmV4ZWMoaW5wdXRfc3RyaW5nKTtcbiAgfVxuXG4gIGlmIChzdGFydF9pbmRleCA8IGlucHV0X3N0cmluZy5sZW5ndGgpIHtcbiAgICByZXN1bHQucHVzaChpbnB1dF9zdHJpbmcuc3Vic3RyaW5nKHN0YXJ0X2luZGV4LCBpbnB1dF9zdHJpbmcubGVuZ3RoKSk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LnB1c2goJycpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuXG5tb2R1bGUuZXhwb3J0cy5XaGl0ZXNwYWNlUGF0dGVybiA9IFdoaXRlc3BhY2VQYXR0ZXJuO1xuXG5cbi8qKiovIH0pLFxuLyogMTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG5mdW5jdGlvbiBQYXR0ZXJuKGlucHV0X3NjYW5uZXIsIHBhcmVudCkge1xuICB0aGlzLl9pbnB1dCA9IGlucHV0X3NjYW5uZXI7XG4gIHRoaXMuX3N0YXJ0aW5nX3BhdHRlcm4gPSBudWxsO1xuICB0aGlzLl9tYXRjaF9wYXR0ZXJuID0gbnVsbDtcbiAgdGhpcy5fdW50aWxfcGF0dGVybiA9IG51bGw7XG4gIHRoaXMuX3VudGlsX2FmdGVyID0gZmFsc2U7XG5cbiAgaWYgKHBhcmVudCkge1xuICAgIHRoaXMuX3N0YXJ0aW5nX3BhdHRlcm4gPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKHBhcmVudC5fc3RhcnRpbmdfcGF0dGVybiwgdHJ1ZSk7XG4gICAgdGhpcy5fbWF0Y2hfcGF0dGVybiA9IHRoaXMuX2lucHV0LmdldF9yZWdleHAocGFyZW50Ll9tYXRjaF9wYXR0ZXJuLCB0cnVlKTtcbiAgICB0aGlzLl91bnRpbF9wYXR0ZXJuID0gdGhpcy5faW5wdXQuZ2V0X3JlZ2V4cChwYXJlbnQuX3VudGlsX3BhdHRlcm4pO1xuICAgIHRoaXMuX3VudGlsX2FmdGVyID0gcGFyZW50Ll91bnRpbF9hZnRlcjtcbiAgfVxufVxuXG5QYXR0ZXJuLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9pbnB1dC5yZWFkKHRoaXMuX3N0YXJ0aW5nX3BhdHRlcm4pO1xuICBpZiAoIXRoaXMuX3N0YXJ0aW5nX3BhdHRlcm4gfHwgcmVzdWx0KSB7XG4gICAgcmVzdWx0ICs9IHRoaXMuX2lucHV0LnJlYWQodGhpcy5fbWF0Y2hfcGF0dGVybiwgdGhpcy5fdW50aWxfcGF0dGVybiwgdGhpcy5fdW50aWxfYWZ0ZXIpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5QYXR0ZXJuLnByb3RvdHlwZS5yZWFkX21hdGNoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9pbnB1dC5tYXRjaCh0aGlzLl9tYXRjaF9wYXR0ZXJuKTtcbn07XG5cblBhdHRlcm4ucHJvdG90eXBlLnVudGlsX2FmdGVyID0gZnVuY3Rpb24ocGF0dGVybikge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fY3JlYXRlKCk7XG4gIHJlc3VsdC5fdW50aWxfYWZ0ZXIgPSB0cnVlO1xuICByZXN1bHQuX3VudGlsX3BhdHRlcm4gPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKHBhdHRlcm4pO1xuICByZXN1bHQuX3VwZGF0ZSgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuUGF0dGVybi5wcm90b3R5cGUudW50aWwgPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9jcmVhdGUoKTtcbiAgcmVzdWx0Ll91bnRpbF9hZnRlciA9IGZhbHNlO1xuICByZXN1bHQuX3VudGlsX3BhdHRlcm4gPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKHBhdHRlcm4pO1xuICByZXN1bHQuX3VwZGF0ZSgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuUGF0dGVybi5wcm90b3R5cGUuc3RhcnRpbmdfd2l0aCA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuX2NyZWF0ZSgpO1xuICByZXN1bHQuX3N0YXJ0aW5nX3BhdHRlcm4gPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKHBhdHRlcm4sIHRydWUpO1xuICByZXN1bHQuX3VwZGF0ZSgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuUGF0dGVybi5wcm90b3R5cGUubWF0Y2hpbmcgPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9jcmVhdGUoKTtcbiAgcmVzdWx0Ll9tYXRjaF9wYXR0ZXJuID0gdGhpcy5faW5wdXQuZ2V0X3JlZ2V4cChwYXR0ZXJuLCB0cnVlKTtcbiAgcmVzdWx0Ll91cGRhdGUoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblBhdHRlcm4ucHJvdG90eXBlLl9jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBQYXR0ZXJuKHRoaXMuX2lucHV0LCB0aGlzKTtcbn07XG5cblBhdHRlcm4ucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbigpIHt9O1xuXG5tb2R1bGUuZXhwb3J0cy5QYXR0ZXJuID0gUGF0dGVybjtcblxuXG4vKioqLyB9KSxcbi8qIDEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxuZnVuY3Rpb24gRGlyZWN0aXZlcyhzdGFydF9ibG9ja19wYXR0ZXJuLCBlbmRfYmxvY2tfcGF0dGVybikge1xuICBzdGFydF9ibG9ja19wYXR0ZXJuID0gdHlwZW9mIHN0YXJ0X2Jsb2NrX3BhdHRlcm4gPT09ICdzdHJpbmcnID8gc3RhcnRfYmxvY2tfcGF0dGVybiA6IHN0YXJ0X2Jsb2NrX3BhdHRlcm4uc291cmNlO1xuICBlbmRfYmxvY2tfcGF0dGVybiA9IHR5cGVvZiBlbmRfYmxvY2tfcGF0dGVybiA9PT0gJ3N0cmluZycgPyBlbmRfYmxvY2tfcGF0dGVybiA6IGVuZF9ibG9ja19wYXR0ZXJuLnNvdXJjZTtcbiAgdGhpcy5fX2RpcmVjdGl2ZXNfYmxvY2tfcGF0dGVybiA9IG5ldyBSZWdFeHAoc3RhcnRfYmxvY2tfcGF0dGVybiArIC8gYmVhdXRpZnkoIFxcdytbOl1cXHcrKSsgLy5zb3VyY2UgKyBlbmRfYmxvY2tfcGF0dGVybiwgJ2cnKTtcbiAgdGhpcy5fX2RpcmVjdGl2ZV9wYXR0ZXJuID0gLyAoXFx3KylbOl0oXFx3KykvZztcblxuICB0aGlzLl9fZGlyZWN0aXZlc19lbmRfaWdub3JlX3BhdHRlcm4gPSBuZXcgUmVnRXhwKHN0YXJ0X2Jsb2NrX3BhdHRlcm4gKyAvXFxzYmVhdXRpZnlcXHNpZ25vcmU6ZW5kXFxzLy5zb3VyY2UgKyBlbmRfYmxvY2tfcGF0dGVybiwgJ2cnKTtcbn1cblxuRGlyZWN0aXZlcy5wcm90b3R5cGUuZ2V0X2RpcmVjdGl2ZXMgPSBmdW5jdGlvbih0ZXh0KSB7XG4gIGlmICghdGV4dC5tYXRjaCh0aGlzLl9fZGlyZWN0aXZlc19ibG9ja19wYXR0ZXJuKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGRpcmVjdGl2ZXMgPSB7fTtcbiAgdGhpcy5fX2RpcmVjdGl2ZV9wYXR0ZXJuLmxhc3RJbmRleCA9IDA7XG4gIHZhciBkaXJlY3RpdmVfbWF0Y2ggPSB0aGlzLl9fZGlyZWN0aXZlX3BhdHRlcm4uZXhlYyh0ZXh0KTtcblxuICB3aGlsZSAoZGlyZWN0aXZlX21hdGNoKSB7XG4gICAgZGlyZWN0aXZlc1tkaXJlY3RpdmVfbWF0Y2hbMV1dID0gZGlyZWN0aXZlX21hdGNoWzJdO1xuICAgIGRpcmVjdGl2ZV9tYXRjaCA9IHRoaXMuX19kaXJlY3RpdmVfcGF0dGVybi5leGVjKHRleHQpO1xuICB9XG5cbiAgcmV0dXJuIGRpcmVjdGl2ZXM7XG59O1xuXG5EaXJlY3RpdmVzLnByb3RvdHlwZS5yZWFkSWdub3JlZCA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIHJldHVybiBpbnB1dC5yZWFkVW50aWxBZnRlcih0aGlzLl9fZGlyZWN0aXZlc19lbmRfaWdub3JlX3BhdHRlcm4pO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cy5EaXJlY3RpdmVzID0gRGlyZWN0aXZlcztcblxuXG4vKioqLyB9KSxcbi8qIDE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG52YXIgUGF0dGVybiA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKS5QYXR0ZXJuKTtcblxuXG52YXIgdGVtcGxhdGVfbmFtZXMgPSB7XG4gIGRqYW5nbzogZmFsc2UsXG4gIGVyYjogZmFsc2UsXG4gIGhhbmRsZWJhcnM6IGZhbHNlLFxuICBwaHA6IGZhbHNlLFxuICBzbWFydHk6IGZhbHNlLFxuICBhbmd1bGFyOiBmYWxzZVxufTtcblxuLy8gVGhpcyBsZXRzIHRlbXBsYXRlcyBhcHBlYXIgYW55d2hlcmUgd2Ugd291bGQgZG8gYSByZWFkVW50aWxcbi8vIFRoZSBjb3N0IGlzIGhpZ2hlciBidXQgaXQgaXMgcGF5IHRvIHBsYXkuXG5mdW5jdGlvbiBUZW1wbGF0YWJsZVBhdHRlcm4oaW5wdXRfc2Nhbm5lciwgcGFyZW50KSB7XG4gIFBhdHRlcm4uY2FsbCh0aGlzLCBpbnB1dF9zY2FubmVyLCBwYXJlbnQpO1xuICB0aGlzLl9fdGVtcGxhdGVfcGF0dGVybiA9IG51bGw7XG4gIHRoaXMuX2Rpc2FibGVkID0gT2JqZWN0LmFzc2lnbih7fSwgdGVtcGxhdGVfbmFtZXMpO1xuICB0aGlzLl9leGNsdWRlZCA9IE9iamVjdC5hc3NpZ24oe30sIHRlbXBsYXRlX25hbWVzKTtcblxuICBpZiAocGFyZW50KSB7XG4gICAgdGhpcy5fX3RlbXBsYXRlX3BhdHRlcm4gPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKHBhcmVudC5fX3RlbXBsYXRlX3BhdHRlcm4pO1xuICAgIHRoaXMuX2V4Y2x1ZGVkID0gT2JqZWN0LmFzc2lnbih0aGlzLl9leGNsdWRlZCwgcGFyZW50Ll9leGNsdWRlZCk7XG4gICAgdGhpcy5fZGlzYWJsZWQgPSBPYmplY3QuYXNzaWduKHRoaXMuX2Rpc2FibGVkLCBwYXJlbnQuX2Rpc2FibGVkKTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IG5ldyBQYXR0ZXJuKGlucHV0X3NjYW5uZXIpO1xuICB0aGlzLl9fcGF0dGVybnMgPSB7XG4gICAgaGFuZGxlYmFyc19jb21tZW50OiBwYXR0ZXJuLnN0YXJ0aW5nX3dpdGgoL3t7IS0tLykudW50aWxfYWZ0ZXIoLy0tfX0vKSxcbiAgICBoYW5kbGViYXJzX3VuZXNjYXBlZDogcGF0dGVybi5zdGFydGluZ193aXRoKC97e3svKS51bnRpbF9hZnRlcigvfX19LyksXG4gICAgaGFuZGxlYmFyczogcGF0dGVybi5zdGFydGluZ193aXRoKC97ey8pLnVudGlsX2FmdGVyKC99fS8pLFxuICAgIHBocDogcGF0dGVybi5zdGFydGluZ193aXRoKC88XFw/KD86Wz0gXXxwaHApLykudW50aWxfYWZ0ZXIoL1xcPz4vKSxcbiAgICBlcmI6IHBhdHRlcm4uc3RhcnRpbmdfd2l0aCgvPCVbXiVdLykudW50aWxfYWZ0ZXIoL1teJV0lPi8pLFxuICAgIC8vIGRqYW5nbyBjb2ZsaWN0cyB3aXRoIGhhbmRsZWJhcnMgYSBiaXQuXG4gICAgZGphbmdvOiBwYXR0ZXJuLnN0YXJ0aW5nX3dpdGgoL3slLykudW50aWxfYWZ0ZXIoLyV9LyksXG4gICAgZGphbmdvX3ZhbHVlOiBwYXR0ZXJuLnN0YXJ0aW5nX3dpdGgoL3t7LykudW50aWxfYWZ0ZXIoL319LyksXG4gICAgZGphbmdvX2NvbW1lbnQ6IHBhdHRlcm4uc3RhcnRpbmdfd2l0aCgveyMvKS51bnRpbF9hZnRlcigvI30vKSxcbiAgICBzbWFydHk6IHBhdHRlcm4uc3RhcnRpbmdfd2l0aCgveyg/PVtefXtcXHNcXG5dKS8pLnVudGlsX2FmdGVyKC9bXlxcc1xcbl19LyksXG4gICAgc21hcnR5X2NvbW1lbnQ6IHBhdHRlcm4uc3RhcnRpbmdfd2l0aCgve1xcKi8pLnVudGlsX2FmdGVyKC9cXCp9LyksXG4gICAgc21hcnR5X2xpdGVyYWw6IHBhdHRlcm4uc3RhcnRpbmdfd2l0aCgve2xpdGVyYWx9LykudW50aWxfYWZ0ZXIoL3tcXC9saXRlcmFsfS8pXG4gIH07XG59XG5UZW1wbGF0YWJsZVBhdHRlcm4ucHJvdG90eXBlID0gbmV3IFBhdHRlcm4oKTtcblxuVGVtcGxhdGFibGVQYXR0ZXJuLnByb3RvdHlwZS5fY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGVtcGxhdGFibGVQYXR0ZXJuKHRoaXMuX2lucHV0LCB0aGlzKTtcbn07XG5cblRlbXBsYXRhYmxlUGF0dGVybi5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9fc2V0X3RlbXBsYXRlZF9wYXR0ZXJuKCk7XG59O1xuXG5UZW1wbGF0YWJsZVBhdHRlcm4ucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbihsYW5ndWFnZSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fY3JlYXRlKCk7XG4gIHJlc3VsdC5fZGlzYWJsZWRbbGFuZ3VhZ2VdID0gdHJ1ZTtcbiAgcmVzdWx0Ll91cGRhdGUoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblRlbXBsYXRhYmxlUGF0dGVybi5wcm90b3R5cGUucmVhZF9vcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fY3JlYXRlKCk7XG4gIGZvciAodmFyIGxhbmd1YWdlIGluIHRlbXBsYXRlX25hbWVzKSB7XG4gICAgcmVzdWx0Ll9kaXNhYmxlZFtsYW5ndWFnZV0gPSBvcHRpb25zLnRlbXBsYXRpbmcuaW5kZXhPZihsYW5ndWFnZSkgPT09IC0xO1xuICB9XG4gIHJlc3VsdC5fdXBkYXRlKCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5UZW1wbGF0YWJsZVBhdHRlcm4ucHJvdG90eXBlLmV4Y2x1ZGUgPSBmdW5jdGlvbihsYW5ndWFnZSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fY3JlYXRlKCk7XG4gIHJlc3VsdC5fZXhjbHVkZWRbbGFuZ3VhZ2VdID0gdHJ1ZTtcbiAgcmVzdWx0Ll91cGRhdGUoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblRlbXBsYXRhYmxlUGF0dGVybi5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmICh0aGlzLl9tYXRjaF9wYXR0ZXJuKSB7XG4gICAgcmVzdWx0ID0gdGhpcy5faW5wdXQucmVhZCh0aGlzLl9zdGFydGluZ19wYXR0ZXJuKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSB0aGlzLl9pbnB1dC5yZWFkKHRoaXMuX3N0YXJ0aW5nX3BhdHRlcm4sIHRoaXMuX190ZW1wbGF0ZV9wYXR0ZXJuKTtcbiAgfVxuICB2YXIgbmV4dCA9IHRoaXMuX3JlYWRfdGVtcGxhdGUoKTtcbiAgd2hpbGUgKG5leHQpIHtcbiAgICBpZiAodGhpcy5fbWF0Y2hfcGF0dGVybikge1xuICAgICAgbmV4dCArPSB0aGlzLl9pbnB1dC5yZWFkKHRoaXMuX21hdGNoX3BhdHRlcm4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0ICs9IHRoaXMuX2lucHV0LnJlYWRVbnRpbCh0aGlzLl9fdGVtcGxhdGVfcGF0dGVybik7XG4gICAgfVxuICAgIHJlc3VsdCArPSBuZXh0O1xuICAgIG5leHQgPSB0aGlzLl9yZWFkX3RlbXBsYXRlKCk7XG4gIH1cblxuICBpZiAodGhpcy5fdW50aWxfYWZ0ZXIpIHtcbiAgICByZXN1bHQgKz0gdGhpcy5faW5wdXQucmVhZFVudGlsQWZ0ZXIodGhpcy5fdW50aWxfcGF0dGVybik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblRlbXBsYXRhYmxlUGF0dGVybi5wcm90b3R5cGUuX19zZXRfdGVtcGxhdGVkX3BhdHRlcm4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGl0ZW1zID0gW107XG5cbiAgaWYgKCF0aGlzLl9kaXNhYmxlZC5waHApIHtcbiAgICBpdGVtcy5wdXNoKHRoaXMuX19wYXR0ZXJucy5waHAuX3N0YXJ0aW5nX3BhdHRlcm4uc291cmNlKTtcbiAgfVxuICBpZiAoIXRoaXMuX2Rpc2FibGVkLmhhbmRsZWJhcnMpIHtcbiAgICBpdGVtcy5wdXNoKHRoaXMuX19wYXR0ZXJucy5oYW5kbGViYXJzLl9zdGFydGluZ19wYXR0ZXJuLnNvdXJjZSk7XG4gIH1cbiAgaWYgKCF0aGlzLl9kaXNhYmxlZC5lcmIpIHtcbiAgICBpdGVtcy5wdXNoKHRoaXMuX19wYXR0ZXJucy5lcmIuX3N0YXJ0aW5nX3BhdHRlcm4uc291cmNlKTtcbiAgfVxuICBpZiAoIXRoaXMuX2Rpc2FibGVkLmRqYW5nbykge1xuICAgIGl0ZW1zLnB1c2godGhpcy5fX3BhdHRlcm5zLmRqYW5nby5fc3RhcnRpbmdfcGF0dGVybi5zb3VyY2UpO1xuICAgIC8vIFRoZSBzdGFydGluZyBwYXR0ZXJuIGZvciBkamFuZ28gaXMgbW9yZSBjb21wbGV4IGJlY2F1c2UgaXQgaGFzIGRpZmZlcmVudFxuICAgIC8vIHBhdHRlcm5zIGZvciB2YWx1ZSwgY29tbWVudCwgYW5kIG90aGVyIHNlY3Rpb25zXG4gICAgaXRlbXMucHVzaCh0aGlzLl9fcGF0dGVybnMuZGphbmdvX3ZhbHVlLl9zdGFydGluZ19wYXR0ZXJuLnNvdXJjZSk7XG4gICAgaXRlbXMucHVzaCh0aGlzLl9fcGF0dGVybnMuZGphbmdvX2NvbW1lbnQuX3N0YXJ0aW5nX3BhdHRlcm4uc291cmNlKTtcbiAgfVxuICBpZiAoIXRoaXMuX2Rpc2FibGVkLnNtYXJ0eSkge1xuICAgIGl0ZW1zLnB1c2godGhpcy5fX3BhdHRlcm5zLnNtYXJ0eS5fc3RhcnRpbmdfcGF0dGVybi5zb3VyY2UpO1xuICB9XG5cbiAgaWYgKHRoaXMuX3VudGlsX3BhdHRlcm4pIHtcbiAgICBpdGVtcy5wdXNoKHRoaXMuX3VudGlsX3BhdHRlcm4uc291cmNlKTtcbiAgfVxuICB0aGlzLl9fdGVtcGxhdGVfcGF0dGVybiA9IHRoaXMuX2lucHV0LmdldF9yZWdleHAoJyg/OicgKyBpdGVtcy5qb2luKCd8JykgKyAnKScpO1xufTtcblxuVGVtcGxhdGFibGVQYXR0ZXJuLnByb3RvdHlwZS5fcmVhZF90ZW1wbGF0ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzdWx0aW5nX3N0cmluZyA9ICcnO1xuICB2YXIgYyA9IHRoaXMuX2lucHV0LnBlZWsoKTtcbiAgaWYgKGMgPT09ICc8Jykge1xuICAgIHZhciBwZWVrMSA9IHRoaXMuX2lucHV0LnBlZWsoMSk7XG4gICAgLy9pZiB3ZSdyZSBpbiBhIGNvbW1lbnQsIGRvIHNvbWV0aGluZyBzcGVjaWFsXG4gICAgLy8gV2UgdHJlYXQgYWxsIGNvbW1lbnRzIGFzIGxpdGVyYWxzLCBldmVuIG1vcmUgdGhhbiBwcmVmb3JtYXR0ZWQgdGFnc1xuICAgIC8vIHdlIGp1c3QgbG9vayBmb3IgdGhlIGFwcHJvcHJpYXRlIGNsb3NlIHRhZ1xuICAgIGlmICghdGhpcy5fZGlzYWJsZWQucGhwICYmICF0aGlzLl9leGNsdWRlZC5waHAgJiYgcGVlazEgPT09ICc/Jykge1xuICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHJlc3VsdGluZ19zdHJpbmcgfHxcbiAgICAgICAgdGhpcy5fX3BhdHRlcm5zLnBocC5yZWFkKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5fZGlzYWJsZWQuZXJiICYmICF0aGlzLl9leGNsdWRlZC5lcmIgJiYgcGVlazEgPT09ICclJykge1xuICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHJlc3VsdGluZ19zdHJpbmcgfHxcbiAgICAgICAgdGhpcy5fX3BhdHRlcm5zLmVyYi5yZWFkKCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGMgPT09ICd7Jykge1xuICAgIGlmICghdGhpcy5fZGlzYWJsZWQuaGFuZGxlYmFycyAmJiAhdGhpcy5fZXhjbHVkZWQuaGFuZGxlYmFycykge1xuICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHJlc3VsdGluZ19zdHJpbmcgfHxcbiAgICAgICAgdGhpcy5fX3BhdHRlcm5zLmhhbmRsZWJhcnNfY29tbWVudC5yZWFkKCk7XG4gICAgICByZXN1bHRpbmdfc3RyaW5nID0gcmVzdWx0aW5nX3N0cmluZyB8fFxuICAgICAgICB0aGlzLl9fcGF0dGVybnMuaGFuZGxlYmFyc191bmVzY2FwZWQucmVhZCgpO1xuICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHJlc3VsdGluZ19zdHJpbmcgfHxcbiAgICAgICAgdGhpcy5fX3BhdHRlcm5zLmhhbmRsZWJhcnMucmVhZCgpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2Rpc2FibGVkLmRqYW5nbykge1xuICAgICAgLy8gZGphbmdvIGNvZmxpY3RzIHdpdGggaGFuZGxlYmFycyBhIGJpdC5cbiAgICAgIGlmICghdGhpcy5fZXhjbHVkZWQuZGphbmdvICYmICF0aGlzLl9leGNsdWRlZC5oYW5kbGViYXJzKSB7XG4gICAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSByZXN1bHRpbmdfc3RyaW5nIHx8XG4gICAgICAgICAgdGhpcy5fX3BhdHRlcm5zLmRqYW5nb192YWx1ZS5yZWFkKCk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuX2V4Y2x1ZGVkLmRqYW5nbykge1xuICAgICAgICByZXN1bHRpbmdfc3RyaW5nID0gcmVzdWx0aW5nX3N0cmluZyB8fFxuICAgICAgICAgIHRoaXMuX19wYXR0ZXJucy5kamFuZ29fY29tbWVudC5yZWFkKCk7XG4gICAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSByZXN1bHRpbmdfc3RyaW5nIHx8XG4gICAgICAgICAgdGhpcy5fX3BhdHRlcm5zLmRqYW5nby5yZWFkKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy5fZGlzYWJsZWQuc21hcnR5KSB7XG4gICAgICAvLyBzbWFydHkgY2Fubm90IGJlIGVuYWJsZWQgd2l0aCBkamFuZ28gb3IgaGFuZGxlYmFycyBlbmFibGVkXG4gICAgICBpZiAodGhpcy5fZGlzYWJsZWQuZGphbmdvICYmIHRoaXMuX2Rpc2FibGVkLmhhbmRsZWJhcnMpIHtcbiAgICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHJlc3VsdGluZ19zdHJpbmcgfHxcbiAgICAgICAgICB0aGlzLl9fcGF0dGVybnMuc21hcnR5X2NvbW1lbnQucmVhZCgpO1xuICAgICAgICByZXN1bHRpbmdfc3RyaW5nID0gcmVzdWx0aW5nX3N0cmluZyB8fFxuICAgICAgICAgIHRoaXMuX19wYXR0ZXJucy5zbWFydHlfbGl0ZXJhbC5yZWFkKCk7XG4gICAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSByZXN1bHRpbmdfc3RyaW5nIHx8XG4gICAgICAgICAgdGhpcy5fX3BhdHRlcm5zLnNtYXJ0eS5yZWFkKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHRpbmdfc3RyaW5nO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cy5UZW1wbGF0YWJsZVBhdHRlcm4gPSBUZW1wbGF0YWJsZVBhdHRlcm47XG5cblxuLyoqKi8gfSksXG4vKiAxNSAqLyxcbi8qIDE2ICovLFxuLyogMTcgKi8sXG4vKiAxOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxudmFyIEJlYXV0aWZpZXIgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygxOSkuQmVhdXRpZmllciksXG4gIE9wdGlvbnMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygyMCkuT3B0aW9ucyk7XG5cbmZ1bmN0aW9uIHN0eWxlX2h0bWwoaHRtbF9zb3VyY2UsIG9wdGlvbnMsIGpzX2JlYXV0aWZ5LCBjc3NfYmVhdXRpZnkpIHtcbiAgdmFyIGJlYXV0aWZpZXIgPSBuZXcgQmVhdXRpZmllcihodG1sX3NvdXJjZSwgb3B0aW9ucywganNfYmVhdXRpZnksIGNzc19iZWF1dGlmeSk7XG4gIHJldHVybiBiZWF1dGlmaWVyLmJlYXV0aWZ5KCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R5bGVfaHRtbDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgT3B0aW9ucygpO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDE5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG52YXIgT3B0aW9ucyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKS5PcHRpb25zKTtcbnZhciBPdXRwdXQgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygyKS5PdXRwdXQpO1xudmFyIFRva2VuaXplciA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKS5Ub2tlbml6ZXIpO1xudmFyIFRPS0VOID0gKF9fd2VicGFja19yZXF1aXJlX18oMjEpLlRPS0VOKTtcblxudmFyIGxpbmVCcmVhayA9IC9cXHJcXG58W1xcclxcbl0vO1xudmFyIGFsbExpbmVCcmVha3MgPSAvXFxyXFxufFtcXHJcXG5dL2c7XG5cbnZhciBQcmludGVyID0gZnVuY3Rpb24ob3B0aW9ucywgYmFzZV9pbmRlbnRfc3RyaW5nKSB7IC8vaGFuZGxlcyBpbnB1dC9vdXRwdXQgYW5kIHNvbWUgb3RoZXIgcHJpbnRpbmcgZnVuY3Rpb25zXG5cbiAgdGhpcy5pbmRlbnRfbGV2ZWwgPSAwO1xuICB0aGlzLmFsaWdubWVudF9zaXplID0gMDtcbiAgdGhpcy5tYXhfcHJlc2VydmVfbmV3bGluZXMgPSBvcHRpb25zLm1heF9wcmVzZXJ2ZV9uZXdsaW5lcztcbiAgdGhpcy5wcmVzZXJ2ZV9uZXdsaW5lcyA9IG9wdGlvbnMucHJlc2VydmVfbmV3bGluZXM7XG5cbiAgdGhpcy5fb3V0cHV0ID0gbmV3IE91dHB1dChvcHRpb25zLCBiYXNlX2luZGVudF9zdHJpbmcpO1xuXG59O1xuXG5QcmludGVyLnByb3RvdHlwZS5jdXJyZW50X2xpbmVfaGFzX21hdGNoID0gZnVuY3Rpb24ocGF0dGVybikge1xuICByZXR1cm4gdGhpcy5fb3V0cHV0LmN1cnJlbnRfbGluZS5oYXNfbWF0Y2gocGF0dGVybik7XG59O1xuXG5QcmludGVyLnByb3RvdHlwZS5zZXRfc3BhY2VfYmVmb3JlX3Rva2VuID0gZnVuY3Rpb24odmFsdWUsIG5vbl9icmVha2luZykge1xuICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdmFsdWU7XG4gIHRoaXMuX291dHB1dC5ub25fYnJlYWtpbmdfc3BhY2UgPSBub25fYnJlYWtpbmc7XG59O1xuXG5QcmludGVyLnByb3RvdHlwZS5zZXRfd3JhcF9wb2ludCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9vdXRwdXQuc2V0X2luZGVudCh0aGlzLmluZGVudF9sZXZlbCwgdGhpcy5hbGlnbm1lbnRfc2l6ZSk7XG4gIHRoaXMuX291dHB1dC5zZXRfd3JhcF9wb2ludCgpO1xufTtcblxuXG5QcmludGVyLnByb3RvdHlwZS5hZGRfcmF3X3Rva2VuID0gZnVuY3Rpb24odG9rZW4pIHtcbiAgdGhpcy5fb3V0cHV0LmFkZF9yYXdfdG9rZW4odG9rZW4pO1xufTtcblxuUHJpbnRlci5wcm90b3R5cGUucHJpbnRfcHJlc2VydmVkX25ld2xpbmVzID0gZnVuY3Rpb24ocmF3X3Rva2VuKSB7XG4gIHZhciBuZXdsaW5lcyA9IDA7XG4gIGlmIChyYXdfdG9rZW4udHlwZSAhPT0gVE9LRU4uVEVYVCAmJiByYXdfdG9rZW4ucHJldmlvdXMudHlwZSAhPT0gVE9LRU4uVEVYVCkge1xuICAgIG5ld2xpbmVzID0gcmF3X3Rva2VuLm5ld2xpbmVzID8gMSA6IDA7XG4gIH1cblxuICBpZiAodGhpcy5wcmVzZXJ2ZV9uZXdsaW5lcykge1xuICAgIG5ld2xpbmVzID0gcmF3X3Rva2VuLm5ld2xpbmVzIDwgdGhpcy5tYXhfcHJlc2VydmVfbmV3bGluZXMgKyAxID8gcmF3X3Rva2VuLm5ld2xpbmVzIDogdGhpcy5tYXhfcHJlc2VydmVfbmV3bGluZXMgKyAxO1xuICB9XG4gIGZvciAodmFyIG4gPSAwOyBuIDwgbmV3bGluZXM7IG4rKykge1xuICAgIHRoaXMucHJpbnRfbmV3bGluZShuID4gMCk7XG4gIH1cblxuICByZXR1cm4gbmV3bGluZXMgIT09IDA7XG59O1xuXG5QcmludGVyLnByb3RvdHlwZS50cmF2ZXJzZV93aGl0ZXNwYWNlID0gZnVuY3Rpb24ocmF3X3Rva2VuKSB7XG4gIGlmIChyYXdfdG9rZW4ud2hpdGVzcGFjZV9iZWZvcmUgfHwgcmF3X3Rva2VuLm5ld2xpbmVzKSB7XG4gICAgaWYgKCF0aGlzLnByaW50X3ByZXNlcnZlZF9uZXdsaW5lcyhyYXdfdG9rZW4pKSB7XG4gICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuUHJpbnRlci5wcm90b3R5cGUucHJldmlvdXNfdG9rZW5fd3JhcHBlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fb3V0cHV0LnByZXZpb3VzX3Rva2VuX3dyYXBwZWQ7XG59O1xuXG5QcmludGVyLnByb3RvdHlwZS5wcmludF9uZXdsaW5lID0gZnVuY3Rpb24oZm9yY2UpIHtcbiAgdGhpcy5fb3V0cHV0LmFkZF9uZXdfbGluZShmb3JjZSk7XG59O1xuXG5QcmludGVyLnByb3RvdHlwZS5wcmludF90b2tlbiA9IGZ1bmN0aW9uKHRva2VuKSB7XG4gIGlmICh0b2tlbi50ZXh0KSB7XG4gICAgdGhpcy5fb3V0cHV0LnNldF9pbmRlbnQodGhpcy5pbmRlbnRfbGV2ZWwsIHRoaXMuYWxpZ25tZW50X3NpemUpO1xuICAgIHRoaXMuX291dHB1dC5hZGRfdG9rZW4odG9rZW4udGV4dCk7XG4gIH1cbn07XG5cblByaW50ZXIucHJvdG90eXBlLmluZGVudCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmluZGVudF9sZXZlbCsrO1xufTtcblxuUHJpbnRlci5wcm90b3R5cGUuZGVpbmRlbnQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuaW5kZW50X2xldmVsID4gMCkge1xuICAgIHRoaXMuaW5kZW50X2xldmVsLS07XG4gICAgdGhpcy5fb3V0cHV0LnNldF9pbmRlbnQodGhpcy5pbmRlbnRfbGV2ZWwsIHRoaXMuYWxpZ25tZW50X3NpemUpO1xuICB9XG59O1xuXG5QcmludGVyLnByb3RvdHlwZS5nZXRfZnVsbF9pbmRlbnQgPSBmdW5jdGlvbihsZXZlbCkge1xuICBsZXZlbCA9IHRoaXMuaW5kZW50X2xldmVsICsgKGxldmVsIHx8IDApO1xuICBpZiAobGV2ZWwgPCAxKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX291dHB1dC5nZXRfaW5kZW50X3N0cmluZyhsZXZlbCk7XG59O1xuXG52YXIgZ2V0X3R5cGVfYXR0cmlidXRlID0gZnVuY3Rpb24oc3RhcnRfdG9rZW4pIHtcbiAgdmFyIHJlc3VsdCA9IG51bGw7XG4gIHZhciByYXdfdG9rZW4gPSBzdGFydF90b2tlbi5uZXh0O1xuXG4gIC8vIFNlYXJjaCBhdHRyaWJ1dGVzIGZvciBhIHR5cGUgYXR0cmlidXRlXG4gIHdoaWxlIChyYXdfdG9rZW4udHlwZSAhPT0gVE9LRU4uRU9GICYmIHN0YXJ0X3Rva2VuLmNsb3NlZCAhPT0gcmF3X3Rva2VuKSB7XG4gICAgaWYgKHJhd190b2tlbi50eXBlID09PSBUT0tFTi5BVFRSSUJVVEUgJiYgcmF3X3Rva2VuLnRleHQgPT09ICd0eXBlJykge1xuICAgICAgaWYgKHJhd190b2tlbi5uZXh0ICYmIHJhd190b2tlbi5uZXh0LnR5cGUgPT09IFRPS0VOLkVRVUFMUyAmJlxuICAgICAgICByYXdfdG9rZW4ubmV4dC5uZXh0ICYmIHJhd190b2tlbi5uZXh0Lm5leHQudHlwZSA9PT0gVE9LRU4uVkFMVUUpIHtcbiAgICAgICAgcmVzdWx0ID0gcmF3X3Rva2VuLm5leHQubmV4dC50ZXh0O1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJhd190b2tlbiA9IHJhd190b2tlbi5uZXh0O1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBnZXRfY3VzdG9tX2JlYXV0aWZpZXJfbmFtZSA9IGZ1bmN0aW9uKHRhZ19jaGVjaywgcmF3X3Rva2VuKSB7XG4gIHZhciB0eXBlQXR0cmlidXRlID0gbnVsbDtcbiAgdmFyIHJlc3VsdCA9IG51bGw7XG5cbiAgaWYgKCFyYXdfdG9rZW4uY2xvc2VkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAodGFnX2NoZWNrID09PSAnc2NyaXB0Jykge1xuICAgIHR5cGVBdHRyaWJ1dGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgfSBlbHNlIGlmICh0YWdfY2hlY2sgPT09ICdzdHlsZScpIHtcbiAgICB0eXBlQXR0cmlidXRlID0gJ3RleHQvY3NzJztcbiAgfVxuXG4gIHR5cGVBdHRyaWJ1dGUgPSBnZXRfdHlwZV9hdHRyaWJ1dGUocmF3X3Rva2VuKSB8fCB0eXBlQXR0cmlidXRlO1xuXG4gIC8vIEZvciBzY3JpcHQgYW5kIHN0eWxlIHRhZ3MgdGhhdCBoYXZlIGEgdHlwZSBhdHRyaWJ1dGUsIG9ubHkgZW5hYmxlIGN1c3RvbSBiZWF1dGlmaWVycyBmb3IgbWF0Y2hpbmcgdmFsdWVzXG4gIC8vIEZvciB0aG9zZSB3aXRob3V0IGEgdHlwZSBhdHRyaWJ1dGUgdXNlIGRlZmF1bHQ7XG4gIGlmICh0eXBlQXR0cmlidXRlLnNlYXJjaCgndGV4dC9jc3MnKSA+IC0xKSB7XG4gICAgcmVzdWx0ID0gJ2Nzcyc7XG4gIH0gZWxzZSBpZiAodHlwZUF0dHJpYnV0ZS5zZWFyY2goL21vZHVsZXwoKHRleHR8YXBwbGljYXRpb258ZG9qbylcXC8oeC0pPyhqYXZhc2NyaXB0fGVjbWFzY3JpcHR8anNjcmlwdHxsaXZlc2NyaXB0fChsZFxcKyk/anNvbnxtZXRob2R8YXNwZWN0KSkvKSA+IC0xKSB7XG4gICAgcmVzdWx0ID0gJ2phdmFzY3JpcHQnO1xuICB9IGVsc2UgaWYgKHR5cGVBdHRyaWJ1dGUuc2VhcmNoKC8odGV4dHxhcHBsaWNhdGlvbnxkb2pvKVxcLyh4LSk/KGh0bWwpLykgPiAtMSkge1xuICAgIHJlc3VsdCA9ICdodG1sJztcbiAgfSBlbHNlIGlmICh0eXBlQXR0cmlidXRlLnNlYXJjaCgvdGVzdFxcL251bGwvKSA+IC0xKSB7XG4gICAgLy8gVGVzdCBvbmx5IG1pbWUtdHlwZSBmb3IgdGVzdGluZyB0aGUgYmVhdXRpZmllciB3aGVuIG51bGwgaXMgcGFzc2VkIGFzIGJlYXV0aWZpbmcgZnVuY3Rpb25cbiAgICByZXN1bHQgPSAnbnVsbCc7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZnVuY3Rpb24gaW5fYXJyYXkod2hhdCwgYXJyKSB7XG4gIHJldHVybiBhcnIuaW5kZXhPZih3aGF0KSAhPT0gLTE7XG59XG5cbmZ1bmN0aW9uIFRhZ0ZyYW1lKHBhcmVudCwgcGFyc2VyX3Rva2VuLCBpbmRlbnRfbGV2ZWwpIHtcbiAgdGhpcy5wYXJlbnQgPSBwYXJlbnQgfHwgbnVsbDtcbiAgdGhpcy50YWcgPSBwYXJzZXJfdG9rZW4gPyBwYXJzZXJfdG9rZW4udGFnX25hbWUgOiAnJztcbiAgdGhpcy5pbmRlbnRfbGV2ZWwgPSBpbmRlbnRfbGV2ZWwgfHwgMDtcbiAgdGhpcy5wYXJzZXJfdG9rZW4gPSBwYXJzZXJfdG9rZW4gfHwgbnVsbDtcbn1cblxuZnVuY3Rpb24gVGFnU3RhY2socHJpbnRlcikge1xuICB0aGlzLl9wcmludGVyID0gcHJpbnRlcjtcbiAgdGhpcy5fY3VycmVudF9mcmFtZSA9IG51bGw7XG59XG5cblRhZ1N0YWNrLnByb3RvdHlwZS5nZXRfcGFyc2VyX3Rva2VuID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9jdXJyZW50X2ZyYW1lID8gdGhpcy5fY3VycmVudF9mcmFtZS5wYXJzZXJfdG9rZW4gOiBudWxsO1xufTtcblxuVGFnU3RhY2sucHJvdG90eXBlLnJlY29yZF90YWcgPSBmdW5jdGlvbihwYXJzZXJfdG9rZW4pIHsgLy9mdW5jdGlvbiB0byByZWNvcmQgYSB0YWcgYW5kIGl0cyBwYXJlbnQgaW4gdGhpcy50YWdzIE9iamVjdFxuICB2YXIgbmV3X2ZyYW1lID0gbmV3IFRhZ0ZyYW1lKHRoaXMuX2N1cnJlbnRfZnJhbWUsIHBhcnNlcl90b2tlbiwgdGhpcy5fcHJpbnRlci5pbmRlbnRfbGV2ZWwpO1xuICB0aGlzLl9jdXJyZW50X2ZyYW1lID0gbmV3X2ZyYW1lO1xufTtcblxuVGFnU3RhY2sucHJvdG90eXBlLl90cnlfcG9wX2ZyYW1lID0gZnVuY3Rpb24oZnJhbWUpIHsgLy9mdW5jdGlvbiB0byByZXRyaWV2ZSB0aGUgb3BlbmluZyB0YWcgdG8gdGhlIGNvcnJlc3BvbmRpbmcgY2xvc2VyXG4gIHZhciBwYXJzZXJfdG9rZW4gPSBudWxsO1xuXG4gIGlmIChmcmFtZSkge1xuICAgIHBhcnNlcl90b2tlbiA9IGZyYW1lLnBhcnNlcl90b2tlbjtcbiAgICB0aGlzLl9wcmludGVyLmluZGVudF9sZXZlbCA9IGZyYW1lLmluZGVudF9sZXZlbDtcbiAgICB0aGlzLl9jdXJyZW50X2ZyYW1lID0gZnJhbWUucGFyZW50O1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlcl90b2tlbjtcbn07XG5cblRhZ1N0YWNrLnByb3RvdHlwZS5fZ2V0X2ZyYW1lID0gZnVuY3Rpb24odGFnX2xpc3QsIHN0b3BfbGlzdCkgeyAvL2Z1bmN0aW9uIHRvIHJldHJpZXZlIHRoZSBvcGVuaW5nIHRhZyB0byB0aGUgY29ycmVzcG9uZGluZyBjbG9zZXJcbiAgdmFyIGZyYW1lID0gdGhpcy5fY3VycmVudF9mcmFtZTtcblxuICB3aGlsZSAoZnJhbWUpIHsgLy90aWxsIHdlIHJlYWNoICcnICh0aGUgaW5pdGlhbCB2YWx1ZSk7XG4gICAgaWYgKHRhZ19saXN0LmluZGV4T2YoZnJhbWUudGFnKSAhPT0gLTEpIHsgLy9pZiB0aGlzIGlzIGl0IHVzZSBpdFxuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIGlmIChzdG9wX2xpc3QgJiYgc3RvcF9saXN0LmluZGV4T2YoZnJhbWUudGFnKSAhPT0gLTEpIHtcbiAgICAgIGZyYW1lID0gbnVsbDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBmcmFtZSA9IGZyYW1lLnBhcmVudDtcbiAgfVxuXG4gIHJldHVybiBmcmFtZTtcbn07XG5cblRhZ1N0YWNrLnByb3RvdHlwZS50cnlfcG9wID0gZnVuY3Rpb24odGFnLCBzdG9wX2xpc3QpIHsgLy9mdW5jdGlvbiB0byByZXRyaWV2ZSB0aGUgb3BlbmluZyB0YWcgdG8gdGhlIGNvcnJlc3BvbmRpbmcgY2xvc2VyXG4gIHZhciBmcmFtZSA9IHRoaXMuX2dldF9mcmFtZShbdGFnXSwgc3RvcF9saXN0KTtcbiAgcmV0dXJuIHRoaXMuX3RyeV9wb3BfZnJhbWUoZnJhbWUpO1xufTtcblxuVGFnU3RhY2sucHJvdG90eXBlLmluZGVudF90b190YWcgPSBmdW5jdGlvbih0YWdfbGlzdCkge1xuICB2YXIgZnJhbWUgPSB0aGlzLl9nZXRfZnJhbWUodGFnX2xpc3QpO1xuICBpZiAoZnJhbWUpIHtcbiAgICB0aGlzLl9wcmludGVyLmluZGVudF9sZXZlbCA9IGZyYW1lLmluZGVudF9sZXZlbDtcbiAgfVxufTtcblxuZnVuY3Rpb24gQmVhdXRpZmllcihzb3VyY2VfdGV4dCwgb3B0aW9ucywganNfYmVhdXRpZnksIGNzc19iZWF1dGlmeSkge1xuICAvL1dyYXBwZXIgZnVuY3Rpb24gdG8gaW52b2tlIGFsbCB0aGUgbmVjZXNzYXJ5IGNvbnN0cnVjdG9ycyBhbmQgZGVhbCB3aXRoIHRoZSBvdXRwdXQuXG4gIHRoaXMuX3NvdXJjZV90ZXh0ID0gc291cmNlX3RleHQgfHwgJyc7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLl9qc19iZWF1dGlmeSA9IGpzX2JlYXV0aWZ5O1xuICB0aGlzLl9jc3NfYmVhdXRpZnkgPSBjc3NfYmVhdXRpZnk7XG4gIHRoaXMuX3RhZ19zdGFjayA9IG51bGw7XG5cbiAgLy8gQWxsb3cgdGhlIHNldHRpbmcgb2YgbGFuZ3VhZ2UvZmlsZS10eXBlIHNwZWNpZmljIG9wdGlvbnNcbiAgLy8gd2l0aCBpbmhlcml0YW5jZSBvZiBvdmVyYWxsIHNldHRpbmdzXG4gIHZhciBvcHRpb25IdG1sID0gbmV3IE9wdGlvbnMob3B0aW9ucywgJ2h0bWwnKTtcblxuICB0aGlzLl9vcHRpb25zID0gb3B0aW9uSHRtbDtcblxuICB0aGlzLl9pc193cmFwX2F0dHJpYnV0ZXNfZm9yY2UgPSB0aGlzLl9vcHRpb25zLndyYXBfYXR0cmlidXRlcy5zdWJzdHIoMCwgJ2ZvcmNlJy5sZW5ndGgpID09PSAnZm9yY2UnO1xuICB0aGlzLl9pc193cmFwX2F0dHJpYnV0ZXNfZm9yY2VfZXhwYW5kX211bHRpbGluZSA9ICh0aGlzLl9vcHRpb25zLndyYXBfYXR0cmlidXRlcyA9PT0gJ2ZvcmNlLWV4cGFuZC1tdWx0aWxpbmUnKTtcbiAgdGhpcy5faXNfd3JhcF9hdHRyaWJ1dGVzX2ZvcmNlX2FsaWduZWQgPSAodGhpcy5fb3B0aW9ucy53cmFwX2F0dHJpYnV0ZXMgPT09ICdmb3JjZS1hbGlnbmVkJyk7XG4gIHRoaXMuX2lzX3dyYXBfYXR0cmlidXRlc19hbGlnbmVkX211bHRpcGxlID0gKHRoaXMuX29wdGlvbnMud3JhcF9hdHRyaWJ1dGVzID09PSAnYWxpZ25lZC1tdWx0aXBsZScpO1xuICB0aGlzLl9pc193cmFwX2F0dHJpYnV0ZXNfcHJlc2VydmUgPSB0aGlzLl9vcHRpb25zLndyYXBfYXR0cmlidXRlcy5zdWJzdHIoMCwgJ3ByZXNlcnZlJy5sZW5ndGgpID09PSAncHJlc2VydmUnO1xuICB0aGlzLl9pc193cmFwX2F0dHJpYnV0ZXNfcHJlc2VydmVfYWxpZ25lZCA9ICh0aGlzLl9vcHRpb25zLndyYXBfYXR0cmlidXRlcyA9PT0gJ3ByZXNlcnZlLWFsaWduZWQnKTtcbn1cblxuQmVhdXRpZmllci5wcm90b3R5cGUuYmVhdXRpZnkgPSBmdW5jdGlvbigpIHtcblxuICAvLyBpZiBkaXNhYmxlZCwgcmV0dXJuIHRoZSBpbnB1dCB1bmNoYW5nZWQuXG4gIGlmICh0aGlzLl9vcHRpb25zLmRpc2FibGVkKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NvdXJjZV90ZXh0O1xuICB9XG5cbiAgdmFyIHNvdXJjZV90ZXh0ID0gdGhpcy5fc291cmNlX3RleHQ7XG4gIHZhciBlb2wgPSB0aGlzLl9vcHRpb25zLmVvbDtcbiAgaWYgKHRoaXMuX29wdGlvbnMuZW9sID09PSAnYXV0bycpIHtcbiAgICBlb2wgPSAnXFxuJztcbiAgICBpZiAoc291cmNlX3RleHQgJiYgbGluZUJyZWFrLnRlc3Qoc291cmNlX3RleHQpKSB7XG4gICAgICBlb2wgPSBzb3VyY2VfdGV4dC5tYXRjaChsaW5lQnJlYWspWzBdO1xuICAgIH1cbiAgfVxuXG4gIC8vIEhBQ0s6IG5ld2xpbmUgcGFyc2luZyBpbmNvbnNpc3RlbnQuIFRoaXMgYnJ1dGUgZm9yY2Ugbm9ybWFsaXplcyB0aGUgaW5wdXQuXG4gIHNvdXJjZV90ZXh0ID0gc291cmNlX3RleHQucmVwbGFjZShhbGxMaW5lQnJlYWtzLCAnXFxuJyk7XG5cbiAgdmFyIGJhc2VJbmRlbnRTdHJpbmcgPSBzb3VyY2VfdGV4dC5tYXRjaCgvXltcXHQgXSovKVswXTtcblxuICB2YXIgbGFzdF90b2tlbiA9IHtcbiAgICB0ZXh0OiAnJyxcbiAgICB0eXBlOiAnJ1xuICB9O1xuXG4gIHZhciBsYXN0X3RhZ190b2tlbiA9IG5ldyBUYWdPcGVuUGFyc2VyVG9rZW4oKTtcblxuICB2YXIgcHJpbnRlciA9IG5ldyBQcmludGVyKHRoaXMuX29wdGlvbnMsIGJhc2VJbmRlbnRTdHJpbmcpO1xuICB2YXIgdG9rZW5zID0gbmV3IFRva2VuaXplcihzb3VyY2VfdGV4dCwgdGhpcy5fb3B0aW9ucykudG9rZW5pemUoKTtcblxuICB0aGlzLl90YWdfc3RhY2sgPSBuZXcgVGFnU3RhY2socHJpbnRlcik7XG5cbiAgdmFyIHBhcnNlcl90b2tlbiA9IG51bGw7XG4gIHZhciByYXdfdG9rZW4gPSB0b2tlbnMubmV4dCgpO1xuICB3aGlsZSAocmF3X3Rva2VuLnR5cGUgIT09IFRPS0VOLkVPRikge1xuXG4gICAgaWYgKHJhd190b2tlbi50eXBlID09PSBUT0tFTi5UQUdfT1BFTiB8fCByYXdfdG9rZW4udHlwZSA9PT0gVE9LRU4uQ09NTUVOVCkge1xuICAgICAgcGFyc2VyX3Rva2VuID0gdGhpcy5faGFuZGxlX3RhZ19vcGVuKHByaW50ZXIsIHJhd190b2tlbiwgbGFzdF90YWdfdG9rZW4sIGxhc3RfdG9rZW4sIHRva2Vucyk7XG4gICAgICBsYXN0X3RhZ190b2tlbiA9IHBhcnNlcl90b2tlbjtcbiAgICB9IGVsc2UgaWYgKChyYXdfdG9rZW4udHlwZSA9PT0gVE9LRU4uQVRUUklCVVRFIHx8IHJhd190b2tlbi50eXBlID09PSBUT0tFTi5FUVVBTFMgfHwgcmF3X3Rva2VuLnR5cGUgPT09IFRPS0VOLlZBTFVFKSB8fFxuICAgICAgKHJhd190b2tlbi50eXBlID09PSBUT0tFTi5URVhUICYmICFsYXN0X3RhZ190b2tlbi50YWdfY29tcGxldGUpKSB7XG4gICAgICBwYXJzZXJfdG9rZW4gPSB0aGlzLl9oYW5kbGVfaW5zaWRlX3RhZyhwcmludGVyLCByYXdfdG9rZW4sIGxhc3RfdGFnX3Rva2VuLCBsYXN0X3Rva2VuKTtcbiAgICB9IGVsc2UgaWYgKHJhd190b2tlbi50eXBlID09PSBUT0tFTi5UQUdfQ0xPU0UpIHtcbiAgICAgIHBhcnNlcl90b2tlbiA9IHRoaXMuX2hhbmRsZV90YWdfY2xvc2UocHJpbnRlciwgcmF3X3Rva2VuLCBsYXN0X3RhZ190b2tlbik7XG4gICAgfSBlbHNlIGlmIChyYXdfdG9rZW4udHlwZSA9PT0gVE9LRU4uVEVYVCkge1xuICAgICAgcGFyc2VyX3Rva2VuID0gdGhpcy5faGFuZGxlX3RleHQocHJpbnRlciwgcmF3X3Rva2VuLCBsYXN0X3RhZ190b2tlbik7XG4gICAgfSBlbHNlIGlmIChyYXdfdG9rZW4udHlwZSA9PT0gVE9LRU4uQ09OVFJPTF9GTE9XX09QRU4pIHtcbiAgICAgIHBhcnNlcl90b2tlbiA9IHRoaXMuX2hhbmRsZV9jb250cm9sX2Zsb3dfb3BlbihwcmludGVyLCByYXdfdG9rZW4pO1xuICAgIH0gZWxzZSBpZiAocmF3X3Rva2VuLnR5cGUgPT09IFRPS0VOLkNPTlRST0xfRkxPV19DTE9TRSkge1xuICAgICAgcGFyc2VyX3Rva2VuID0gdGhpcy5faGFuZGxlX2NvbnRyb2xfZmxvd19jbG9zZShwcmludGVyLCByYXdfdG9rZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4sIGJ1dCBpZiBpdCBkb2VzLiBQcmludCB0aGUgcmF3IHRva2VuXG4gICAgICBwcmludGVyLmFkZF9yYXdfdG9rZW4ocmF3X3Rva2VuKTtcbiAgICB9XG5cbiAgICBsYXN0X3Rva2VuID0gcGFyc2VyX3Rva2VuO1xuXG4gICAgcmF3X3Rva2VuID0gdG9rZW5zLm5leHQoKTtcbiAgfVxuICB2YXIgc3dlZXRfY29kZSA9IHByaW50ZXIuX291dHB1dC5nZXRfY29kZShlb2wpO1xuXG4gIHJldHVybiBzd2VldF9jb2RlO1xufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuX2hhbmRsZV9jb250cm9sX2Zsb3dfb3BlbiA9IGZ1bmN0aW9uKHByaW50ZXIsIHJhd190b2tlbikge1xuICB2YXIgcGFyc2VyX3Rva2VuID0ge1xuICAgIHRleHQ6IHJhd190b2tlbi50ZXh0LFxuICAgIHR5cGU6IHJhd190b2tlbi50eXBlXG4gIH07XG4gIHByaW50ZXIuc2V0X3NwYWNlX2JlZm9yZV90b2tlbihyYXdfdG9rZW4ubmV3bGluZXMgfHwgcmF3X3Rva2VuLndoaXRlc3BhY2VfYmVmb3JlICE9PSAnJywgdHJ1ZSk7XG4gIGlmIChyYXdfdG9rZW4ubmV3bGluZXMpIHtcbiAgICBwcmludGVyLnByaW50X3ByZXNlcnZlZF9uZXdsaW5lcyhyYXdfdG9rZW4pO1xuICB9IGVsc2Uge1xuICAgIHByaW50ZXIuc2V0X3NwYWNlX2JlZm9yZV90b2tlbihyYXdfdG9rZW4ubmV3bGluZXMgfHwgcmF3X3Rva2VuLndoaXRlc3BhY2VfYmVmb3JlICE9PSAnJywgdHJ1ZSk7XG4gIH1cbiAgcHJpbnRlci5wcmludF90b2tlbihyYXdfdG9rZW4pO1xuICBwcmludGVyLmluZGVudCgpO1xuICByZXR1cm4gcGFyc2VyX3Rva2VuO1xufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuX2hhbmRsZV9jb250cm9sX2Zsb3dfY2xvc2UgPSBmdW5jdGlvbihwcmludGVyLCByYXdfdG9rZW4pIHtcbiAgdmFyIHBhcnNlcl90b2tlbiA9IHtcbiAgICB0ZXh0OiByYXdfdG9rZW4udGV4dCxcbiAgICB0eXBlOiByYXdfdG9rZW4udHlwZVxuICB9O1xuXG4gIHByaW50ZXIuZGVpbmRlbnQoKTtcbiAgaWYgKHJhd190b2tlbi5uZXdsaW5lcykge1xuICAgIHByaW50ZXIucHJpbnRfcHJlc2VydmVkX25ld2xpbmVzKHJhd190b2tlbik7XG4gIH0gZWxzZSB7XG4gICAgcHJpbnRlci5zZXRfc3BhY2VfYmVmb3JlX3Rva2VuKHJhd190b2tlbi5uZXdsaW5lcyB8fCByYXdfdG9rZW4ud2hpdGVzcGFjZV9iZWZvcmUgIT09ICcnLCB0cnVlKTtcbiAgfVxuICBwcmludGVyLnByaW50X3Rva2VuKHJhd190b2tlbik7XG4gIHJldHVybiBwYXJzZXJfdG9rZW47XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5faGFuZGxlX3RhZ19jbG9zZSA9IGZ1bmN0aW9uKHByaW50ZXIsIHJhd190b2tlbiwgbGFzdF90YWdfdG9rZW4pIHtcbiAgdmFyIHBhcnNlcl90b2tlbiA9IHtcbiAgICB0ZXh0OiByYXdfdG9rZW4udGV4dCxcbiAgICB0eXBlOiByYXdfdG9rZW4udHlwZVxuICB9O1xuICBwcmludGVyLmFsaWdubWVudF9zaXplID0gMDtcbiAgbGFzdF90YWdfdG9rZW4udGFnX2NvbXBsZXRlID0gdHJ1ZTtcblxuICBwcmludGVyLnNldF9zcGFjZV9iZWZvcmVfdG9rZW4ocmF3X3Rva2VuLm5ld2xpbmVzIHx8IHJhd190b2tlbi53aGl0ZXNwYWNlX2JlZm9yZSAhPT0gJycsIHRydWUpO1xuICBpZiAobGFzdF90YWdfdG9rZW4uaXNfdW5mb3JtYXR0ZWQpIHtcbiAgICBwcmludGVyLmFkZF9yYXdfdG9rZW4ocmF3X3Rva2VuKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAobGFzdF90YWdfdG9rZW4udGFnX3N0YXJ0X2NoYXIgPT09ICc8Jykge1xuICAgICAgcHJpbnRlci5zZXRfc3BhY2VfYmVmb3JlX3Rva2VuKHJhd190b2tlbi50ZXh0WzBdID09PSAnLycsIHRydWUpOyAvLyBzcGFjZSBiZWZvcmUgLz4sIG5vIHNwYWNlIGJlZm9yZSA+XG4gICAgICBpZiAodGhpcy5faXNfd3JhcF9hdHRyaWJ1dGVzX2ZvcmNlX2V4cGFuZF9tdWx0aWxpbmUgJiYgbGFzdF90YWdfdG9rZW4uaGFzX3dyYXBwZWRfYXR0cnMpIHtcbiAgICAgICAgcHJpbnRlci5wcmludF9uZXdsaW5lKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcHJpbnRlci5wcmludF90b2tlbihyYXdfdG9rZW4pO1xuXG4gIH1cblxuICBpZiAobGFzdF90YWdfdG9rZW4uaW5kZW50X2NvbnRlbnQgJiZcbiAgICAhKGxhc3RfdGFnX3Rva2VuLmlzX3VuZm9ybWF0dGVkIHx8IGxhc3RfdGFnX3Rva2VuLmlzX2NvbnRlbnRfdW5mb3JtYXR0ZWQpKSB7XG4gICAgcHJpbnRlci5pbmRlbnQoKTtcblxuICAgIC8vIG9ubHkgaW5kZW50IG9uY2UgcGVyIG9wZW5lZCB0YWdcbiAgICBsYXN0X3RhZ190b2tlbi5pbmRlbnRfY29udGVudCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKCFsYXN0X3RhZ190b2tlbi5pc19pbmxpbmVfZWxlbWVudCAmJlxuICAgICEobGFzdF90YWdfdG9rZW4uaXNfdW5mb3JtYXR0ZWQgfHwgbGFzdF90YWdfdG9rZW4uaXNfY29udGVudF91bmZvcm1hdHRlZCkpIHtcbiAgICBwcmludGVyLnNldF93cmFwX3BvaW50KCk7XG4gIH1cblxuICByZXR1cm4gcGFyc2VyX3Rva2VuO1xufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuX2hhbmRsZV9pbnNpZGVfdGFnID0gZnVuY3Rpb24ocHJpbnRlciwgcmF3X3Rva2VuLCBsYXN0X3RhZ190b2tlbiwgbGFzdF90b2tlbikge1xuICB2YXIgd3JhcHBlZCA9IGxhc3RfdGFnX3Rva2VuLmhhc193cmFwcGVkX2F0dHJzO1xuICB2YXIgcGFyc2VyX3Rva2VuID0ge1xuICAgIHRleHQ6IHJhd190b2tlbi50ZXh0LFxuICAgIHR5cGU6IHJhd190b2tlbi50eXBlXG4gIH07XG5cbiAgcHJpbnRlci5zZXRfc3BhY2VfYmVmb3JlX3Rva2VuKHJhd190b2tlbi5uZXdsaW5lcyB8fCByYXdfdG9rZW4ud2hpdGVzcGFjZV9iZWZvcmUgIT09ICcnLCB0cnVlKTtcbiAgaWYgKGxhc3RfdGFnX3Rva2VuLmlzX3VuZm9ybWF0dGVkKSB7XG4gICAgcHJpbnRlci5hZGRfcmF3X3Rva2VuKHJhd190b2tlbik7XG4gIH0gZWxzZSBpZiAobGFzdF90YWdfdG9rZW4udGFnX3N0YXJ0X2NoYXIgPT09ICd7JyAmJiByYXdfdG9rZW4udHlwZSA9PT0gVE9LRU4uVEVYVCkge1xuICAgIC8vIEZvciB0aGUgaW5zaWRlcyBvZiBoYW5kbGViYXJzIGFsbG93IG5ld2xpbmVzIG9yIGEgc2luZ2xlIHNwYWNlIGJldHdlZW4gb3BlbiBhbmQgY29udGVudHNcbiAgICBpZiAocHJpbnRlci5wcmludF9wcmVzZXJ2ZWRfbmV3bGluZXMocmF3X3Rva2VuKSkge1xuICAgICAgcmF3X3Rva2VuLm5ld2xpbmVzID0gMDtcbiAgICAgIHByaW50ZXIuYWRkX3Jhd190b2tlbihyYXdfdG9rZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmludGVyLnByaW50X3Rva2VuKHJhd190b2tlbik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChyYXdfdG9rZW4udHlwZSA9PT0gVE9LRU4uQVRUUklCVVRFKSB7XG4gICAgICBwcmludGVyLnNldF9zcGFjZV9iZWZvcmVfdG9rZW4odHJ1ZSk7XG4gICAgfSBlbHNlIGlmIChyYXdfdG9rZW4udHlwZSA9PT0gVE9LRU4uRVFVQUxTKSB7IC8vbm8gc3BhY2UgYmVmb3JlID1cbiAgICAgIHByaW50ZXIuc2V0X3NwYWNlX2JlZm9yZV90b2tlbihmYWxzZSk7XG4gICAgfSBlbHNlIGlmIChyYXdfdG9rZW4udHlwZSA9PT0gVE9LRU4uVkFMVUUgJiYgcmF3X3Rva2VuLnByZXZpb3VzLnR5cGUgPT09IFRPS0VOLkVRVUFMUykgeyAvL25vIHNwYWNlIGJlZm9yZSB2YWx1ZVxuICAgICAgcHJpbnRlci5zZXRfc3BhY2VfYmVmb3JlX3Rva2VuKGZhbHNlKTtcbiAgICB9XG5cbiAgICBpZiAocmF3X3Rva2VuLnR5cGUgPT09IFRPS0VOLkFUVFJJQlVURSAmJiBsYXN0X3RhZ190b2tlbi50YWdfc3RhcnRfY2hhciA9PT0gJzwnKSB7XG4gICAgICBpZiAodGhpcy5faXNfd3JhcF9hdHRyaWJ1dGVzX3ByZXNlcnZlIHx8IHRoaXMuX2lzX3dyYXBfYXR0cmlidXRlc19wcmVzZXJ2ZV9hbGlnbmVkKSB7XG4gICAgICAgIHByaW50ZXIudHJhdmVyc2Vfd2hpdGVzcGFjZShyYXdfdG9rZW4pO1xuICAgICAgICB3cmFwcGVkID0gd3JhcHBlZCB8fCByYXdfdG9rZW4ubmV3bGluZXMgIT09IDA7XG4gICAgICB9XG5cbiAgICAgIC8vIFdyYXAgZm9yICdmb3JjZScgb3B0aW9ucywgYW5kIGlmIHRoZSBudW1iZXIgb2YgYXR0cmlidXRlcyBpcyBhdCBsZWFzdCB0aGF0IHNwZWNpZmllZCBpbiAnd3JhcF9hdHRyaWJ1dGVzX21pbl9hdHRycyc6XG4gICAgICAvLyAxLiBhbHdheXMgd3JhcCB0aGUgc2Vjb25kIGFuZCBiZXlvbmQgYXR0cmlidXRlc1xuICAgICAgLy8gMi4gd3JhcCB0aGUgZmlyc3QgYXR0cmlidXRlIG9ubHkgaWYgJ2ZvcmNlLWV4cGFuZC1tdWx0aWxpbmUnIGlzIHNwZWNpZmllZFxuICAgICAgaWYgKHRoaXMuX2lzX3dyYXBfYXR0cmlidXRlc19mb3JjZSAmJlxuICAgICAgICBsYXN0X3RhZ190b2tlbi5hdHRyX2NvdW50ID49IHRoaXMuX29wdGlvbnMud3JhcF9hdHRyaWJ1dGVzX21pbl9hdHRycyAmJlxuICAgICAgICAobGFzdF90b2tlbi50eXBlICE9PSBUT0tFTi5UQUdfT1BFTiB8fCAvLyBpZS4gc2Vjb25kIGF0dHJpYnV0ZSBhbmQgYmV5b25kXG4gICAgICAgICAgdGhpcy5faXNfd3JhcF9hdHRyaWJ1dGVzX2ZvcmNlX2V4cGFuZF9tdWx0aWxpbmUpKSB7XG4gICAgICAgIHByaW50ZXIucHJpbnRfbmV3bGluZShmYWxzZSk7XG4gICAgICAgIHdyYXBwZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBwcmludGVyLnByaW50X3Rva2VuKHJhd190b2tlbik7XG4gICAgd3JhcHBlZCA9IHdyYXBwZWQgfHwgcHJpbnRlci5wcmV2aW91c190b2tlbl93cmFwcGVkKCk7XG4gICAgbGFzdF90YWdfdG9rZW4uaGFzX3dyYXBwZWRfYXR0cnMgPSB3cmFwcGVkO1xuICB9XG4gIHJldHVybiBwYXJzZXJfdG9rZW47XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5faGFuZGxlX3RleHQgPSBmdW5jdGlvbihwcmludGVyLCByYXdfdG9rZW4sIGxhc3RfdGFnX3Rva2VuKSB7XG4gIHZhciBwYXJzZXJfdG9rZW4gPSB7XG4gICAgdGV4dDogcmF3X3Rva2VuLnRleHQsXG4gICAgdHlwZTogJ1RLX0NPTlRFTlQnXG4gIH07XG4gIGlmIChsYXN0X3RhZ190b2tlbi5jdXN0b21fYmVhdXRpZmllcl9uYW1lKSB7IC8vY2hlY2sgaWYgd2UgbmVlZCB0byBmb3JtYXQgamF2YXNjcmlwdFxuICAgIHRoaXMuX3ByaW50X2N1c3RvbV9iZWF0aWZpZXJfdGV4dChwcmludGVyLCByYXdfdG9rZW4sIGxhc3RfdGFnX3Rva2VuKTtcbiAgfSBlbHNlIGlmIChsYXN0X3RhZ190b2tlbi5pc191bmZvcm1hdHRlZCB8fCBsYXN0X3RhZ190b2tlbi5pc19jb250ZW50X3VuZm9ybWF0dGVkKSB7XG4gICAgcHJpbnRlci5hZGRfcmF3X3Rva2VuKHJhd190b2tlbik7XG4gIH0gZWxzZSB7XG4gICAgcHJpbnRlci50cmF2ZXJzZV93aGl0ZXNwYWNlKHJhd190b2tlbik7XG4gICAgcHJpbnRlci5wcmludF90b2tlbihyYXdfdG9rZW4pO1xuICB9XG4gIHJldHVybiBwYXJzZXJfdG9rZW47XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5fcHJpbnRfY3VzdG9tX2JlYXRpZmllcl90ZXh0ID0gZnVuY3Rpb24ocHJpbnRlciwgcmF3X3Rva2VuLCBsYXN0X3RhZ190b2tlbikge1xuICB2YXIgbG9jYWwgPSB0aGlzO1xuICBpZiAocmF3X3Rva2VuLnRleHQgIT09ICcnKSB7XG5cbiAgICB2YXIgdGV4dCA9IHJhd190b2tlbi50ZXh0LFxuICAgICAgX2JlYXV0aWZpZXIsXG4gICAgICBzY3JpcHRfaW5kZW50X2xldmVsID0gMSxcbiAgICAgIHByZSA9ICcnLFxuICAgICAgcG9zdCA9ICcnO1xuICAgIGlmIChsYXN0X3RhZ190b2tlbi5jdXN0b21fYmVhdXRpZmllcl9uYW1lID09PSAnamF2YXNjcmlwdCcgJiYgdHlwZW9mIHRoaXMuX2pzX2JlYXV0aWZ5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBfYmVhdXRpZmllciA9IHRoaXMuX2pzX2JlYXV0aWZ5O1xuICAgIH0gZWxzZSBpZiAobGFzdF90YWdfdG9rZW4uY3VzdG9tX2JlYXV0aWZpZXJfbmFtZSA9PT0gJ2NzcycgJiYgdHlwZW9mIHRoaXMuX2Nzc19iZWF1dGlmeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgX2JlYXV0aWZpZXIgPSB0aGlzLl9jc3NfYmVhdXRpZnk7XG4gICAgfSBlbHNlIGlmIChsYXN0X3RhZ190b2tlbi5jdXN0b21fYmVhdXRpZmllcl9uYW1lID09PSAnaHRtbCcpIHtcbiAgICAgIF9iZWF1dGlmaWVyID0gZnVuY3Rpb24oaHRtbF9zb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGJlYXV0aWZpZXIgPSBuZXcgQmVhdXRpZmllcihodG1sX3NvdXJjZSwgb3B0aW9ucywgbG9jYWwuX2pzX2JlYXV0aWZ5LCBsb2NhbC5fY3NzX2JlYXV0aWZ5KTtcbiAgICAgICAgcmV0dXJuIGJlYXV0aWZpZXIuYmVhdXRpZnkoKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX29wdGlvbnMuaW5kZW50X3NjcmlwdHMgPT09IFwia2VlcFwiKSB7XG4gICAgICBzY3JpcHRfaW5kZW50X2xldmVsID0gMDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX29wdGlvbnMuaW5kZW50X3NjcmlwdHMgPT09IFwic2VwYXJhdGVcIikge1xuICAgICAgc2NyaXB0X2luZGVudF9sZXZlbCA9IC1wcmludGVyLmluZGVudF9sZXZlbDtcbiAgICB9XG5cbiAgICB2YXIgaW5kZW50YXRpb24gPSBwcmludGVyLmdldF9mdWxsX2luZGVudChzY3JpcHRfaW5kZW50X2xldmVsKTtcblxuICAgIC8vIGlmIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBlbXB0eSBsaW5lIGF0IHRoZSBlbmQgb2YgdGhpcyB0ZXh0LCBzdHJpcCBpdFxuICAgIC8vIHdlJ2xsIGJlIGFkZGluZyBvbmUgYmFjayBhZnRlciB0aGUgdGV4dCBidXQgYmVmb3JlIHRoZSBjb250YWluaW5nIHRhZy5cbiAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXG5bIFxcdF0qJC8sICcnKTtcblxuICAgIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSBjb250ZW50IGlzIHdyYXBwZWQgaW4gYSBjb21tZW50IG9yIGNkYXRhLlxuICAgIGlmIChsYXN0X3RhZ190b2tlbi5jdXN0b21fYmVhdXRpZmllcl9uYW1lICE9PSAnaHRtbCcgJiZcbiAgICAgIHRleHRbMF0gPT09ICc8JyAmJiB0ZXh0Lm1hdGNoKC9eKDwhLS18PCFcXFtDREFUQVxcWykvKSkge1xuICAgICAgdmFyIG1hdGNoZWQgPSAvXig8IS0tW15cXG5dKnw8IVxcW0NEQVRBXFxbKShcXG4/KShbIFxcdFxcbl0qKShbXFxzXFxTXSopKC0tPnxdXT4pJC8uZXhlYyh0ZXh0KTtcblxuICAgICAgLy8gaWYgd2Ugc3RhcnQgdG8gd3JhcCBidXQgZG9uJ3QgZmluaXNoLCBwcmludCByYXdcbiAgICAgIGlmICghbWF0Y2hlZCkge1xuICAgICAgICBwcmludGVyLmFkZF9yYXdfdG9rZW4ocmF3X3Rva2VuKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBwcmUgPSBpbmRlbnRhdGlvbiArIG1hdGNoZWRbMV0gKyAnXFxuJztcbiAgICAgIHRleHQgPSBtYXRjaGVkWzRdO1xuICAgICAgaWYgKG1hdGNoZWRbNV0pIHtcbiAgICAgICAgcG9zdCA9IGluZGVudGF0aW9uICsgbWF0Y2hlZFs1XTtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGVtcHR5IGxpbmUgYXQgdGhlIGVuZCBvZiB0aGlzIHRleHQsIHN0cmlwIGl0XG4gICAgICAvLyB3ZSdsbCBiZSBhZGRpbmcgb25lIGJhY2sgYWZ0ZXIgdGhlIHRleHQgYnV0IGJlZm9yZSB0aGUgY29udGFpbmluZyB0YWcuXG4gICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXG5bIFxcdF0qJC8sICcnKTtcblxuICAgICAgaWYgKG1hdGNoZWRbMl0gfHwgbWF0Y2hlZFszXS5pbmRleE9mKCdcXG4nKSAhPT0gLTEpIHtcbiAgICAgICAgLy8gaWYgdGhlIGZpcnN0IGxpbmUgb2YgdGhlIG5vbi1jb21tZW50IHRleHQgaGFzIHNwYWNlc1xuICAgICAgICAvLyB1c2UgdGhhdCBhcyB0aGUgYmFzaXMgZm9yIGluZGVudGluZyBpbiBudWxsIGNhc2UuXG4gICAgICAgIG1hdGNoZWQgPSBtYXRjaGVkWzNdLm1hdGNoKC9bIFxcdF0rJC8pO1xuICAgICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICAgIHJhd190b2tlbi53aGl0ZXNwYWNlX2JlZm9yZSA9IG1hdGNoZWRbMF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGV4dCkge1xuICAgICAgaWYgKF9iZWF1dGlmaWVyKSB7XG5cbiAgICAgICAgLy8gY2FsbCB0aGUgQmVhdXRpZmllciBpZiBhdmFsaWFibGVcbiAgICAgICAgdmFyIENoaWxkX29wdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLmVvbCA9ICdcXG4nO1xuICAgICAgICB9O1xuICAgICAgICBDaGlsZF9vcHRpb25zLnByb3RvdHlwZSA9IHRoaXMuX29wdGlvbnMucmF3X29wdGlvbnM7XG4gICAgICAgIHZhciBjaGlsZF9vcHRpb25zID0gbmV3IENoaWxkX29wdGlvbnMoKTtcbiAgICAgICAgdGV4dCA9IF9iZWF1dGlmaWVyKGluZGVudGF0aW9uICsgdGV4dCwgY2hpbGRfb3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzaW1wbHkgaW5kZW50IHRoZSBzdHJpbmcgb3RoZXJ3aXNlXG4gICAgICAgIHZhciB3aGl0ZSA9IHJhd190b2tlbi53aGl0ZXNwYWNlX2JlZm9yZTtcbiAgICAgICAgaWYgKHdoaXRlKSB7XG4gICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZShuZXcgUmVnRXhwKCdcXG4oJyArIHdoaXRlICsgJyk/JywgJ2cnKSwgJ1xcbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGV4dCA9IGluZGVudGF0aW9uICsgdGV4dC5yZXBsYWNlKC9cXG4vZywgJ1xcbicgKyBpbmRlbnRhdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByZSkge1xuICAgICAgaWYgKCF0ZXh0KSB7XG4gICAgICAgIHRleHQgPSBwcmUgKyBwb3N0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dCA9IHByZSArIHRleHQgKyAnXFxuJyArIHBvc3Q7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHJpbnRlci5wcmludF9uZXdsaW5lKGZhbHNlKTtcbiAgICBpZiAodGV4dCkge1xuICAgICAgcmF3X3Rva2VuLnRleHQgPSB0ZXh0O1xuICAgICAgcmF3X3Rva2VuLndoaXRlc3BhY2VfYmVmb3JlID0gJyc7XG4gICAgICByYXdfdG9rZW4ubmV3bGluZXMgPSAwO1xuICAgICAgcHJpbnRlci5hZGRfcmF3X3Rva2VuKHJhd190b2tlbik7XG4gICAgICBwcmludGVyLnByaW50X25ld2xpbmUodHJ1ZSk7XG4gICAgfVxuICB9XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5faGFuZGxlX3RhZ19vcGVuID0gZnVuY3Rpb24ocHJpbnRlciwgcmF3X3Rva2VuLCBsYXN0X3RhZ190b2tlbiwgbGFzdF90b2tlbiwgdG9rZW5zKSB7XG4gIHZhciBwYXJzZXJfdG9rZW4gPSB0aGlzLl9nZXRfdGFnX29wZW5fdG9rZW4ocmF3X3Rva2VuKTtcblxuICBpZiAoKGxhc3RfdGFnX3Rva2VuLmlzX3VuZm9ybWF0dGVkIHx8IGxhc3RfdGFnX3Rva2VuLmlzX2NvbnRlbnRfdW5mb3JtYXR0ZWQpICYmXG4gICAgIWxhc3RfdGFnX3Rva2VuLmlzX2VtcHR5X2VsZW1lbnQgJiZcbiAgICByYXdfdG9rZW4udHlwZSA9PT0gVE9LRU4uVEFHX09QRU4gJiYgIXBhcnNlcl90b2tlbi5pc19zdGFydF90YWcpIHtcbiAgICAvLyBFbmQgZWxlbWVudCB0YWdzIGZvciB1bmZvcm1hdHRlZCBvciBjb250ZW50X3VuZm9ybWF0dGVkIGVsZW1lbnRzXG4gICAgLy8gYXJlIHByaW50ZWQgcmF3IHRvIGtlZXAgYW55IG5ld2xpbmVzIGluc2lkZSB0aGVtIGV4YWN0bHkgdGhlIHNhbWUuXG4gICAgcHJpbnRlci5hZGRfcmF3X3Rva2VuKHJhd190b2tlbik7XG4gICAgcGFyc2VyX3Rva2VuLnN0YXJ0X3RhZ190b2tlbiA9IHRoaXMuX3RhZ19zdGFjay50cnlfcG9wKHBhcnNlcl90b2tlbi50YWdfbmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgcHJpbnRlci50cmF2ZXJzZV93aGl0ZXNwYWNlKHJhd190b2tlbik7XG4gICAgdGhpcy5fc2V0X3RhZ19wb3NpdGlvbihwcmludGVyLCByYXdfdG9rZW4sIHBhcnNlcl90b2tlbiwgbGFzdF90YWdfdG9rZW4sIGxhc3RfdG9rZW4pO1xuICAgIGlmICghcGFyc2VyX3Rva2VuLmlzX2lubGluZV9lbGVtZW50KSB7XG4gICAgICBwcmludGVyLnNldF93cmFwX3BvaW50KCk7XG4gICAgfVxuICAgIHByaW50ZXIucHJpbnRfdG9rZW4ocmF3X3Rva2VuKTtcbiAgfVxuXG4gIC8vIGNvdW50IHRoZSBudW1iZXIgb2YgYXR0cmlidXRlc1xuICBpZiAocGFyc2VyX3Rva2VuLmlzX3N0YXJ0X3RhZyAmJiB0aGlzLl9pc193cmFwX2F0dHJpYnV0ZXNfZm9yY2UpIHtcbiAgICB2YXIgcGVla19pbmRleCA9IDA7XG4gICAgdmFyIHBlZWtfdG9rZW47XG4gICAgZG8ge1xuICAgICAgcGVla190b2tlbiA9IHRva2Vucy5wZWVrKHBlZWtfaW5kZXgpO1xuICAgICAgaWYgKHBlZWtfdG9rZW4udHlwZSA9PT0gVE9LRU4uQVRUUklCVVRFKSB7XG4gICAgICAgIHBhcnNlcl90b2tlbi5hdHRyX2NvdW50ICs9IDE7XG4gICAgICB9XG4gICAgICBwZWVrX2luZGV4ICs9IDE7XG4gICAgfSB3aGlsZSAocGVla190b2tlbi50eXBlICE9PSBUT0tFTi5FT0YgJiYgcGVla190b2tlbi50eXBlICE9PSBUT0tFTi5UQUdfQ0xPU0UpO1xuICB9XG5cbiAgLy9pbmRlbnQgYXR0cmlidXRlcyBhbiBhdXRvLCBmb3JjZWQsIGFsaWduZWQgb3IgZm9yY2VkLWFsaWduIGxpbmUtd3JhcFxuICBpZiAodGhpcy5faXNfd3JhcF9hdHRyaWJ1dGVzX2ZvcmNlX2FsaWduZWQgfHwgdGhpcy5faXNfd3JhcF9hdHRyaWJ1dGVzX2FsaWduZWRfbXVsdGlwbGUgfHwgdGhpcy5faXNfd3JhcF9hdHRyaWJ1dGVzX3ByZXNlcnZlX2FsaWduZWQpIHtcbiAgICBwYXJzZXJfdG9rZW4uYWxpZ25tZW50X3NpemUgPSByYXdfdG9rZW4udGV4dC5sZW5ndGggKyAxO1xuICB9XG5cbiAgaWYgKCFwYXJzZXJfdG9rZW4udGFnX2NvbXBsZXRlICYmICFwYXJzZXJfdG9rZW4uaXNfdW5mb3JtYXR0ZWQpIHtcbiAgICBwcmludGVyLmFsaWdubWVudF9zaXplID0gcGFyc2VyX3Rva2VuLmFsaWdubWVudF9zaXplO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlcl90b2tlbjtcbn07XG5cbnZhciBUYWdPcGVuUGFyc2VyVG9rZW4gPSBmdW5jdGlvbihwYXJlbnQsIHJhd190b2tlbikge1xuICB0aGlzLnBhcmVudCA9IHBhcmVudCB8fCBudWxsO1xuICB0aGlzLnRleHQgPSAnJztcbiAgdGhpcy50eXBlID0gJ1RLX1RBR19PUEVOJztcbiAgdGhpcy50YWdfbmFtZSA9ICcnO1xuICB0aGlzLmlzX2lubGluZV9lbGVtZW50ID0gZmFsc2U7XG4gIHRoaXMuaXNfdW5mb3JtYXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5pc19jb250ZW50X3VuZm9ybWF0dGVkID0gZmFsc2U7XG4gIHRoaXMuaXNfZW1wdHlfZWxlbWVudCA9IGZhbHNlO1xuICB0aGlzLmlzX3N0YXJ0X3RhZyA9IGZhbHNlO1xuICB0aGlzLmlzX2VuZF90YWcgPSBmYWxzZTtcbiAgdGhpcy5pbmRlbnRfY29udGVudCA9IGZhbHNlO1xuICB0aGlzLm11bHRpbGluZV9jb250ZW50ID0gZmFsc2U7XG4gIHRoaXMuY3VzdG9tX2JlYXV0aWZpZXJfbmFtZSA9IG51bGw7XG4gIHRoaXMuc3RhcnRfdGFnX3Rva2VuID0gbnVsbDtcbiAgdGhpcy5hdHRyX2NvdW50ID0gMDtcbiAgdGhpcy5oYXNfd3JhcHBlZF9hdHRycyA9IGZhbHNlO1xuICB0aGlzLmFsaWdubWVudF9zaXplID0gMDtcbiAgdGhpcy50YWdfY29tcGxldGUgPSBmYWxzZTtcbiAgdGhpcy50YWdfc3RhcnRfY2hhciA9ICcnO1xuICB0aGlzLnRhZ19jaGVjayA9ICcnO1xuXG4gIGlmICghcmF3X3Rva2VuKSB7XG4gICAgdGhpcy50YWdfY29tcGxldGUgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHZhciB0YWdfY2hlY2tfbWF0Y2g7XG5cbiAgICB0aGlzLnRhZ19zdGFydF9jaGFyID0gcmF3X3Rva2VuLnRleHRbMF07XG4gICAgdGhpcy50ZXh0ID0gcmF3X3Rva2VuLnRleHQ7XG5cbiAgICBpZiAodGhpcy50YWdfc3RhcnRfY2hhciA9PT0gJzwnKSB7XG4gICAgICB0YWdfY2hlY2tfbWF0Y2ggPSByYXdfdG9rZW4udGV4dC5tYXRjaCgvXjwoW15cXHM+XSopLyk7XG4gICAgICB0aGlzLnRhZ19jaGVjayA9IHRhZ19jaGVja19tYXRjaCA/IHRhZ19jaGVja19tYXRjaFsxXSA6ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YWdfY2hlY2tfbWF0Y2ggPSByYXdfdG9rZW4udGV4dC5tYXRjaCgvXnt7fj8oPzpbXFxeXXwjXFwqPyk/KFteXFxzfV0rKS8pO1xuICAgICAgdGhpcy50YWdfY2hlY2sgPSB0YWdfY2hlY2tfbWF0Y2ggPyB0YWdfY2hlY2tfbWF0Y2hbMV0gOiAnJztcblxuICAgICAgLy8gaGFuZGxlIFwie3sjPiBteVBhcnRpYWx9fVwiIG9yIFwie3t+Iz4gbXlQYXJ0aWFsfX1cIlxuICAgICAgaWYgKChyYXdfdG9rZW4udGV4dC5zdGFydHNXaXRoKCd7eyM+JykgfHwgcmF3X3Rva2VuLnRleHQuc3RhcnRzV2l0aCgne3t+Iz4nKSkgJiYgdGhpcy50YWdfY2hlY2tbMF0gPT09ICc+Jykge1xuICAgICAgICBpZiAodGhpcy50YWdfY2hlY2sgPT09ICc+JyAmJiByYXdfdG9rZW4ubmV4dCAhPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMudGFnX2NoZWNrID0gcmF3X3Rva2VuLm5leHQudGV4dC5zcGxpdCgnICcpWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudGFnX2NoZWNrID0gcmF3X3Rva2VuLnRleHQuc3BsaXQoJz4nKVsxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudGFnX2NoZWNrID0gdGhpcy50YWdfY2hlY2sudG9Mb3dlckNhc2UoKTtcblxuICAgIGlmIChyYXdfdG9rZW4udHlwZSA9PT0gVE9LRU4uQ09NTUVOVCkge1xuICAgICAgdGhpcy50YWdfY29tcGxldGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuaXNfc3RhcnRfdGFnID0gdGhpcy50YWdfY2hlY2suY2hhckF0KDApICE9PSAnLyc7XG4gICAgdGhpcy50YWdfbmFtZSA9ICF0aGlzLmlzX3N0YXJ0X3RhZyA/IHRoaXMudGFnX2NoZWNrLnN1YnN0cigxKSA6IHRoaXMudGFnX2NoZWNrO1xuICAgIHRoaXMuaXNfZW5kX3RhZyA9ICF0aGlzLmlzX3N0YXJ0X3RhZyB8fFxuICAgICAgKHJhd190b2tlbi5jbG9zZWQgJiYgcmF3X3Rva2VuLmNsb3NlZC50ZXh0ID09PSAnLz4nKTtcblxuICAgIC8vIGlmIHdoaXRlc3BhY2UgaGFuZGxlciB+IGluY2x1ZGVkIChpLmUuIHt7fiNpZiB0cnVlfX0pLCBoYW5kbGViYXJzIHRhZ3Mgc3RhcnQgYXQgcG9zIDMgbm90IHBvcyAyXG4gICAgdmFyIGhhbmRsZWJhcl9zdGFydHMgPSAyO1xuICAgIGlmICh0aGlzLnRhZ19zdGFydF9jaGFyID09PSAneycgJiYgdGhpcy50ZXh0Lmxlbmd0aCA+PSAzKSB7XG4gICAgICBpZiAodGhpcy50ZXh0LmNoYXJBdCgyKSA9PT0gJ34nKSB7XG4gICAgICAgIGhhbmRsZWJhcl9zdGFydHMgPSAzO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGhhbmRsZWJhcnMgdGFncyB0aGF0IGRvbid0IHN0YXJ0IHdpdGggIyBvciBeIGFyZSBzaW5nbGVfdGFncywgYW5kIHNvIGFsc28gc3RhcnQgYW5kIGVuZC5cbiAgICB0aGlzLmlzX2VuZF90YWcgPSB0aGlzLmlzX2VuZF90YWcgfHxcbiAgICAgICh0aGlzLnRhZ19zdGFydF9jaGFyID09PSAneycgJiYgKHRoaXMudGV4dC5sZW5ndGggPCAzIHx8ICgvW14jXFxeXS8udGVzdCh0aGlzLnRleHQuY2hhckF0KGhhbmRsZWJhcl9zdGFydHMpKSkpKTtcbiAgfVxufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuX2dldF90YWdfb3Blbl90b2tlbiA9IGZ1bmN0aW9uKHJhd190b2tlbikgeyAvL2Z1bmN0aW9uIHRvIGdldCBhIGZ1bGwgdGFnIGFuZCBwYXJzZSBpdHMgdHlwZVxuICB2YXIgcGFyc2VyX3Rva2VuID0gbmV3IFRhZ09wZW5QYXJzZXJUb2tlbih0aGlzLl90YWdfc3RhY2suZ2V0X3BhcnNlcl90b2tlbigpLCByYXdfdG9rZW4pO1xuXG4gIHBhcnNlcl90b2tlbi5hbGlnbm1lbnRfc2l6ZSA9IHRoaXMuX29wdGlvbnMud3JhcF9hdHRyaWJ1dGVzX2luZGVudF9zaXplO1xuXG4gIHBhcnNlcl90b2tlbi5pc19lbmRfdGFnID0gcGFyc2VyX3Rva2VuLmlzX2VuZF90YWcgfHxcbiAgICBpbl9hcnJheShwYXJzZXJfdG9rZW4udGFnX2NoZWNrLCB0aGlzLl9vcHRpb25zLnZvaWRfZWxlbWVudHMpO1xuXG4gIHBhcnNlcl90b2tlbi5pc19lbXB0eV9lbGVtZW50ID0gcGFyc2VyX3Rva2VuLnRhZ19jb21wbGV0ZSB8fFxuICAgIChwYXJzZXJfdG9rZW4uaXNfc3RhcnRfdGFnICYmIHBhcnNlcl90b2tlbi5pc19lbmRfdGFnKTtcblxuICBwYXJzZXJfdG9rZW4uaXNfdW5mb3JtYXR0ZWQgPSAhcGFyc2VyX3Rva2VuLnRhZ19jb21wbGV0ZSAmJiBpbl9hcnJheShwYXJzZXJfdG9rZW4udGFnX2NoZWNrLCB0aGlzLl9vcHRpb25zLnVuZm9ybWF0dGVkKTtcbiAgcGFyc2VyX3Rva2VuLmlzX2NvbnRlbnRfdW5mb3JtYXR0ZWQgPSAhcGFyc2VyX3Rva2VuLmlzX2VtcHR5X2VsZW1lbnQgJiYgaW5fYXJyYXkocGFyc2VyX3Rva2VuLnRhZ19jaGVjaywgdGhpcy5fb3B0aW9ucy5jb250ZW50X3VuZm9ybWF0dGVkKTtcbiAgcGFyc2VyX3Rva2VuLmlzX2lubGluZV9lbGVtZW50ID0gaW5fYXJyYXkocGFyc2VyX3Rva2VuLnRhZ19uYW1lLCB0aGlzLl9vcHRpb25zLmlubGluZSkgfHwgKHRoaXMuX29wdGlvbnMuaW5saW5lX2N1c3RvbV9lbGVtZW50cyAmJiBwYXJzZXJfdG9rZW4udGFnX25hbWUuaW5jbHVkZXMoXCItXCIpKSB8fCBwYXJzZXJfdG9rZW4udGFnX3N0YXJ0X2NoYXIgPT09ICd7JztcblxuICByZXR1cm4gcGFyc2VyX3Rva2VuO1xufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuX3NldF90YWdfcG9zaXRpb24gPSBmdW5jdGlvbihwcmludGVyLCByYXdfdG9rZW4sIHBhcnNlcl90b2tlbiwgbGFzdF90YWdfdG9rZW4sIGxhc3RfdG9rZW4pIHtcblxuICBpZiAoIXBhcnNlcl90b2tlbi5pc19lbXB0eV9lbGVtZW50KSB7XG4gICAgaWYgKHBhcnNlcl90b2tlbi5pc19lbmRfdGFnKSB7IC8vdGhpcyB0YWcgaXMgYSBkb3VibGUgdGFnIHNvIGNoZWNrIGZvciB0YWctZW5kaW5nXG4gICAgICBwYXJzZXJfdG9rZW4uc3RhcnRfdGFnX3Rva2VuID0gdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AocGFyc2VyX3Rva2VuLnRhZ19uYW1lKTsgLy9yZW1vdmUgaXQgYW5kIGFsbCBhbmNlc3RvcnNcbiAgICB9IGVsc2UgeyAvLyBpdCdzIGEgc3RhcnQtdGFnXG4gICAgICAvLyBjaGVjayBpZiB0aGlzIHRhZyBpcyBzdGFydGluZyBhbiBlbGVtZW50IHRoYXQgaGFzIG9wdGlvbmFsIGVuZCBlbGVtZW50XG4gICAgICAvLyBhbmQgZG8gYW4gZW5kaW5nIG5lZWRlZFxuICAgICAgaWYgKHRoaXMuX2RvX29wdGlvbmFsX2VuZF9lbGVtZW50KHBhcnNlcl90b2tlbikpIHtcbiAgICAgICAgaWYgKCFwYXJzZXJfdG9rZW4uaXNfaW5saW5lX2VsZW1lbnQpIHtcbiAgICAgICAgICBwcmludGVyLnByaW50X25ld2xpbmUoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3RhZ19zdGFjay5yZWNvcmRfdGFnKHBhcnNlcl90b2tlbik7IC8vcHVzaCBpdCBvbiB0aGUgdGFnIHN0YWNrXG5cbiAgICAgIGlmICgocGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAnc2NyaXB0JyB8fCBwYXJzZXJfdG9rZW4udGFnX25hbWUgPT09ICdzdHlsZScpICYmXG4gICAgICAgICEocGFyc2VyX3Rva2VuLmlzX3VuZm9ybWF0dGVkIHx8IHBhcnNlcl90b2tlbi5pc19jb250ZW50X3VuZm9ybWF0dGVkKSkge1xuICAgICAgICBwYXJzZXJfdG9rZW4uY3VzdG9tX2JlYXV0aWZpZXJfbmFtZSA9IGdldF9jdXN0b21fYmVhdXRpZmllcl9uYW1lKHBhcnNlcl90b2tlbi50YWdfY2hlY2ssIHJhd190b2tlbik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGluX2FycmF5KHBhcnNlcl90b2tlbi50YWdfY2hlY2ssIHRoaXMuX29wdGlvbnMuZXh0cmFfbGluZXJzKSkgeyAvL2NoZWNrIGlmIHRoaXMgZG91YmxlIG5lZWRzIGFuIGV4dHJhIGxpbmVcbiAgICBwcmludGVyLnByaW50X25ld2xpbmUoZmFsc2UpO1xuICAgIGlmICghcHJpbnRlci5fb3V0cHV0Lmp1c3RfYWRkZWRfYmxhbmtsaW5lKCkpIHtcbiAgICAgIHByaW50ZXIucHJpbnRfbmV3bGluZSh0cnVlKTtcbiAgICB9XG4gIH1cblxuICBpZiAocGFyc2VyX3Rva2VuLmlzX2VtcHR5X2VsZW1lbnQpIHsgLy9pZiB0aGlzIHRhZyBuYW1lIGlzIGEgc2luZ2xlIHRhZyB0eXBlIChlaXRoZXIgaW4gdGhlIGxpc3Qgb3IgaGFzIGEgY2xvc2luZyAvKVxuXG4gICAgLy8gaWYgeW91IGhpdCBhbiBlbHNlIGNhc2UsIHJlc2V0IHRoZSBpbmRlbnQgbGV2ZWwgaWYgeW91IGFyZSBpbnNpZGUgYW46XG4gICAgLy8gJ2lmJywgJ3VubGVzcycsIG9yICdlYWNoJyBibG9jay5cbiAgICBpZiAocGFyc2VyX3Rva2VuLnRhZ19zdGFydF9jaGFyID09PSAneycgJiYgcGFyc2VyX3Rva2VuLnRhZ19jaGVjayA9PT0gJ2Vsc2UnKSB7XG4gICAgICB0aGlzLl90YWdfc3RhY2suaW5kZW50X3RvX3RhZyhbJ2lmJywgJ3VubGVzcycsICdlYWNoJ10pO1xuICAgICAgcGFyc2VyX3Rva2VuLmluZGVudF9jb250ZW50ID0gdHJ1ZTtcbiAgICAgIC8vIERvbid0IGFkZCBhIG5ld2xpbmUgaWYgb3BlbmluZyB7eyNpZn19IHRhZyBpcyBvbiB0aGUgY3VycmVudCBsaW5lXG4gICAgICB2YXIgZm91bmRJZk9uQ3VycmVudExpbmUgPSBwcmludGVyLmN1cnJlbnRfbGluZV9oYXNfbWF0Y2goL3t7I2lmLyk7XG4gICAgICBpZiAoIWZvdW5kSWZPbkN1cnJlbnRMaW5lKSB7XG4gICAgICAgIHByaW50ZXIucHJpbnRfbmV3bGluZShmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRG9uJ3QgYWRkIGEgbmV3bGluZSBiZWZvcmUgZWxlbWVudHMgdGhhdCBzaG91bGQgcmVtYWluIHdoZXJlIHRoZXkgYXJlLlxuICAgIGlmIChwYXJzZXJfdG9rZW4udGFnX25hbWUgPT09ICchLS0nICYmIGxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uVEFHX0NMT1NFICYmXG4gICAgICBsYXN0X3RhZ190b2tlbi5pc19lbmRfdGFnICYmIHBhcnNlcl90b2tlbi50ZXh0LmluZGV4T2YoJ1xcbicpID09PSAtMSkge1xuICAgICAgLy9EbyBub3RoaW5nLiBMZWF2ZSBjb21tZW50cyBvbiBzYW1lIGxpbmUuXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghKHBhcnNlcl90b2tlbi5pc19pbmxpbmVfZWxlbWVudCB8fCBwYXJzZXJfdG9rZW4uaXNfdW5mb3JtYXR0ZWQpKSB7XG4gICAgICAgIHByaW50ZXIucHJpbnRfbmV3bGluZShmYWxzZSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9jYWxjbHVhdGVfcGFyZW50X211bHRpbGluZShwcmludGVyLCBwYXJzZXJfdG9rZW4pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChwYXJzZXJfdG9rZW4uaXNfZW5kX3RhZykgeyAvL3RoaXMgdGFnIGlzIGEgZG91YmxlIHRhZyBzbyBjaGVjayBmb3IgdGFnLWVuZGluZ1xuICAgIHZhciBkb19lbmRfZXhwYW5kID0gZmFsc2U7XG5cbiAgICAvLyBkZWNpZGluZyB3aGV0aGVyIGEgYmxvY2sgaXMgbXVsdGlsaW5lIHNob3VsZCBub3QgYmUgdGhpcyBoYXJkXG4gICAgZG9fZW5kX2V4cGFuZCA9IHBhcnNlcl90b2tlbi5zdGFydF90YWdfdG9rZW4gJiYgcGFyc2VyX3Rva2VuLnN0YXJ0X3RhZ190b2tlbi5tdWx0aWxpbmVfY29udGVudDtcbiAgICBkb19lbmRfZXhwYW5kID0gZG9fZW5kX2V4cGFuZCB8fCAoIXBhcnNlcl90b2tlbi5pc19pbmxpbmVfZWxlbWVudCAmJlxuICAgICAgIShsYXN0X3RhZ190b2tlbi5pc19pbmxpbmVfZWxlbWVudCB8fCBsYXN0X3RhZ190b2tlbi5pc191bmZvcm1hdHRlZCkgJiZcbiAgICAgICEobGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5UQUdfQ0xPU0UgJiYgcGFyc2VyX3Rva2VuLnN0YXJ0X3RhZ190b2tlbiA9PT0gbGFzdF90YWdfdG9rZW4pICYmXG4gICAgICBsYXN0X3Rva2VuLnR5cGUgIT09ICdUS19DT05URU5UJ1xuICAgICk7XG5cbiAgICBpZiAocGFyc2VyX3Rva2VuLmlzX2NvbnRlbnRfdW5mb3JtYXR0ZWQgfHwgcGFyc2VyX3Rva2VuLmlzX3VuZm9ybWF0dGVkKSB7XG4gICAgICBkb19lbmRfZXhwYW5kID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGRvX2VuZF9leHBhbmQpIHtcbiAgICAgIHByaW50ZXIucHJpbnRfbmV3bGluZShmYWxzZSk7XG4gICAgfVxuICB9IGVsc2UgeyAvLyBpdCdzIGEgc3RhcnQtdGFnXG4gICAgcGFyc2VyX3Rva2VuLmluZGVudF9jb250ZW50ID0gIXBhcnNlcl90b2tlbi5jdXN0b21fYmVhdXRpZmllcl9uYW1lO1xuXG4gICAgaWYgKHBhcnNlcl90b2tlbi50YWdfc3RhcnRfY2hhciA9PT0gJzwnKSB7XG4gICAgICBpZiAocGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAnaHRtbCcpIHtcbiAgICAgICAgcGFyc2VyX3Rva2VuLmluZGVudF9jb250ZW50ID0gdGhpcy5fb3B0aW9ucy5pbmRlbnRfaW5uZXJfaHRtbDtcbiAgICAgIH0gZWxzZSBpZiAocGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAnaGVhZCcpIHtcbiAgICAgICAgcGFyc2VyX3Rva2VuLmluZGVudF9jb250ZW50ID0gdGhpcy5fb3B0aW9ucy5pbmRlbnRfaGVhZF9pbm5lcl9odG1sO1xuICAgICAgfSBlbHNlIGlmIChwYXJzZXJfdG9rZW4udGFnX25hbWUgPT09ICdib2R5Jykge1xuICAgICAgICBwYXJzZXJfdG9rZW4uaW5kZW50X2NvbnRlbnQgPSB0aGlzLl9vcHRpb25zLmluZGVudF9ib2R5X2lubmVyX2h0bWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEocGFyc2VyX3Rva2VuLmlzX2lubGluZV9lbGVtZW50IHx8IHBhcnNlcl90b2tlbi5pc191bmZvcm1hdHRlZCkgJiZcbiAgICAgIChsYXN0X3Rva2VuLnR5cGUgIT09ICdUS19DT05URU5UJyB8fCBwYXJzZXJfdG9rZW4uaXNfY29udGVudF91bmZvcm1hdHRlZCkpIHtcbiAgICAgIHByaW50ZXIucHJpbnRfbmV3bGluZShmYWxzZSk7XG4gICAgfVxuXG4gICAgdGhpcy5fY2FsY2x1YXRlX3BhcmVudF9tdWx0aWxpbmUocHJpbnRlciwgcGFyc2VyX3Rva2VuKTtcbiAgfVxufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuX2NhbGNsdWF0ZV9wYXJlbnRfbXVsdGlsaW5lID0gZnVuY3Rpb24ocHJpbnRlciwgcGFyc2VyX3Rva2VuKSB7XG4gIGlmIChwYXJzZXJfdG9rZW4ucGFyZW50ICYmIHByaW50ZXIuX291dHB1dC5qdXN0X2FkZGVkX25ld2xpbmUoKSAmJlxuICAgICEoKHBhcnNlcl90b2tlbi5pc19pbmxpbmVfZWxlbWVudCB8fCBwYXJzZXJfdG9rZW4uaXNfdW5mb3JtYXR0ZWQpICYmIHBhcnNlcl90b2tlbi5wYXJlbnQuaXNfaW5saW5lX2VsZW1lbnQpKSB7XG4gICAgcGFyc2VyX3Rva2VuLnBhcmVudC5tdWx0aWxpbmVfY29udGVudCA9IHRydWU7XG4gIH1cbn07XG5cbi8vVG8gYmUgdXNlZCBmb3IgPHA+IHRhZyBzcGVjaWFsIGNhc2U6XG52YXIgcF9jbG9zZXJzID0gWydhZGRyZXNzJywgJ2FydGljbGUnLCAnYXNpZGUnLCAnYmxvY2txdW90ZScsICdkZXRhaWxzJywgJ2RpdicsICdkbCcsICdmaWVsZHNldCcsICdmaWdjYXB0aW9uJywgJ2ZpZ3VyZScsICdmb290ZXInLCAnZm9ybScsICdoMScsICdoMicsICdoMycsICdoNCcsICdoNScsICdoNicsICdoZWFkZXInLCAnaHInLCAnbWFpbicsICdtZW51JywgJ25hdicsICdvbCcsICdwJywgJ3ByZScsICdzZWN0aW9uJywgJ3RhYmxlJywgJ3VsJ107XG52YXIgcF9wYXJlbnRfZXhjbHVkZXMgPSBbJ2EnLCAnYXVkaW8nLCAnZGVsJywgJ2lucycsICdtYXAnLCAnbm9zY3JpcHQnLCAndmlkZW8nXTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuX2RvX29wdGlvbmFsX2VuZF9lbGVtZW50ID0gZnVuY3Rpb24ocGFyc2VyX3Rva2VuKSB7XG4gIHZhciByZXN1bHQgPSBudWxsO1xuICAvLyBOT1RFOiBjYXNlcyBvZiBcImlmIHRoZXJlIGlzIG5vIG1vcmUgY29udGVudCBpbiB0aGUgcGFyZW50IGVsZW1lbnRcIlxuICAvLyBhcmUgaGFuZGxlZCBhdXRvbWF0aWNhbGx5IGJ5IHRoZSBiZWF1dGlmaWVyLlxuICAvLyBJdCBhc3N1bWVzIHBhcmVudCBvciBhbmNlc3RvciBjbG9zZSB0YWcgY2xvc2VzIGFsbCBjaGlsZHJlbi5cbiAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI29wdGlvbmFsLXRhZ3NcbiAgaWYgKHBhcnNlcl90b2tlbi5pc19lbXB0eV9lbGVtZW50IHx8ICFwYXJzZXJfdG9rZW4uaXNfc3RhcnRfdGFnIHx8ICFwYXJzZXJfdG9rZW4ucGFyZW50KSB7XG4gICAgcmV0dXJuO1xuXG4gIH1cblxuICBpZiAocGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAnYm9keScpIHtcbiAgICAvLyBBIGhlYWQgZWxlbWVudOKAmXMgZW5kIHRhZyBtYXkgYmUgb21pdHRlZCBpZiB0aGUgaGVhZCBlbGVtZW50IGlzIG5vdCBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhIHNwYWNlIGNoYXJhY3RlciBvciBhIGNvbW1lbnQuXG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuX3RhZ19zdGFjay50cnlfcG9wKCdoZWFkJyk7XG5cbiAgICAvL30gZWxzZSBpZiAocGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAnYm9keScpIHtcbiAgICAvLyBET05FOiBBIGJvZHkgZWxlbWVudOKAmXMgZW5kIHRhZyBtYXkgYmUgb21pdHRlZCBpZiB0aGUgYm9keSBlbGVtZW50IGlzIG5vdCBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhIGNvbW1lbnQuXG5cbiAgfSBlbHNlIGlmIChwYXJzZXJfdG9rZW4udGFnX25hbWUgPT09ICdsaScpIHtcbiAgICAvLyBBbiBsaSBlbGVtZW504oCZcyBlbmQgdGFnIG1heSBiZSBvbWl0dGVkIGlmIHRoZSBsaSBlbGVtZW50IGlzIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGFub3RoZXIgbGkgZWxlbWVudCBvciBpZiB0aGVyZSBpcyBubyBtb3JlIGNvbnRlbnQgaW4gdGhlIHBhcmVudCBlbGVtZW50LlxuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLl90YWdfc3RhY2sudHJ5X3BvcCgnbGknLCBbJ29sJywgJ3VsJywgJ21lbnUnXSk7XG5cbiAgfSBlbHNlIGlmIChwYXJzZXJfdG9rZW4udGFnX25hbWUgPT09ICdkZCcgfHwgcGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAnZHQnKSB7XG4gICAgLy8gQSBkZCBlbGVtZW504oCZcyBlbmQgdGFnIG1heSBiZSBvbWl0dGVkIGlmIHRoZSBkZCBlbGVtZW50IGlzIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGFub3RoZXIgZGQgZWxlbWVudCBvciBhIGR0IGVsZW1lbnQsIG9yIGlmIHRoZXJlIGlzIG5vIG1vcmUgY29udGVudCBpbiB0aGUgcGFyZW50IGVsZW1lbnQuXG4gICAgLy8gQSBkdCBlbGVtZW504oCZcyBlbmQgdGFnIG1heSBiZSBvbWl0dGVkIGlmIHRoZSBkdCBlbGVtZW50IGlzIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGFub3RoZXIgZHQgZWxlbWVudCBvciBhIGRkIGVsZW1lbnQuXG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuX3RhZ19zdGFjay50cnlfcG9wKCdkdCcsIFsnZGwnXSk7XG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuX3RhZ19zdGFjay50cnlfcG9wKCdkZCcsIFsnZGwnXSk7XG5cblxuICB9IGVsc2UgaWYgKHBhcnNlcl90b2tlbi5wYXJlbnQudGFnX25hbWUgPT09ICdwJyAmJiBwX2Nsb3NlcnMuaW5kZXhPZihwYXJzZXJfdG9rZW4udGFnX25hbWUpICE9PSAtMSkge1xuICAgIC8vIElNUE9SVEFOVDogdGhpcyBlbHNlLWlmIHdvcmtzIGJlY2F1c2UgcF9jbG9zZXJzIGhhcyBubyBvdmVybGFwIHdpdGggYW55IG90aGVyIGVsZW1lbnQgd2UgbG9vayBmb3IgaW4gdGhpcyBtZXRob2RcbiAgICAvLyBjaGVjayBmb3IgdGhlIHBhcmVudCBlbGVtZW50IGlzIGFuIEhUTUwgZWxlbWVudCB0aGF0IGlzIG5vdCBhbiA8YT4sIDxhdWRpbz4sIDxkZWw+LCA8aW5zPiwgPG1hcD4sIDxub3NjcmlwdD4sIG9yIDx2aWRlbz4gZWxlbWVudCwgIG9yIGFuIGF1dG9ub21vdXMgY3VzdG9tIGVsZW1lbnQuXG4gICAgLy8gVG8gZG8gdGhpcyByaWdodCwgdGhpcyBuZWVkcyB0byBiZSBjb2RlZCBhcyBhbiBpbmNsdXNpb24gb2YgdGhlIGludmVyc2Ugb2YgdGhlIGV4Y2x1c2lvbiBhYm92ZS5cbiAgICAvLyBCdXQgdG8gc3RhcnQgd2l0aCAoaWYgd2UgaWdub3JlIFwiYXV0b25vbW91cyBjdXN0b20gZWxlbWVudHNcIikgdGhlIGV4Y2x1c2lvbiB3b3VsZCBiZSBmaW5lLlxuICAgIHZhciBwX3BhcmVudCA9IHBhcnNlcl90b2tlbi5wYXJlbnQucGFyZW50O1xuICAgIGlmICghcF9wYXJlbnQgfHwgcF9wYXJlbnRfZXhjbHVkZXMuaW5kZXhPZihwX3BhcmVudC50YWdfbmFtZSkgPT09IC0xKSB7XG4gICAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AoJ3AnKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAncnAnIHx8IHBhcnNlcl90b2tlbi50YWdfbmFtZSA9PT0gJ3J0Jykge1xuICAgIC8vIEFuIHJ0IGVsZW1lbnTigJlzIGVuZCB0YWcgbWF5IGJlIG9taXR0ZWQgaWYgdGhlIHJ0IGVsZW1lbnQgaXMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYW4gcnQgb3IgcnAgZWxlbWVudCwgb3IgaWYgdGhlcmUgaXMgbm8gbW9yZSBjb250ZW50IGluIHRoZSBwYXJlbnQgZWxlbWVudC5cbiAgICAvLyBBbiBycCBlbGVtZW504oCZcyBlbmQgdGFnIG1heSBiZSBvbWl0dGVkIGlmIHRoZSBycCBlbGVtZW50IGlzIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGFuIHJ0IG9yIHJwIGVsZW1lbnQsIG9yIGlmIHRoZXJlIGlzIG5vIG1vcmUgY29udGVudCBpbiB0aGUgcGFyZW50IGVsZW1lbnQuXG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuX3RhZ19zdGFjay50cnlfcG9wKCdydCcsIFsncnVieScsICdydGMnXSk7XG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuX3RhZ19zdGFjay50cnlfcG9wKCdycCcsIFsncnVieScsICdydGMnXSk7XG5cbiAgfSBlbHNlIGlmIChwYXJzZXJfdG9rZW4udGFnX25hbWUgPT09ICdvcHRncm91cCcpIHtcbiAgICAvLyBBbiBvcHRncm91cCBlbGVtZW504oCZcyBlbmQgdGFnIG1heSBiZSBvbWl0dGVkIGlmIHRoZSBvcHRncm91cCBlbGVtZW50IGlzIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGFub3RoZXIgb3B0Z3JvdXAgZWxlbWVudCwgb3IgaWYgdGhlcmUgaXMgbm8gbW9yZSBjb250ZW50IGluIHRoZSBwYXJlbnQgZWxlbWVudC5cbiAgICAvLyBBbiBvcHRpb24gZWxlbWVudOKAmXMgZW5kIHRhZyBtYXkgYmUgb21pdHRlZCBpZiB0aGUgb3B0aW9uIGVsZW1lbnQgaXMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYW5vdGhlciBvcHRpb24gZWxlbWVudCwgb3IgaWYgaXQgaXMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYW4gb3B0Z3JvdXAgZWxlbWVudCwgb3IgaWYgdGhlcmUgaXMgbm8gbW9yZSBjb250ZW50IGluIHRoZSBwYXJlbnQgZWxlbWVudC5cbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AoJ29wdGdyb3VwJywgWydzZWxlY3QnXSk7XG4gICAgLy9yZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AoJ29wdGlvbicsIFsnc2VsZWN0J10pO1xuXG4gIH0gZWxzZSBpZiAocGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAnb3B0aW9uJykge1xuICAgIC8vIEFuIG9wdGlvbiBlbGVtZW504oCZcyBlbmQgdGFnIG1heSBiZSBvbWl0dGVkIGlmIHRoZSBvcHRpb24gZWxlbWVudCBpcyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhbm90aGVyIG9wdGlvbiBlbGVtZW50LCBvciBpZiBpdCBpcyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhbiBvcHRncm91cCBlbGVtZW50LCBvciBpZiB0aGVyZSBpcyBubyBtb3JlIGNvbnRlbnQgaW4gdGhlIHBhcmVudCBlbGVtZW50LlxuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLl90YWdfc3RhY2sudHJ5X3BvcCgnb3B0aW9uJywgWydzZWxlY3QnLCAnZGF0YWxpc3QnLCAnb3B0Z3JvdXAnXSk7XG5cbiAgfSBlbHNlIGlmIChwYXJzZXJfdG9rZW4udGFnX25hbWUgPT09ICdjb2xncm91cCcpIHtcbiAgICAvLyBET05FOiBBIGNvbGdyb3VwIGVsZW1lbnTigJlzIGVuZCB0YWcgbWF5IGJlIG9taXR0ZWQgaWYgdGhlIGNvbGdyb3VwIGVsZW1lbnQgaXMgbm90IGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGEgc3BhY2UgY2hhcmFjdGVyIG9yIGEgY29tbWVudC5cbiAgICAvLyBBIGNhcHRpb24gZWxlbWVudCdzIGVuZCB0YWcgbWF5IGJlIG9tbWl0dGVkIGlmIGEgY29sZ3JvdXAsIHRoZWFkLCB0Zm9vdCwgdGJvZHksIG9yIHRyIGVsZW1lbnQgaXMgc3RhcnRlZC5cbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AoJ2NhcHRpb24nLCBbJ3RhYmxlJ10pO1xuXG4gIH0gZWxzZSBpZiAocGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAndGhlYWQnKSB7XG4gICAgLy8gQSBjb2xncm91cCBlbGVtZW50J3MgZW5kIHRhZyBtYXkgYmUgb21taXR0ZWQgaWYgYSB0aGVhZCwgdGZvb3QsIHRib2R5LCBvciB0ciBlbGVtZW50IGlzIHN0YXJ0ZWQuXG4gICAgLy8gQSBjYXB0aW9uIGVsZW1lbnQncyBlbmQgdGFnIG1heSBiZSBvbW1pdHRlZCBpZiBhIGNvbGdyb3VwLCB0aGVhZCwgdGZvb3QsIHRib2R5LCBvciB0ciBlbGVtZW50IGlzIHN0YXJ0ZWQuXG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuX3RhZ19zdGFjay50cnlfcG9wKCdjYXB0aW9uJywgWyd0YWJsZSddKTtcbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AoJ2NvbGdyb3VwJywgWyd0YWJsZSddKTtcblxuICAgIC8vfSBlbHNlIGlmIChwYXJzZXJfdG9rZW4udGFnX25hbWUgPT09ICdjYXB0aW9uJykge1xuICAgIC8vIERPTkU6IEEgY2FwdGlvbiBlbGVtZW504oCZcyBlbmQgdGFnIG1heSBiZSBvbWl0dGVkIGlmIHRoZSBjYXB0aW9uIGVsZW1lbnQgaXMgbm90IGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGEgc3BhY2UgY2hhcmFjdGVyIG9yIGEgY29tbWVudC5cblxuICB9IGVsc2UgaWYgKHBhcnNlcl90b2tlbi50YWdfbmFtZSA9PT0gJ3Rib2R5JyB8fCBwYXJzZXJfdG9rZW4udGFnX25hbWUgPT09ICd0Zm9vdCcpIHtcbiAgICAvLyBBIHRoZWFkIGVsZW1lbnTigJlzIGVuZCB0YWcgbWF5IGJlIG9taXR0ZWQgaWYgdGhlIHRoZWFkIGVsZW1lbnQgaXMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYSB0Ym9keSBvciB0Zm9vdCBlbGVtZW50LlxuICAgIC8vIEEgdGJvZHkgZWxlbWVudOKAmXMgZW5kIHRhZyBtYXkgYmUgb21pdHRlZCBpZiB0aGUgdGJvZHkgZWxlbWVudCBpcyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhIHRib2R5IG9yIHRmb290IGVsZW1lbnQsIG9yIGlmIHRoZXJlIGlzIG5vIG1vcmUgY29udGVudCBpbiB0aGUgcGFyZW50IGVsZW1lbnQuXG4gICAgLy8gQSBjb2xncm91cCBlbGVtZW50J3MgZW5kIHRhZyBtYXkgYmUgb21taXR0ZWQgaWYgYSB0aGVhZCwgdGZvb3QsIHRib2R5LCBvciB0ciBlbGVtZW50IGlzIHN0YXJ0ZWQuXG4gICAgLy8gQSBjYXB0aW9uIGVsZW1lbnQncyBlbmQgdGFnIG1heSBiZSBvbW1pdHRlZCBpZiBhIGNvbGdyb3VwLCB0aGVhZCwgdGZvb3QsIHRib2R5LCBvciB0ciBlbGVtZW50IGlzIHN0YXJ0ZWQuXG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuX3RhZ19zdGFjay50cnlfcG9wKCdjYXB0aW9uJywgWyd0YWJsZSddKTtcbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AoJ2NvbGdyb3VwJywgWyd0YWJsZSddKTtcbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AoJ3RoZWFkJywgWyd0YWJsZSddKTtcbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AoJ3Rib2R5JywgWyd0YWJsZSddKTtcblxuICAgIC8vfSBlbHNlIGlmIChwYXJzZXJfdG9rZW4udGFnX25hbWUgPT09ICd0Zm9vdCcpIHtcbiAgICAvLyBET05FOiBBIHRmb290IGVsZW1lbnTigJlzIGVuZCB0YWcgbWF5IGJlIG9taXR0ZWQgaWYgdGhlcmUgaXMgbm8gbW9yZSBjb250ZW50IGluIHRoZSBwYXJlbnQgZWxlbWVudC5cblxuICB9IGVsc2UgaWYgKHBhcnNlcl90b2tlbi50YWdfbmFtZSA9PT0gJ3RyJykge1xuICAgIC8vIEEgdHIgZWxlbWVudOKAmXMgZW5kIHRhZyBtYXkgYmUgb21pdHRlZCBpZiB0aGUgdHIgZWxlbWVudCBpcyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhbm90aGVyIHRyIGVsZW1lbnQsIG9yIGlmIHRoZXJlIGlzIG5vIG1vcmUgY29udGVudCBpbiB0aGUgcGFyZW50IGVsZW1lbnQuXG4gICAgLy8gQSBjb2xncm91cCBlbGVtZW50J3MgZW5kIHRhZyBtYXkgYmUgb21taXR0ZWQgaWYgYSB0aGVhZCwgdGZvb3QsIHRib2R5LCBvciB0ciBlbGVtZW50IGlzIHN0YXJ0ZWQuXG4gICAgLy8gQSBjYXB0aW9uIGVsZW1lbnQncyBlbmQgdGFnIG1heSBiZSBvbW1pdHRlZCBpZiBhIGNvbGdyb3VwLCB0aGVhZCwgdGZvb3QsIHRib2R5LCBvciB0ciBlbGVtZW50IGlzIHN0YXJ0ZWQuXG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuX3RhZ19zdGFjay50cnlfcG9wKCdjYXB0aW9uJywgWyd0YWJsZSddKTtcbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AoJ2NvbGdyb3VwJywgWyd0YWJsZSddKTtcbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AoJ3RyJywgWyd0YWJsZScsICd0aGVhZCcsICd0Ym9keScsICd0Zm9vdCddKTtcblxuICB9IGVsc2UgaWYgKHBhcnNlcl90b2tlbi50YWdfbmFtZSA9PT0gJ3RoJyB8fCBwYXJzZXJfdG9rZW4udGFnX25hbWUgPT09ICd0ZCcpIHtcbiAgICAvLyBBIHRkIGVsZW1lbnTigJlzIGVuZCB0YWcgbWF5IGJlIG9taXR0ZWQgaWYgdGhlIHRkIGVsZW1lbnQgaXMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYSB0ZCBvciB0aCBlbGVtZW50LCBvciBpZiB0aGVyZSBpcyBubyBtb3JlIGNvbnRlbnQgaW4gdGhlIHBhcmVudCBlbGVtZW50LlxuICAgIC8vIEEgdGggZWxlbWVudOKAmXMgZW5kIHRhZyBtYXkgYmUgb21pdHRlZCBpZiB0aGUgdGggZWxlbWVudCBpcyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhIHRkIG9yIHRoIGVsZW1lbnQsIG9yIGlmIHRoZXJlIGlzIG5vIG1vcmUgY29udGVudCBpbiB0aGUgcGFyZW50IGVsZW1lbnQuXG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuX3RhZ19zdGFjay50cnlfcG9wKCd0ZCcsIFsndGFibGUnLCAndGhlYWQnLCAndGJvZHknLCAndGZvb3QnLCAndHInXSk7XG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuX3RhZ19zdGFjay50cnlfcG9wKCd0aCcsIFsndGFibGUnLCAndGhlYWQnLCAndGJvZHknLCAndGZvb3QnLCAndHInXSk7XG4gIH1cblxuICAvLyBTdGFydCBlbGVtZW50IG9taXNzaW9uIG5vdCBoYW5kbGVkIGN1cnJlbnRseVxuICAvLyBBIGhlYWQgZWxlbWVudOKAmXMgc3RhcnQgdGFnIG1heSBiZSBvbWl0dGVkIGlmIHRoZSBlbGVtZW50IGlzIGVtcHR5LCBvciBpZiB0aGUgZmlyc3QgdGhpbmcgaW5zaWRlIHRoZSBoZWFkIGVsZW1lbnQgaXMgYW4gZWxlbWVudC5cbiAgLy8gQSB0Ym9keSBlbGVtZW504oCZcyBzdGFydCB0YWcgbWF5IGJlIG9taXR0ZWQgaWYgdGhlIGZpcnN0IHRoaW5nIGluc2lkZSB0aGUgdGJvZHkgZWxlbWVudCBpcyBhIHRyIGVsZW1lbnQsIGFuZCBpZiB0aGUgZWxlbWVudCBpcyBub3QgaW1tZWRpYXRlbHkgcHJlY2VkZWQgYnkgYSB0Ym9keSwgdGhlYWQsIG9yIHRmb290IGVsZW1lbnQgd2hvc2UgZW5kIHRhZyBoYXMgYmVlbiBvbWl0dGVkLiAoSXQgY2Fu4oCZdCBiZSBvbWl0dGVkIGlmIHRoZSBlbGVtZW50IGlzIGVtcHR5LilcbiAgLy8gQSBjb2xncm91cCBlbGVtZW504oCZcyBzdGFydCB0YWcgbWF5IGJlIG9taXR0ZWQgaWYgdGhlIGZpcnN0IHRoaW5nIGluc2lkZSB0aGUgY29sZ3JvdXAgZWxlbWVudCBpcyBhIGNvbCBlbGVtZW50LCBhbmQgaWYgdGhlIGVsZW1lbnQgaXMgbm90IGltbWVkaWF0ZWx5IHByZWNlZGVkIGJ5IGFub3RoZXIgY29sZ3JvdXAgZWxlbWVudCB3aG9zZSBlbmQgdGFnIGhhcyBiZWVuIG9taXR0ZWQuIChJdCBjYW7igJl0IGJlIG9taXR0ZWQgaWYgdGhlIGVsZW1lbnQgaXMgZW1wdHkuKVxuXG4gIC8vIEZpeCB1cCB0aGUgcGFyZW50IG9mIHRoZSBwYXJzZXIgdG9rZW5cbiAgcGFyc2VyX3Rva2VuLnBhcmVudCA9IHRoaXMuX3RhZ19zdGFjay5nZXRfcGFyc2VyX3Rva2VuKCk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzLkJlYXV0aWZpZXIgPSBCZWF1dGlmaWVyO1xuXG5cbi8qKiovIH0pLFxuLyogMjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbnZhciBCYXNlT3B0aW9ucyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDYpLk9wdGlvbnMpO1xuXG5mdW5jdGlvbiBPcHRpb25zKG9wdGlvbnMpIHtcbiAgQmFzZU9wdGlvbnMuY2FsbCh0aGlzLCBvcHRpb25zLCAnaHRtbCcpO1xuICBpZiAodGhpcy50ZW1wbGF0aW5nLmxlbmd0aCA9PT0gMSAmJiB0aGlzLnRlbXBsYXRpbmdbMF0gPT09ICdhdXRvJykge1xuICAgIHRoaXMudGVtcGxhdGluZyA9IFsnZGphbmdvJywgJ2VyYicsICdoYW5kbGViYXJzJywgJ3BocCddO1xuICB9XG5cbiAgdGhpcy5pbmRlbnRfaW5uZXJfaHRtbCA9IHRoaXMuX2dldF9ib29sZWFuKCdpbmRlbnRfaW5uZXJfaHRtbCcpO1xuICB0aGlzLmluZGVudF9ib2R5X2lubmVyX2h0bWwgPSB0aGlzLl9nZXRfYm9vbGVhbignaW5kZW50X2JvZHlfaW5uZXJfaHRtbCcsIHRydWUpO1xuICB0aGlzLmluZGVudF9oZWFkX2lubmVyX2h0bWwgPSB0aGlzLl9nZXRfYm9vbGVhbignaW5kZW50X2hlYWRfaW5uZXJfaHRtbCcsIHRydWUpO1xuXG4gIHRoaXMuaW5kZW50X2hhbmRsZWJhcnMgPSB0aGlzLl9nZXRfYm9vbGVhbignaW5kZW50X2hhbmRsZWJhcnMnLCB0cnVlKTtcbiAgdGhpcy53cmFwX2F0dHJpYnV0ZXMgPSB0aGlzLl9nZXRfc2VsZWN0aW9uKCd3cmFwX2F0dHJpYnV0ZXMnLFxuICAgIFsnYXV0bycsICdmb3JjZScsICdmb3JjZS1hbGlnbmVkJywgJ2ZvcmNlLWV4cGFuZC1tdWx0aWxpbmUnLCAnYWxpZ25lZC1tdWx0aXBsZScsICdwcmVzZXJ2ZScsICdwcmVzZXJ2ZS1hbGlnbmVkJ10pO1xuICB0aGlzLndyYXBfYXR0cmlidXRlc19taW5fYXR0cnMgPSB0aGlzLl9nZXRfbnVtYmVyKCd3cmFwX2F0dHJpYnV0ZXNfbWluX2F0dHJzJywgMik7XG4gIHRoaXMud3JhcF9hdHRyaWJ1dGVzX2luZGVudF9zaXplID0gdGhpcy5fZ2V0X251bWJlcignd3JhcF9hdHRyaWJ1dGVzX2luZGVudF9zaXplJywgdGhpcy5pbmRlbnRfc2l6ZSk7XG4gIHRoaXMuZXh0cmFfbGluZXJzID0gdGhpcy5fZ2V0X2FycmF5KCdleHRyYV9saW5lcnMnLCBbJ2hlYWQnLCAnYm9keScsICcvaHRtbCddKTtcblxuICAvLyBCbG9jayB2cyBpbmxpbmUgZWxlbWVudHNcbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9CbG9jay1sZXZlbF9lbGVtZW50c1xuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0lubGluZV9lbGVtZW50c1xuICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZG9tLmh0bWwjcGhyYXNpbmctY29udGVudFxuICB0aGlzLmlubGluZSA9IHRoaXMuX2dldF9hcnJheSgnaW5saW5lJywgW1xuICAgICdhJywgJ2FiYnInLCAnYXJlYScsICdhdWRpbycsICdiJywgJ2JkaScsICdiZG8nLCAnYnInLCAnYnV0dG9uJywgJ2NhbnZhcycsICdjaXRlJyxcbiAgICAnY29kZScsICdkYXRhJywgJ2RhdGFsaXN0JywgJ2RlbCcsICdkZm4nLCAnZW0nLCAnZW1iZWQnLCAnaScsICdpZnJhbWUnLCAnaW1nJyxcbiAgICAnaW5wdXQnLCAnaW5zJywgJ2tiZCcsICdrZXlnZW4nLCAnbGFiZWwnLCAnbWFwJywgJ21hcmsnLCAnbWF0aCcsICdtZXRlcicsICdub3NjcmlwdCcsXG4gICAgJ29iamVjdCcsICdvdXRwdXQnLCAncHJvZ3Jlc3MnLCAncScsICdydWJ5JywgJ3MnLCAnc2FtcCcsIC8qICdzY3JpcHQnLCAqLyAnc2VsZWN0JywgJ3NtYWxsJyxcbiAgICAnc3BhbicsICdzdHJvbmcnLCAnc3ViJywgJ3N1cCcsICdzdmcnLCAndGVtcGxhdGUnLCAndGV4dGFyZWEnLCAndGltZScsICd1JywgJ3ZhcicsXG4gICAgJ3ZpZGVvJywgJ3dicicsICd0ZXh0JyxcbiAgICAvLyBvYnNvbGV0ZSBpbmxpbmUgdGFnc1xuICAgICdhY3JvbnltJywgJ2JpZycsICdzdHJpa2UnLCAndHQnXG4gIF0pO1xuICB0aGlzLmlubGluZV9jdXN0b21fZWxlbWVudHMgPSB0aGlzLl9nZXRfYm9vbGVhbignaW5saW5lX2N1c3RvbV9lbGVtZW50cycsIHRydWUpO1xuICB0aGlzLnZvaWRfZWxlbWVudHMgPSB0aGlzLl9nZXRfYXJyYXkoJ3ZvaWRfZWxlbWVudHMnLCBbXG4gICAgLy8gSFRMTSB2b2lkIGVsZW1lbnRzIC0gYWthIHNlbGYtY2xvc2luZyB0YWdzIC0gYWthIHNpbmdsZXRvbnNcbiAgICAvLyBodHRwczovL3d3dy53My5vcmcvaHRtbC93Zy9kcmFmdHMvaHRtbC9tYXN0ZXIvc3ludGF4Lmh0bWwjdm9pZC1lbGVtZW50c1xuICAgICdhcmVhJywgJ2Jhc2UnLCAnYnInLCAnY29sJywgJ2VtYmVkJywgJ2hyJywgJ2ltZycsICdpbnB1dCcsICdrZXlnZW4nLFxuICAgICdsaW5rJywgJ21lbnVpdGVtJywgJ21ldGEnLCAncGFyYW0nLCAnc291cmNlJywgJ3RyYWNrJywgJ3dicicsXG4gICAgLy8gTk9URTogT3B0aW9uYWwgdGFncyBhcmUgdG9vIGNvbXBsZXggZm9yIGEgc2ltcGxlIGxpc3RcbiAgICAvLyB0aGV5IGFyZSBoYXJkIGNvZGVkIGluIF9kb19vcHRpb25hbF9lbmRfZWxlbWVudFxuXG4gICAgLy8gRG9jdHlwZSBhbmQgeG1sIGVsZW1lbnRzXG4gICAgJyFkb2N0eXBlJywgJz94bWwnLFxuXG4gICAgLy8gb2Jzb2xldGUgdGFnc1xuICAgIC8vIGJhc2Vmb250OiBodHRwczovL3d3dy5jb21wdXRlcmhvcGUuY29tL2phcmdvbi9oL2h0bWwtYmFzZWZvbnQtdGFnLmh0bVxuICAgIC8vIGlzbmRleDogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L2lzaW5kZXhcbiAgICAnYmFzZWZvbnQnLCAnaXNpbmRleCdcbiAgXSk7XG4gIHRoaXMudW5mb3JtYXR0ZWQgPSB0aGlzLl9nZXRfYXJyYXkoJ3VuZm9ybWF0dGVkJywgW10pO1xuICB0aGlzLmNvbnRlbnRfdW5mb3JtYXR0ZWQgPSB0aGlzLl9nZXRfYXJyYXkoJ2NvbnRlbnRfdW5mb3JtYXR0ZWQnLCBbXG4gICAgJ3ByZScsICd0ZXh0YXJlYSdcbiAgXSk7XG4gIHRoaXMudW5mb3JtYXR0ZWRfY29udGVudF9kZWxpbWl0ZXIgPSB0aGlzLl9nZXRfY2hhcmFjdGVycygndW5mb3JtYXR0ZWRfY29udGVudF9kZWxpbWl0ZXInKTtcbiAgdGhpcy5pbmRlbnRfc2NyaXB0cyA9IHRoaXMuX2dldF9zZWxlY3Rpb24oJ2luZGVudF9zY3JpcHRzJywgWydub3JtYWwnLCAna2VlcCcsICdzZXBhcmF0ZSddKTtcblxufVxuT3B0aW9ucy5wcm90b3R5cGUgPSBuZXcgQmFzZU9wdGlvbnMoKTtcblxuXG5cbm1vZHVsZS5leHBvcnRzLk9wdGlvbnMgPSBPcHRpb25zO1xuXG5cbi8qKiovIH0pLFxuLyogMjEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbnZhciBCYXNlVG9rZW5pemVyID0gKF9fd2VicGFja19yZXF1aXJlX18oOSkuVG9rZW5pemVyKTtcbnZhciBCQVNFVE9LRU4gPSAoX193ZWJwYWNrX3JlcXVpcmVfXyg5KS5UT0tFTik7XG52YXIgRGlyZWN0aXZlcyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKS5EaXJlY3RpdmVzKTtcbnZhciBUZW1wbGF0YWJsZVBhdHRlcm4gPSAoX193ZWJwYWNrX3JlcXVpcmVfXygxNCkuVGVtcGxhdGFibGVQYXR0ZXJuKTtcbnZhciBQYXR0ZXJuID0gKF9fd2VicGFja19yZXF1aXJlX18oMTIpLlBhdHRlcm4pO1xuXG52YXIgVE9LRU4gPSB7XG4gIFRBR19PUEVOOiAnVEtfVEFHX09QRU4nLFxuICBUQUdfQ0xPU0U6ICdUS19UQUdfQ0xPU0UnLFxuICBDT05UUk9MX0ZMT1dfT1BFTjogJ1RLX0NPTlRST0xfRkxPV19PUEVOJyxcbiAgQ09OVFJPTF9GTE9XX0NMT1NFOiAnVEtfQ09OVFJPTF9GTE9XX0NMT1NFJyxcbiAgQVRUUklCVVRFOiAnVEtfQVRUUklCVVRFJyxcbiAgRVFVQUxTOiAnVEtfRVFVQUxTJyxcbiAgVkFMVUU6ICdUS19WQUxVRScsXG4gIENPTU1FTlQ6ICdUS19DT01NRU5UJyxcbiAgVEVYVDogJ1RLX1RFWFQnLFxuICBVTktOT1dOOiAnVEtfVU5LTk9XTicsXG4gIFNUQVJUOiBCQVNFVE9LRU4uU1RBUlQsXG4gIFJBVzogQkFTRVRPS0VOLlJBVyxcbiAgRU9GOiBCQVNFVE9LRU4uRU9GXG59O1xuXG52YXIgZGlyZWN0aXZlc19jb3JlID0gbmV3IERpcmVjdGl2ZXMoLzxcXCEtLS8sIC8tLT4vKTtcblxudmFyIFRva2VuaXplciA9IGZ1bmN0aW9uKGlucHV0X3N0cmluZywgb3B0aW9ucykge1xuICBCYXNlVG9rZW5pemVyLmNhbGwodGhpcywgaW5wdXRfc3RyaW5nLCBvcHRpb25zKTtcbiAgdGhpcy5fY3VycmVudF90YWdfbmFtZSA9ICcnO1xuXG4gIC8vIFdvcmRzIGVuZCBhdCB3aGl0ZXNwYWNlIG9yIHdoZW4gYSB0YWcgc3RhcnRzXG4gIC8vIGlmIHdlIGFyZSBpbmRlbnRpbmcgaGFuZGxlYmFycywgdGhleSBhcmUgY29uc2lkZXJlZCB0YWdzXG4gIHZhciB0ZW1wbGF0YWJsZV9yZWFkZXIgPSBuZXcgVGVtcGxhdGFibGVQYXR0ZXJuKHRoaXMuX2lucHV0KS5yZWFkX29wdGlvbnModGhpcy5fb3B0aW9ucyk7XG4gIHZhciBwYXR0ZXJuX3JlYWRlciA9IG5ldyBQYXR0ZXJuKHRoaXMuX2lucHV0KTtcblxuICB0aGlzLl9fcGF0dGVybnMgPSB7XG4gICAgd29yZDogdGVtcGxhdGFibGVfcmVhZGVyLnVudGlsKC9bXFxuXFxyXFx0IDxdLyksXG4gICAgd29yZF9jb250cm9sX2Zsb3dfY2xvc2VfZXhjbHVkZWQ6IHRlbXBsYXRhYmxlX3JlYWRlci51bnRpbCgvW1xcblxcclxcdCA8fV0vKSxcbiAgICBzaW5nbGVfcXVvdGU6IHRlbXBsYXRhYmxlX3JlYWRlci51bnRpbF9hZnRlcigvJy8pLFxuICAgIGRvdWJsZV9xdW90ZTogdGVtcGxhdGFibGVfcmVhZGVyLnVudGlsX2FmdGVyKC9cIi8pLFxuICAgIGF0dHJpYnV0ZTogdGVtcGxhdGFibGVfcmVhZGVyLnVudGlsKC9bXFxuXFxyXFx0ID0+XXxcXC8+LyksXG4gICAgZWxlbWVudF9uYW1lOiB0ZW1wbGF0YWJsZV9yZWFkZXIudW50aWwoL1tcXG5cXHJcXHQgPlxcL10vKSxcblxuICAgIGFuZ3VsYXJfY29udHJvbF9mbG93X3N0YXJ0OiBwYXR0ZXJuX3JlYWRlci5tYXRjaGluZygvXFxAW2EtekEtWl0rW14oe10qWyh7XS8pLFxuICAgIGhhbmRsZWJhcnNfY29tbWVudDogcGF0dGVybl9yZWFkZXIuc3RhcnRpbmdfd2l0aCgve3shLS0vKS51bnRpbF9hZnRlcigvLS19fS8pLFxuICAgIGhhbmRsZWJhcnM6IHBhdHRlcm5fcmVhZGVyLnN0YXJ0aW5nX3dpdGgoL3t7LykudW50aWxfYWZ0ZXIoL319LyksXG4gICAgaGFuZGxlYmFyc19vcGVuOiBwYXR0ZXJuX3JlYWRlci51bnRpbCgvW1xcblxcclxcdCB9XS8pLFxuICAgIGhhbmRsZWJhcnNfcmF3X2Nsb3NlOiBwYXR0ZXJuX3JlYWRlci51bnRpbCgvfX0vKSxcbiAgICBjb21tZW50OiBwYXR0ZXJuX3JlYWRlci5zdGFydGluZ193aXRoKC88IS0tLykudW50aWxfYWZ0ZXIoLy0tPi8pLFxuICAgIGNkYXRhOiBwYXR0ZXJuX3JlYWRlci5zdGFydGluZ193aXRoKC88IVxcW0NEQVRBXFxbLykudW50aWxfYWZ0ZXIoL11dPi8pLFxuICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbmRpdGlvbmFsX2NvbW1lbnRcbiAgICBjb25kaXRpb25hbF9jb21tZW50OiBwYXR0ZXJuX3JlYWRlci5zdGFydGluZ193aXRoKC88IVxcWy8pLnVudGlsX2FmdGVyKC9dPi8pLFxuICAgIHByb2Nlc3Npbmc6IHBhdHRlcm5fcmVhZGVyLnN0YXJ0aW5nX3dpdGgoLzxcXD8vKS51bnRpbF9hZnRlcigvXFw/Pi8pXG4gIH07XG5cbiAgaWYgKHRoaXMuX29wdGlvbnMuaW5kZW50X2hhbmRsZWJhcnMpIHtcbiAgICB0aGlzLl9fcGF0dGVybnMud29yZCA9IHRoaXMuX19wYXR0ZXJucy53b3JkLmV4Y2x1ZGUoJ2hhbmRsZWJhcnMnKTtcbiAgICB0aGlzLl9fcGF0dGVybnMud29yZF9jb250cm9sX2Zsb3dfY2xvc2VfZXhjbHVkZWQgPSB0aGlzLl9fcGF0dGVybnMud29yZF9jb250cm9sX2Zsb3dfY2xvc2VfZXhjbHVkZWQuZXhjbHVkZSgnaGFuZGxlYmFycycpO1xuICB9XG5cbiAgdGhpcy5fdW5mb3JtYXR0ZWRfY29udGVudF9kZWxpbWl0ZXIgPSBudWxsO1xuXG4gIGlmICh0aGlzLl9vcHRpb25zLnVuZm9ybWF0dGVkX2NvbnRlbnRfZGVsaW1pdGVyKSB7XG4gICAgdmFyIGxpdGVyYWxfcmVnZXhwID0gdGhpcy5faW5wdXQuZ2V0X2xpdGVyYWxfcmVnZXhwKHRoaXMuX29wdGlvbnMudW5mb3JtYXR0ZWRfY29udGVudF9kZWxpbWl0ZXIpO1xuICAgIHRoaXMuX19wYXR0ZXJucy51bmZvcm1hdHRlZF9jb250ZW50X2RlbGltaXRlciA9XG4gICAgICBwYXR0ZXJuX3JlYWRlci5tYXRjaGluZyhsaXRlcmFsX3JlZ2V4cClcbiAgICAgIC51bnRpbF9hZnRlcihsaXRlcmFsX3JlZ2V4cCk7XG4gIH1cbn07XG5Ub2tlbml6ZXIucHJvdG90eXBlID0gbmV3IEJhc2VUb2tlbml6ZXIoKTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5faXNfY29tbWVudCA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4pIHsgLy8ganNoaW50IHVudXNlZDpmYWxzZVxuICByZXR1cm4gZmFsc2U7IC8vY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5DT01NRU5UIHx8IGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uVU5LTk9XTjtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX2lzX29wZW5pbmcgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7XG4gIHJldHVybiBjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLlRBR19PUEVOIHx8IGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uQ09OVFJPTF9GTE9XX09QRU47XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9pc19jbG9zaW5nID0gZnVuY3Rpb24oY3VycmVudF90b2tlbiwgb3Blbl90b2tlbikge1xuICByZXR1cm4gKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uVEFHX0NMT1NFICYmXG4gICAgKG9wZW5fdG9rZW4gJiYgKFxuICAgICAgKChjdXJyZW50X3Rva2VuLnRleHQgPT09ICc+JyB8fCBjdXJyZW50X3Rva2VuLnRleHQgPT09ICcvPicpICYmIG9wZW5fdG9rZW4udGV4dFswXSA9PT0gJzwnKSB8fFxuICAgICAgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJ319JyAmJiBvcGVuX3Rva2VuLnRleHRbMF0gPT09ICd7JyAmJiBvcGVuX3Rva2VuLnRleHRbMV0gPT09ICd7JykpKVxuICApIHx8IChjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLkNPTlRST0xfRkxPV19DTE9TRSAmJlxuICAgIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICd9JyAmJiBvcGVuX3Rva2VuLnRleHQuZW5kc1dpdGgoJ3snKSkpO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fcmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY3VycmVudF90YWdfbmFtZSA9ICcnO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fZ2V0X25leHRfdG9rZW4gPSBmdW5jdGlvbihwcmV2aW91c190b2tlbiwgb3Blbl90b2tlbikgeyAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXG4gIHZhciB0b2tlbiA9IG51bGw7XG4gIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG4gIHZhciBjID0gdGhpcy5faW5wdXQucGVlaygpO1xuXG4gIGlmIChjID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5FT0YsICcnKTtcbiAgfVxuXG4gIHRva2VuID0gdG9rZW4gfHwgdGhpcy5fcmVhZF9vcGVuX2hhbmRsZWJhcnMoYywgb3Blbl90b2tlbik7XG4gIHRva2VuID0gdG9rZW4gfHwgdGhpcy5fcmVhZF9hdHRyaWJ1dGUoYywgcHJldmlvdXNfdG9rZW4sIG9wZW5fdG9rZW4pO1xuICB0b2tlbiA9IHRva2VuIHx8IHRoaXMuX3JlYWRfY2xvc2UoYywgb3Blbl90b2tlbik7XG4gIHRva2VuID0gdG9rZW4gfHwgdGhpcy5fcmVhZF9jb250cm9sX2Zsb3dzKGMsIG9wZW5fdG9rZW4pO1xuICB0b2tlbiA9IHRva2VuIHx8IHRoaXMuX3JlYWRfcmF3X2NvbnRlbnQoYywgcHJldmlvdXNfdG9rZW4sIG9wZW5fdG9rZW4pO1xuICB0b2tlbiA9IHRva2VuIHx8IHRoaXMuX3JlYWRfY29udGVudF93b3JkKGMsIG9wZW5fdG9rZW4pO1xuICB0b2tlbiA9IHRva2VuIHx8IHRoaXMuX3JlYWRfY29tbWVudF9vcl9jZGF0YShjKTtcbiAgdG9rZW4gPSB0b2tlbiB8fCB0aGlzLl9yZWFkX3Byb2Nlc3NpbmcoYyk7XG4gIHRva2VuID0gdG9rZW4gfHwgdGhpcy5fcmVhZF9vcGVuKGMsIG9wZW5fdG9rZW4pO1xuICB0b2tlbiA9IHRva2VuIHx8IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5VTktOT1dOLCB0aGlzLl9pbnB1dC5uZXh0KCkpO1xuXG4gIHJldHVybiB0b2tlbjtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3JlYWRfY29tbWVudF9vcl9jZGF0YSA9IGZ1bmN0aW9uKGMpIHsgLy8ganNoaW50IHVudXNlZDpmYWxzZVxuICB2YXIgdG9rZW4gPSBudWxsO1xuICB2YXIgcmVzdWx0aW5nX3N0cmluZyA9IG51bGw7XG4gIHZhciBkaXJlY3RpdmVzID0gbnVsbDtcblxuICBpZiAoYyA9PT0gJzwnKSB7XG4gICAgdmFyIHBlZWsxID0gdGhpcy5faW5wdXQucGVlaygxKTtcbiAgICAvLyBXZSB0cmVhdCBhbGwgY29tbWVudHMgYXMgbGl0ZXJhbHMsIGV2ZW4gbW9yZSB0aGFuIHByZWZvcm1hdHRlZCB0YWdzXG4gICAgLy8gd2Ugb25seSBsb29rIGZvciB0aGUgYXBwcm9wcmlhdGUgY2xvc2luZyBtYXJrZXJcbiAgICBpZiAocGVlazEgPT09ICchJykge1xuICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHRoaXMuX19wYXR0ZXJucy5jb21tZW50LnJlYWQoKTtcblxuICAgICAgLy8gb25seSBwcm9jZXNzIGRpcmVjdGl2ZSBvbiBodG1sIGNvbW1lbnRzXG4gICAgICBpZiAocmVzdWx0aW5nX3N0cmluZykge1xuICAgICAgICBkaXJlY3RpdmVzID0gZGlyZWN0aXZlc19jb3JlLmdldF9kaXJlY3RpdmVzKHJlc3VsdGluZ19zdHJpbmcpO1xuICAgICAgICBpZiAoZGlyZWN0aXZlcyAmJiBkaXJlY3RpdmVzLmlnbm9yZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICAgIHJlc3VsdGluZ19zdHJpbmcgKz0gZGlyZWN0aXZlc19jb3JlLnJlYWRJZ25vcmVkKHRoaXMuX2lucHV0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHRoaXMuX19wYXR0ZXJucy5jZGF0YS5yZWFkKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdGluZ19zdHJpbmcpIHtcbiAgICAgIHRva2VuID0gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLkNPTU1FTlQsIHJlc3VsdGluZ19zdHJpbmcpO1xuICAgICAgdG9rZW4uZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZXM7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRva2VuO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fcmVhZF9wcm9jZXNzaW5nID0gZnVuY3Rpb24oYykgeyAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXG4gIHZhciB0b2tlbiA9IG51bGw7XG4gIHZhciByZXN1bHRpbmdfc3RyaW5nID0gbnVsbDtcbiAgdmFyIGRpcmVjdGl2ZXMgPSBudWxsO1xuXG4gIGlmIChjID09PSAnPCcpIHtcbiAgICB2YXIgcGVlazEgPSB0aGlzLl9pbnB1dC5wZWVrKDEpO1xuICAgIGlmIChwZWVrMSA9PT0gJyEnIHx8IHBlZWsxID09PSAnPycpIHtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9fcGF0dGVybnMuY29uZGl0aW9uYWxfY29tbWVudC5yZWFkKCk7XG4gICAgICByZXN1bHRpbmdfc3RyaW5nID0gcmVzdWx0aW5nX3N0cmluZyB8fCB0aGlzLl9fcGF0dGVybnMucHJvY2Vzc2luZy5yZWFkKCk7XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdGluZ19zdHJpbmcpIHtcbiAgICAgIHRva2VuID0gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLkNPTU1FTlQsIHJlc3VsdGluZ19zdHJpbmcpO1xuICAgICAgdG9rZW4uZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZXM7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRva2VuO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fcmVhZF9vcGVuID0gZnVuY3Rpb24oYywgb3Blbl90b2tlbikge1xuICB2YXIgcmVzdWx0aW5nX3N0cmluZyA9IG51bGw7XG4gIHZhciB0b2tlbiA9IG51bGw7XG4gIGlmICghb3Blbl90b2tlbiB8fCBvcGVuX3Rva2VuLnR5cGUgPT09IFRPS0VOLkNPTlRST0xfRkxPV19PUEVOKSB7XG4gICAgaWYgKGMgPT09ICc8Jykge1xuXG4gICAgICByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5faW5wdXQubmV4dCgpO1xuICAgICAgaWYgKHRoaXMuX2lucHV0LnBlZWsoKSA9PT0gJy8nKSB7XG4gICAgICAgIHJlc3VsdGluZ19zdHJpbmcgKz0gdGhpcy5faW5wdXQubmV4dCgpO1xuICAgICAgfVxuICAgICAgcmVzdWx0aW5nX3N0cmluZyArPSB0aGlzLl9fcGF0dGVybnMuZWxlbWVudF9uYW1lLnJlYWQoKTtcbiAgICAgIHRva2VuID0gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLlRBR19PUEVOLCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRva2VuO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fcmVhZF9vcGVuX2hhbmRsZWJhcnMgPSBmdW5jdGlvbihjLCBvcGVuX3Rva2VuKSB7XG4gIHZhciByZXN1bHRpbmdfc3RyaW5nID0gbnVsbDtcbiAgdmFyIHRva2VuID0gbnVsbDtcbiAgaWYgKCFvcGVuX3Rva2VuIHx8IG9wZW5fdG9rZW4udHlwZSA9PT0gVE9LRU4uQ09OVFJPTF9GTE9XX09QRU4pIHtcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5pbmRlbnRfaGFuZGxlYmFycyAmJiBjID09PSAneycgJiYgdGhpcy5faW5wdXQucGVlaygxKSA9PT0gJ3snKSB7XG4gICAgICBpZiAodGhpcy5faW5wdXQucGVlaygyKSA9PT0gJyEnKSB7XG4gICAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9fcGF0dGVybnMuaGFuZGxlYmFyc19jb21tZW50LnJlYWQoKTtcbiAgICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHJlc3VsdGluZ19zdHJpbmcgfHwgdGhpcy5fX3BhdHRlcm5zLmhhbmRsZWJhcnMucmVhZCgpO1xuICAgICAgICB0b2tlbiA9IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5DT01NRU5ULCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9fcGF0dGVybnMuaGFuZGxlYmFyc19vcGVuLnJlYWQoKTtcbiAgICAgICAgdG9rZW4gPSB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uVEFHX09QRU4sIHJlc3VsdGluZ19zdHJpbmcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdG9rZW47XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZWFkX2NvbnRyb2xfZmxvd3MgPSBmdW5jdGlvbihjLCBvcGVuX3Rva2VuKSB7XG4gIHZhciByZXN1bHRpbmdfc3RyaW5nID0gJyc7XG4gIHZhciB0b2tlbiA9IG51bGw7XG4gIC8vIE9ubHkgY2hlY2sgZm9yIGNvbnRyb2wgZmxvd3MgaWYgYW5ndWxhciB0ZW1wbGF0aW5nIGlzIHNldCBBTkQgaW5kZW50aW5nIGlzIHNldFxuICBpZiAoIXRoaXMuX29wdGlvbnMudGVtcGxhdGluZy5pbmNsdWRlcygnYW5ndWxhcicpIHx8ICF0aGlzLl9vcHRpb25zLmluZGVudF9oYW5kbGViYXJzKSB7XG4gICAgcmV0dXJuIHRva2VuO1xuICB9XG5cbiAgaWYgKGMgPT09ICdAJykge1xuICAgIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9fcGF0dGVybnMuYW5ndWxhcl9jb250cm9sX2Zsb3dfc3RhcnQucmVhZCgpO1xuICAgIGlmIChyZXN1bHRpbmdfc3RyaW5nID09PSAnJykge1xuICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH1cblxuICAgIHZhciBvcGVuaW5nX3BhcmVudGhlc2VzX2NvdW50ID0gcmVzdWx0aW5nX3N0cmluZy5lbmRzV2l0aCgnKCcpID8gMSA6IDA7XG4gICAgdmFyIGNsb3NpbmdfcGFyZW50aGVzZXNfY291bnQgPSAwO1xuICAgIC8vIFRoZSBvcGVuaW5nIGJyYWNlIG9mIHRoZSBjb250cm9sIGZsb3cgaXMgd2hlcmUgdGhlIG51bWJlciBvZiBvcGVuaW5nIGFuZCBjbG9zaW5nIHBhcmVudGhlc2VzIGVxdWFsXG4gICAgLy8gZS5nLiBAaWYoe3ZhbHVlOiB0cnVlfSAhPT0gbnVsbCkgeyBcbiAgICB3aGlsZSAoIShyZXN1bHRpbmdfc3RyaW5nLmVuZHNXaXRoKCd7JykgJiYgb3BlbmluZ19wYXJlbnRoZXNlc19jb3VudCA9PT0gY2xvc2luZ19wYXJlbnRoZXNlc19jb3VudCkpIHtcbiAgICAgIHZhciBuZXh0X2NoYXIgPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgICBpZiAobmV4dF9jaGFyID09PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmIChuZXh0X2NoYXIgPT09ICcoJykge1xuICAgICAgICBvcGVuaW5nX3BhcmVudGhlc2VzX2NvdW50Kys7XG4gICAgICB9IGVsc2UgaWYgKG5leHRfY2hhciA9PT0gJyknKSB7XG4gICAgICAgIGNsb3NpbmdfcGFyZW50aGVzZXNfY291bnQrKztcbiAgICAgIH1cbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgKz0gbmV4dF9jaGFyO1xuICAgIH1cbiAgICB0b2tlbiA9IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5DT05UUk9MX0ZMT1dfT1BFTiwgcmVzdWx0aW5nX3N0cmluZyk7XG4gIH0gZWxzZSBpZiAoYyA9PT0gJ30nICYmIG9wZW5fdG9rZW4gJiYgb3Blbl90b2tlbi50eXBlID09PSBUT0tFTi5DT05UUk9MX0ZMT1dfT1BFTikge1xuICAgIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgdG9rZW4gPSB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uQ09OVFJPTF9GTE9XX0NMT1NFLCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgfVxuICByZXR1cm4gdG9rZW47XG59O1xuXG5cblRva2VuaXplci5wcm90b3R5cGUuX3JlYWRfY2xvc2UgPSBmdW5jdGlvbihjLCBvcGVuX3Rva2VuKSB7XG4gIHZhciByZXN1bHRpbmdfc3RyaW5nID0gbnVsbDtcbiAgdmFyIHRva2VuID0gbnVsbDtcbiAgaWYgKG9wZW5fdG9rZW4gJiYgb3Blbl90b2tlbi50eXBlID09PSBUT0tFTi5UQUdfT1BFTikge1xuICAgIGlmIChvcGVuX3Rva2VuLnRleHRbMF0gPT09ICc8JyAmJiAoYyA9PT0gJz4nIHx8IChjID09PSAnLycgJiYgdGhpcy5faW5wdXQucGVlaygxKSA9PT0gJz4nKSkpIHtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgICBpZiAoYyA9PT0gJy8nKSB7IC8vICBmb3IgY2xvc2UgdGFnIFwiLz5cIlxuICAgICAgICByZXN1bHRpbmdfc3RyaW5nICs9IHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICAgIH1cbiAgICAgIHRva2VuID0gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLlRBR19DTE9TRSwgcmVzdWx0aW5nX3N0cmluZyk7XG4gICAgfSBlbHNlIGlmIChvcGVuX3Rva2VuLnRleHRbMF0gPT09ICd7JyAmJiBjID09PSAnfScgJiYgdGhpcy5faW5wdXQucGVlaygxKSA9PT0gJ30nKSB7XG4gICAgICB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgICB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgICB0b2tlbiA9IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5UQUdfQ0xPU0UsICd9fScpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0b2tlbjtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3JlYWRfYXR0cmlidXRlID0gZnVuY3Rpb24oYywgcHJldmlvdXNfdG9rZW4sIG9wZW5fdG9rZW4pIHtcbiAgdmFyIHRva2VuID0gbnVsbDtcbiAgdmFyIHJlc3VsdGluZ19zdHJpbmcgPSAnJztcbiAgaWYgKG9wZW5fdG9rZW4gJiYgb3Blbl90b2tlbi50ZXh0WzBdID09PSAnPCcpIHtcblxuICAgIGlmIChjID09PSAnPScpIHtcbiAgICAgIHRva2VuID0gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLkVRVUFMUywgdGhpcy5faW5wdXQubmV4dCgpKTtcbiAgICB9IGVsc2UgaWYgKGMgPT09ICdcIicgfHwgYyA9PT0gXCInXCIpIHtcbiAgICAgIHZhciBjb250ZW50ID0gdGhpcy5faW5wdXQubmV4dCgpO1xuICAgICAgaWYgKGMgPT09ICdcIicpIHtcbiAgICAgICAgY29udGVudCArPSB0aGlzLl9fcGF0dGVybnMuZG91YmxlX3F1b3RlLnJlYWQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRlbnQgKz0gdGhpcy5fX3BhdHRlcm5zLnNpbmdsZV9xdW90ZS5yZWFkKCk7XG4gICAgICB9XG4gICAgICB0b2tlbiA9IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5WQUxVRSwgY29udGVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9fcGF0dGVybnMuYXR0cmlidXRlLnJlYWQoKTtcblxuICAgICAgaWYgKHJlc3VsdGluZ19zdHJpbmcpIHtcbiAgICAgICAgaWYgKHByZXZpb3VzX3Rva2VuLnR5cGUgPT09IFRPS0VOLkVRVUFMUykge1xuICAgICAgICAgIHRva2VuID0gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLlZBTFVFLCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b2tlbiA9IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5BVFRSSUJVVEUsIHJlc3VsdGluZ19zdHJpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0b2tlbjtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX2lzX2NvbnRlbnRfdW5mb3JtYXR0ZWQgPSBmdW5jdGlvbih0YWdfbmFtZSkge1xuICAvLyB2b2lkX2VsZW1lbnRzIGhhdmUgbm8gY29udGVudCBhbmQgc28gY2Fubm90IGhhdmUgdW5mb3JtYXR0ZWQgY29udGVudFxuICAvLyBzY3JpcHQgYW5kIHN0eWxlIHRhZ3Mgc2hvdWxkIGFsd2F5cyBiZSByZWFkIGFzIHVuZm9ybWF0dGVkIGNvbnRlbnRcbiAgLy8gZmluYWxseSBjb250ZW50X3VuZm9ybWF0dGVkIGFuZCB1bmZvcm1hdHRlZCBlbGVtZW50IGNvbnRlbnRzIGFyZSB1bmZvcm1hdHRlZFxuICByZXR1cm4gdGhpcy5fb3B0aW9ucy52b2lkX2VsZW1lbnRzLmluZGV4T2YodGFnX25hbWUpID09PSAtMSAmJlxuICAgICh0aGlzLl9vcHRpb25zLmNvbnRlbnRfdW5mb3JtYXR0ZWQuaW5kZXhPZih0YWdfbmFtZSkgIT09IC0xIHx8XG4gICAgICB0aGlzLl9vcHRpb25zLnVuZm9ybWF0dGVkLmluZGV4T2YodGFnX25hbWUpICE9PSAtMSk7XG59O1xuXG5cblRva2VuaXplci5wcm90b3R5cGUuX3JlYWRfcmF3X2NvbnRlbnQgPSBmdW5jdGlvbihjLCBwcmV2aW91c190b2tlbiwgb3Blbl90b2tlbikgeyAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXG4gIHZhciByZXN1bHRpbmdfc3RyaW5nID0gJyc7XG4gIGlmIChvcGVuX3Rva2VuICYmIG9wZW5fdG9rZW4udGV4dFswXSA9PT0gJ3snKSB7XG4gICAgcmVzdWx0aW5nX3N0cmluZyA9IHRoaXMuX19wYXR0ZXJucy5oYW5kbGViYXJzX3Jhd19jbG9zZS5yZWFkKCk7XG4gIH0gZWxzZSBpZiAocHJldmlvdXNfdG9rZW4udHlwZSA9PT0gVE9LRU4uVEFHX0NMT1NFICYmXG4gICAgcHJldmlvdXNfdG9rZW4ub3BlbmVkLnRleHRbMF0gPT09ICc8JyAmJiBwcmV2aW91c190b2tlbi50ZXh0WzBdICE9PSAnLycpIHtcbiAgICAvLyBeXiBlbXB0eSB0YWcgaGFzIG5vIGNvbnRlbnQgXG4gICAgdmFyIHRhZ19uYW1lID0gcHJldmlvdXNfdG9rZW4ub3BlbmVkLnRleHQuc3Vic3RyKDEpLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKHRhZ19uYW1lID09PSAnc2NyaXB0JyB8fCB0YWdfbmFtZSA9PT0gJ3N0eWxlJykge1xuICAgICAgLy8gU2NyaXB0IGFuZCBzdHlsZSB0YWdzIGFyZSBhbGxvd2VkIHRvIGhhdmUgY29tbWVudHMgd3JhcHBpbmcgdGhlaXIgY29udGVudFxuICAgICAgLy8gb3IganVzdCBoYXZlIHJlZ3VsYXIgY29udGVudC5cbiAgICAgIHZhciB0b2tlbiA9IHRoaXMuX3JlYWRfY29tbWVudF9vcl9jZGF0YShjKTtcbiAgICAgIGlmICh0b2tlbikge1xuICAgICAgICB0b2tlbi50eXBlID0gVE9LRU4uVEVYVDtcbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgfVxuICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHRoaXMuX2lucHV0LnJlYWRVbnRpbChuZXcgUmVnRXhwKCc8LycgKyB0YWdfbmFtZSArICdbXFxcXG5cXFxcclxcXFx0IF0qPz4nLCAnaWcnKSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9pc19jb250ZW50X3VuZm9ybWF0dGVkKHRhZ19uYW1lKSkge1xuXG4gICAgICByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5faW5wdXQucmVhZFVudGlsKG5ldyBSZWdFeHAoJzwvJyArIHRhZ19uYW1lICsgJ1tcXFxcblxcXFxyXFxcXHQgXSo/PicsICdpZycpKTtcbiAgICB9XG4gIH1cblxuICBpZiAocmVzdWx0aW5nX3N0cmluZykge1xuICAgIHJldHVybiB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uVEVYVCwgcmVzdWx0aW5nX3N0cmluZyk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3JlYWRfY29udGVudF93b3JkID0gZnVuY3Rpb24oYywgb3Blbl90b2tlbikge1xuICB2YXIgcmVzdWx0aW5nX3N0cmluZyA9ICcnO1xuICBpZiAodGhpcy5fb3B0aW9ucy51bmZvcm1hdHRlZF9jb250ZW50X2RlbGltaXRlcikge1xuICAgIGlmIChjID09PSB0aGlzLl9vcHRpb25zLnVuZm9ybWF0dGVkX2NvbnRlbnRfZGVsaW1pdGVyWzBdKSB7XG4gICAgICByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5fX3BhdHRlcm5zLnVuZm9ybWF0dGVkX2NvbnRlbnRfZGVsaW1pdGVyLnJlYWQoKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXJlc3VsdGluZ19zdHJpbmcpIHtcbiAgICByZXN1bHRpbmdfc3RyaW5nID0gKG9wZW5fdG9rZW4gJiYgb3Blbl90b2tlbi50eXBlID09PSBUT0tFTi5DT05UUk9MX0ZMT1dfT1BFTikgPyB0aGlzLl9fcGF0dGVybnMud29yZF9jb250cm9sX2Zsb3dfY2xvc2VfZXhjbHVkZWQucmVhZCgpIDogdGhpcy5fX3BhdHRlcm5zLndvcmQucmVhZCgpO1xuICB9XG4gIGlmIChyZXN1bHRpbmdfc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5URVhULCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuVG9rZW5pemVyID0gVG9rZW5pemVyO1xubW9kdWxlLmV4cG9ydHMuVE9LRU4gPSBUT0tFTjtcblxuXG4vKioqLyB9KVxuLyoqKioqKi8gXHRdKTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRcdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIHN0YXJ0dXBcbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdC8vIFRoaXMgZW50cnkgbW9kdWxlIGlzIHJlZmVyZW5jZWQgYnkgb3RoZXIgbW9kdWxlcyBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG4vKioqKioqLyBcdGxlZ2FjeV9iZWF1dGlmeV9odG1sID0gX193ZWJwYWNrX2V4cG9ydHNfXztcbi8qKioqKiovIFx0XG4vKioqKioqLyB9KSgpXG47XG52YXIgc3R5bGVfaHRtbCA9IGxlZ2FjeV9iZWF1dGlmeV9odG1sO1xuLyogRm9vdGVyICovXG5pZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBBZGQgc3VwcG9ydCBmb3IgQU1EICggaHR0cHM6Ly9naXRodWIuY29tL2FtZGpzL2FtZGpzLWFwaS93aWtpL0FNRCNkZWZpbmVhbWQtcHJvcGVydHktIClcbiAgICBkZWZpbmUoW1wicmVxdWlyZVwiLCBcIi4vYmVhdXRpZnlcIiwgXCIuL2JlYXV0aWZ5LWNzc1wiXSwgZnVuY3Rpb24ocmVxdWlyZWFtZCkge1xuICAgICAgICB2YXIganNfYmVhdXRpZnkgPSByZXF1aXJlYW1kKFwiLi9iZWF1dGlmeVwiKTtcbiAgICAgICAgdmFyIGNzc19iZWF1dGlmeSA9IHJlcXVpcmVhbWQoXCIuL2JlYXV0aWZ5LWNzc1wiKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaHRtbF9iZWF1dGlmeTogZnVuY3Rpb24oaHRtbF9zb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3R5bGVfaHRtbChodG1sX3NvdXJjZSwgb3B0aW9ucywganNfYmVhdXRpZnkuanNfYmVhdXRpZnksIGNzc19iZWF1dGlmeS5jc3NfYmVhdXRpZnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xufSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8vIEFkZCBzdXBwb3J0IGZvciBDb21tb25KUy4gSnVzdCBwdXQgdGhpcyBmaWxlIHNvbWV3aGVyZSBvbiB5b3VyIHJlcXVpcmUucGF0aHNcbiAgICAvLyBhbmQgeW91IHdpbGwgYmUgYWJsZSB0byBgdmFyIGh0bWxfYmVhdXRpZnkgPSByZXF1aXJlKFwiYmVhdXRpZnlcIikuaHRtbF9iZWF1dGlmeWAuXG4gICAgdmFyIGpzX2JlYXV0aWZ5ID0gcmVxdWlyZSgnLi9iZWF1dGlmeS5qcycpO1xuICAgIHZhciBjc3NfYmVhdXRpZnkgPSByZXF1aXJlKCcuL2JlYXV0aWZ5LWNzcy5qcycpO1xuXG4gICAgZXhwb3J0cy5odG1sX2JlYXV0aWZ5ID0gZnVuY3Rpb24oaHRtbF9zb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHN0eWxlX2h0bWwoaHRtbF9zb3VyY2UsIG9wdGlvbnMsIGpzX2JlYXV0aWZ5LmpzX2JlYXV0aWZ5LCBjc3NfYmVhdXRpZnkuY3NzX2JlYXV0aWZ5KTtcbiAgICB9O1xufSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgLy8gSWYgd2UncmUgcnVubmluZyBhIHdlYiBwYWdlIGFuZCBkb24ndCBoYXZlIGVpdGhlciBvZiB0aGUgYWJvdmUsIGFkZCBvdXIgb25lIGdsb2JhbFxuICAgIHdpbmRvdy5odG1sX2JlYXV0aWZ5ID0gZnVuY3Rpb24oaHRtbF9zb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHN0eWxlX2h0bWwoaHRtbF9zb3VyY2UsIG9wdGlvbnMsIHdpbmRvdy5qc19iZWF1dGlmeSwgd2luZG93LmNzc19iZWF1dGlmeSk7XG4gICAgfTtcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8vIElmIHdlIGRvbid0IGV2ZW4gaGF2ZSB3aW5kb3csIHRyeSBnbG9iYWwuXG4gICAgZ2xvYmFsLmh0bWxfYmVhdXRpZnkgPSBmdW5jdGlvbihodG1sX3NvdXJjZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gc3R5bGVfaHRtbChodG1sX3NvdXJjZSwgb3B0aW9ucywgZ2xvYmFsLmpzX2JlYXV0aWZ5LCBnbG9iYWwuY3NzX2JlYXV0aWZ5KTtcbiAgICB9O1xufVxuXG59KCkpO1xuIl0sIm5hbWVzIjpbImxlZ2FjeV9iZWF1dGlmeV9odG1sIiwiX193ZWJwYWNrX21vZHVsZXNfXyIsIm1vZHVsZSIsIk91dHB1dExpbmUiLCJwYXJlbnQiLCJfX3BhcmVudCIsIl9fY2hhcmFjdGVyX2NvdW50IiwiX19pbmRlbnRfY291bnQiLCJfX2FsaWdubWVudF9jb3VudCIsIl9fd3JhcF9wb2ludF9pbmRleCIsIl9fd3JhcF9wb2ludF9jaGFyYWN0ZXJfY291bnQiLCJfX3dyYXBfcG9pbnRfaW5kZW50X2NvdW50IiwiX193cmFwX3BvaW50X2FsaWdubWVudF9jb3VudCIsIl9faXRlbXMiLCJwcm90b3R5cGUiLCJjbG9uZV9lbXB0eSIsImxpbmUiLCJzZXRfaW5kZW50IiwiaXRlbSIsImluZGV4IiwibGVuZ3RoIiwiaGFzX21hdGNoIiwicGF0dGVybiIsImxhc3RDaGVja2VkT3V0cHV0IiwibWF0Y2giLCJpbmRlbnQiLCJhbGlnbm1lbnQiLCJpc19lbXB0eSIsImdldF9pbmRlbnRfc2l6ZSIsIl9zZXRfd3JhcF9wb2ludCIsIndyYXBfbGluZV9sZW5ndGgiLCJuZXh0X2xpbmUiLCJfc2hvdWxkX3dyYXAiLCJfYWxsb3dfd3JhcCIsImFkZF9uZXdfbGluZSIsIm5leHQiLCJjdXJyZW50X2xpbmUiLCJzbGljZSIsInNwbGljZSIsImxhc3QiLCJwdXNoIiwibGFzdF9uZXdsaW5lX2luZGV4IiwibGFzdEluZGV4T2YiLCJwb3AiLCJfcmVtb3ZlX2luZGVudCIsImluZGVudF9zaXplIiwiX3JlbW92ZV93cmFwX2luZGVudCIsInRyaW0iLCJ0b1N0cmluZyIsInJlc3VsdCIsImluZGVudF9lbXB0eV9saW5lcyIsImdldF9pbmRlbnRfc3RyaW5nIiwiam9pbiIsIkluZGVudFN0cmluZ0NhY2hlIiwib3B0aW9ucyIsImJhc2VJbmRlbnRTdHJpbmciLCJfX2NhY2hlIiwiX19pbmRlbnRfc2l6ZSIsIl9faW5kZW50X3N0cmluZyIsImluZGVudF9jaGFyIiwiaW5kZW50X3dpdGhfdGFicyIsIkFycmF5IiwiaW5kZW50X2xldmVsIiwiX19iYXNlX3N0cmluZyIsIl9fYmFzZV9zdHJpbmdfbGVuZ3RoIiwiY29sdW1uIiwiX19lbnN1cmVfY2FjaGUiLCJfX2FkZF9jb2x1bW4iLCJNYXRoIiwiZmxvb3IiLCJPdXRwdXQiLCJfX2luZGVudF9jYWNoZSIsInJhdyIsIl9lbmRfd2l0aF9uZXdsaW5lIiwiZW5kX3dpdGhfbmV3bGluZSIsIl9fbGluZXMiLCJwcmV2aW91c19saW5lIiwic3BhY2VfYmVmb3JlX3Rva2VuIiwibm9uX2JyZWFraW5nX3NwYWNlIiwicHJldmlvdXNfdG9rZW5fd3JhcHBlZCIsIl9fYWRkX291dHB1dGxpbmUiLCJnZXRfbGluZV9udW1iZXIiLCJmb3JjZV9uZXdsaW5lIiwianVzdF9hZGRlZF9uZXdsaW5lIiwiZ2V0X2NvZGUiLCJlb2wiLCJsYXN0X2l0ZW0iLCJyZXBsYWNlIiwic3dlZXRfY29kZSIsInNldF93cmFwX3BvaW50IiwiYWRkX3Jhd190b2tlbiIsInRva2VuIiwieCIsIm5ld2xpbmVzIiwid2hpdGVzcGFjZV9iZWZvcmUiLCJ0ZXh0IiwiYWRkX3Rva2VuIiwicHJpbnRhYmxlX3Rva2VuIiwiX19hZGRfc3BhY2VfYmVmb3JlX3Rva2VuIiwicmVtb3ZlX2luZGVudCIsIm91dHB1dF9sZW5ndGgiLCJlYXRfbmV3bGluZXMiLCJ1bmRlZmluZWQiLCJqdXN0X2FkZGVkX2JsYW5rbGluZSIsImVuc3VyZV9lbXB0eV9saW5lX2Fib3ZlIiwic3RhcnRzX3dpdGgiLCJlbmRzX3dpdGgiLCJwb3RlbnRpYWxFbXB0eUxpbmUiLCJpbmRleE9mIiwiZXhwb3J0cyIsIlRva2VuIiwidHlwZSIsImNvbW1lbnRzX2JlZm9yZSIsInByZXZpb3VzIiwib3BlbmVkIiwiY2xvc2VkIiwiZGlyZWN0aXZlcyIsIk9wdGlvbnMiLCJtZXJnZV9jaGlsZF9maWVsZCIsInJhd19vcHRpb25zIiwiX21lcmdlT3B0cyIsImRpc2FibGVkIiwiX2dldF9ib29sZWFuIiwiX2dldF9jaGFyYWN0ZXJzIiwiX2dldF9udW1iZXIiLCJwcmVzZXJ2ZV9uZXdsaW5lcyIsIm1heF9wcmVzZXJ2ZV9uZXdsaW5lcyIsInRlbXBsYXRpbmciLCJfZ2V0X3NlbGVjdGlvbl9saXN0IiwiX2dldF9hcnJheSIsIm5hbWUiLCJkZWZhdWx0X3ZhbHVlIiwib3B0aW9uX3ZhbHVlIiwiY29uY2F0Iiwic3BsaXQiLCJwYXJzZUludCIsImlzTmFOIiwiX2dldF9zZWxlY3Rpb24iLCJzZWxlY3Rpb25fbGlzdCIsIkVycm9yIiwiX2lzX3ZhbGlkX3NlbGVjdGlvbiIsInNvbWUiLCJhbGxPcHRpb25zIiwiY2hpbGRGaWVsZE5hbWUiLCJmaW5hbE9wdHMiLCJfbm9ybWFsaXplT3B0cyIsImNvbnZlcnRlZE9wdHMiLCJrZXkiLCJuZXdLZXkiLCJub3JtYWxpemVPcHRzIiwibWVyZ2VPcHRzIiwicmVnZXhwX2hhc19zdGlja3kiLCJSZWdFeHAiLCJoYXNPd25Qcm9wZXJ0eSIsIklucHV0U2Nhbm5lciIsImlucHV0X3N0cmluZyIsIl9faW5wdXQiLCJfX2lucHV0X2xlbmd0aCIsIl9fcG9zaXRpb24iLCJyZXN0YXJ0IiwiYmFjayIsImhhc05leHQiLCJ2YWwiLCJjaGFyQXQiLCJwZWVrIiwiX19tYXRjaCIsImxhc3RJbmRleCIsInBhdHRlcm5fbWF0Y2giLCJleGVjIiwic3RpY2t5IiwidGVzdCIsInRlc3RDaGFyIiwicmVhZCIsInN0YXJ0aW5nX3BhdHRlcm4iLCJ1bnRpbF9wYXR0ZXJuIiwidW50aWxfYWZ0ZXIiLCJyZWFkVW50aWwiLCJtYXRjaF9pbmRleCIsInN1YnN0cmluZyIsInJlYWRVbnRpbEFmdGVyIiwiZ2V0X3JlZ2V4cCIsIm1hdGNoX2Zyb20iLCJmbGFncyIsInNvdXJjZSIsImdldF9saXRlcmFsX3JlZ2V4cCIsImxpdGVyYWxfc3RyaW5nIiwicGVla1VudGlsQWZ0ZXIiLCJzdGFydCIsImxvb2tCYWNrIiwidGVzdFZhbCIsInRvTG93ZXJDYXNlIiwiX191bnVzZWRfd2VicGFja19leHBvcnRzIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsIlRva2VuU3RyZWFtIiwiV2hpdGVzcGFjZVBhdHRlcm4iLCJUT0tFTiIsIlNUQVJUIiwiUkFXIiwiRU9GIiwiVG9rZW5pemVyIiwiX2lucHV0IiwiX29wdGlvbnMiLCJfX3Rva2VucyIsIl9wYXR0ZXJucyIsIndoaXRlc3BhY2UiLCJ0b2tlbml6ZSIsIl9yZXNldCIsImN1cnJlbnQiLCJvcGVuX3Rva2VuIiwib3Blbl9zdGFjayIsImNvbW1lbnRzIiwiX2dldF9uZXh0X3Rva2VuIiwiX2lzX2NvbW1lbnQiLCJhZGQiLCJpc0VtcHR5IiwiX2lzX29wZW5pbmciLCJfaXNfY2xvc2luZyIsIl9pc19maXJzdF90b2tlbiIsInByZXZpb3VzX3Rva2VuIiwiX3JlYWRXaGl0ZXNwYWNlIiwicmVzdWx0aW5nX3N0cmluZyIsIl9jcmVhdGVfdG9rZW4iLCJjdXJyZW50X3Rva2VuIiwibmV3bGluZV9jb3VudCIsIndoaXRlc3BhY2VfYmVmb3JlX3Rva2VuIiwicGFyZW50X3Rva2VuIiwiX190b2tlbnNfbGVuZ3RoIiwiX19wYXJlbnRfdG9rZW4iLCJQYXR0ZXJuIiwiaW5wdXRfc2Nhbm5lciIsImNhbGwiLCJfbGluZV9yZWdleHAiLCJfX3NldF93aGl0ZXNwYWNlX3BhdHRlcm5zIiwid2hpdGVzcGFjZV9jaGFycyIsIm5ld2xpbmVfY2hhcnMiLCJfbWF0Y2hfcGF0dGVybiIsIl9uZXdsaW5lX3JlZ2V4cCIsIm1hdGNoZXMiLCJfX3NwbGl0IiwibWF0Y2hpbmciLCJfY3JlYXRlIiwiX3VwZGF0ZSIsInJlZ2V4cCIsInN0YXJ0X2luZGV4IiwibmV4dF9tYXRjaCIsIl9zdGFydGluZ19wYXR0ZXJuIiwiX3VudGlsX3BhdHRlcm4iLCJfdW50aWxfYWZ0ZXIiLCJyZWFkX21hdGNoIiwidW50aWwiLCJzdGFydGluZ193aXRoIiwiRGlyZWN0aXZlcyIsInN0YXJ0X2Jsb2NrX3BhdHRlcm4iLCJlbmRfYmxvY2tfcGF0dGVybiIsIl9fZGlyZWN0aXZlc19ibG9ja19wYXR0ZXJuIiwiX19kaXJlY3RpdmVfcGF0dGVybiIsIl9fZGlyZWN0aXZlc19lbmRfaWdub3JlX3BhdHRlcm4iLCJnZXRfZGlyZWN0aXZlcyIsImRpcmVjdGl2ZV9tYXRjaCIsInJlYWRJZ25vcmVkIiwiaW5wdXQiLCJ0ZW1wbGF0ZV9uYW1lcyIsImRqYW5nbyIsImVyYiIsImhhbmRsZWJhcnMiLCJwaHAiLCJzbWFydHkiLCJhbmd1bGFyIiwiVGVtcGxhdGFibGVQYXR0ZXJuIiwiX190ZW1wbGF0ZV9wYXR0ZXJuIiwiX2Rpc2FibGVkIiwiT2JqZWN0IiwiYXNzaWduIiwiX2V4Y2x1ZGVkIiwiX19wYXR0ZXJucyIsImhhbmRsZWJhcnNfY29tbWVudCIsImhhbmRsZWJhcnNfdW5lc2NhcGVkIiwiZGphbmdvX3ZhbHVlIiwiZGphbmdvX2NvbW1lbnQiLCJzbWFydHlfY29tbWVudCIsInNtYXJ0eV9saXRlcmFsIiwiX19zZXRfdGVtcGxhdGVkX3BhdHRlcm4iLCJkaXNhYmxlIiwibGFuZ3VhZ2UiLCJyZWFkX29wdGlvbnMiLCJleGNsdWRlIiwiX3JlYWRfdGVtcGxhdGUiLCJpdGVtcyIsImMiLCJwZWVrMSIsIkJlYXV0aWZpZXIiLCJzdHlsZV9odG1sIiwiaHRtbF9zb3VyY2UiLCJqc19iZWF1dGlmeSIsImNzc19iZWF1dGlmeSIsImJlYXV0aWZpZXIiLCJiZWF1dGlmeSIsImRlZmF1bHRPcHRpb25zIiwibGluZUJyZWFrIiwiYWxsTGluZUJyZWFrcyIsIlByaW50ZXIiLCJiYXNlX2luZGVudF9zdHJpbmciLCJhbGlnbm1lbnRfc2l6ZSIsIl9vdXRwdXQiLCJjdXJyZW50X2xpbmVfaGFzX21hdGNoIiwic2V0X3NwYWNlX2JlZm9yZV90b2tlbiIsInZhbHVlIiwibm9uX2JyZWFraW5nIiwicHJpbnRfcHJlc2VydmVkX25ld2xpbmVzIiwicmF3X3Rva2VuIiwiVEVYVCIsIm4iLCJwcmludF9uZXdsaW5lIiwidHJhdmVyc2Vfd2hpdGVzcGFjZSIsImZvcmNlIiwicHJpbnRfdG9rZW4iLCJkZWluZGVudCIsImdldF9mdWxsX2luZGVudCIsImxldmVsIiwiZ2V0X3R5cGVfYXR0cmlidXRlIiwic3RhcnRfdG9rZW4iLCJBVFRSSUJVVEUiLCJFUVVBTFMiLCJWQUxVRSIsImdldF9jdXN0b21fYmVhdXRpZmllcl9uYW1lIiwidGFnX2NoZWNrIiwidHlwZUF0dHJpYnV0ZSIsInNlYXJjaCIsImluX2FycmF5Iiwid2hhdCIsImFyciIsIlRhZ0ZyYW1lIiwicGFyc2VyX3Rva2VuIiwidGFnIiwidGFnX25hbWUiLCJUYWdTdGFjayIsInByaW50ZXIiLCJfcHJpbnRlciIsIl9jdXJyZW50X2ZyYW1lIiwiZ2V0X3BhcnNlcl90b2tlbiIsInJlY29yZF90YWciLCJuZXdfZnJhbWUiLCJfdHJ5X3BvcF9mcmFtZSIsImZyYW1lIiwiX2dldF9mcmFtZSIsInRhZ19saXN0Iiwic3RvcF9saXN0IiwidHJ5X3BvcCIsImluZGVudF90b190YWciLCJzb3VyY2VfdGV4dCIsIl9zb3VyY2VfdGV4dCIsIl9qc19iZWF1dGlmeSIsIl9jc3NfYmVhdXRpZnkiLCJfdGFnX3N0YWNrIiwib3B0aW9uSHRtbCIsIl9pc193cmFwX2F0dHJpYnV0ZXNfZm9yY2UiLCJ3cmFwX2F0dHJpYnV0ZXMiLCJzdWJzdHIiLCJfaXNfd3JhcF9hdHRyaWJ1dGVzX2ZvcmNlX2V4cGFuZF9tdWx0aWxpbmUiLCJfaXNfd3JhcF9hdHRyaWJ1dGVzX2ZvcmNlX2FsaWduZWQiLCJfaXNfd3JhcF9hdHRyaWJ1dGVzX2FsaWduZWRfbXVsdGlwbGUiLCJfaXNfd3JhcF9hdHRyaWJ1dGVzX3ByZXNlcnZlIiwiX2lzX3dyYXBfYXR0cmlidXRlc19wcmVzZXJ2ZV9hbGlnbmVkIiwibGFzdF90b2tlbiIsImxhc3RfdGFnX3Rva2VuIiwiVGFnT3BlblBhcnNlclRva2VuIiwidG9rZW5zIiwiVEFHX09QRU4iLCJDT01NRU5UIiwiX2hhbmRsZV90YWdfb3BlbiIsInRhZ19jb21wbGV0ZSIsIl9oYW5kbGVfaW5zaWRlX3RhZyIsIlRBR19DTE9TRSIsIl9oYW5kbGVfdGFnX2Nsb3NlIiwiX2hhbmRsZV90ZXh0IiwiQ09OVFJPTF9GTE9XX09QRU4iLCJfaGFuZGxlX2NvbnRyb2xfZmxvd19vcGVuIiwiQ09OVFJPTF9GTE9XX0NMT1NFIiwiX2hhbmRsZV9jb250cm9sX2Zsb3dfY2xvc2UiLCJpc191bmZvcm1hdHRlZCIsInRhZ19zdGFydF9jaGFyIiwiaGFzX3dyYXBwZWRfYXR0cnMiLCJpbmRlbnRfY29udGVudCIsImlzX2NvbnRlbnRfdW5mb3JtYXR0ZWQiLCJpc19pbmxpbmVfZWxlbWVudCIsIndyYXBwZWQiLCJhdHRyX2NvdW50Iiwid3JhcF9hdHRyaWJ1dGVzX21pbl9hdHRycyIsImN1c3RvbV9iZWF1dGlmaWVyX25hbWUiLCJfcHJpbnRfY3VzdG9tX2JlYXRpZmllcl90ZXh0IiwibG9jYWwiLCJfYmVhdXRpZmllciIsInNjcmlwdF9pbmRlbnRfbGV2ZWwiLCJwcmUiLCJwb3N0IiwiaW5kZW50X3NjcmlwdHMiLCJpbmRlbnRhdGlvbiIsIm1hdGNoZWQiLCJDaGlsZF9vcHRpb25zIiwiY2hpbGRfb3B0aW9ucyIsIndoaXRlIiwiX2dldF90YWdfb3Blbl90b2tlbiIsImlzX2VtcHR5X2VsZW1lbnQiLCJpc19zdGFydF90YWciLCJzdGFydF90YWdfdG9rZW4iLCJfc2V0X3RhZ19wb3NpdGlvbiIsInBlZWtfaW5kZXgiLCJwZWVrX3Rva2VuIiwiaXNfZW5kX3RhZyIsIm11bHRpbGluZV9jb250ZW50IiwidGFnX2NoZWNrX21hdGNoIiwic3RhcnRzV2l0aCIsImhhbmRsZWJhcl9zdGFydHMiLCJ3cmFwX2F0dHJpYnV0ZXNfaW5kZW50X3NpemUiLCJ2b2lkX2VsZW1lbnRzIiwidW5mb3JtYXR0ZWQiLCJjb250ZW50X3VuZm9ybWF0dGVkIiwiaW5saW5lIiwiaW5saW5lX2N1c3RvbV9lbGVtZW50cyIsImluY2x1ZGVzIiwiX2RvX29wdGlvbmFsX2VuZF9lbGVtZW50IiwiZXh0cmFfbGluZXJzIiwiZm91bmRJZk9uQ3VycmVudExpbmUiLCJfY2FsY2x1YXRlX3BhcmVudF9tdWx0aWxpbmUiLCJkb19lbmRfZXhwYW5kIiwiaW5kZW50X2lubmVyX2h0bWwiLCJpbmRlbnRfaGVhZF9pbm5lcl9odG1sIiwiaW5kZW50X2JvZHlfaW5uZXJfaHRtbCIsInBfY2xvc2VycyIsInBfcGFyZW50X2V4Y2x1ZGVzIiwicF9wYXJlbnQiLCJCYXNlT3B0aW9ucyIsImluZGVudF9oYW5kbGViYXJzIiwidW5mb3JtYXR0ZWRfY29udGVudF9kZWxpbWl0ZXIiLCJCYXNlVG9rZW5pemVyIiwiQkFTRVRPS0VOIiwiVU5LTk9XTiIsImRpcmVjdGl2ZXNfY29yZSIsIl9jdXJyZW50X3RhZ19uYW1lIiwidGVtcGxhdGFibGVfcmVhZGVyIiwicGF0dGVybl9yZWFkZXIiLCJ3b3JkIiwid29yZF9jb250cm9sX2Zsb3dfY2xvc2VfZXhjbHVkZWQiLCJzaW5nbGVfcXVvdGUiLCJkb3VibGVfcXVvdGUiLCJhdHRyaWJ1dGUiLCJlbGVtZW50X25hbWUiLCJhbmd1bGFyX2NvbnRyb2xfZmxvd19zdGFydCIsImhhbmRsZWJhcnNfb3BlbiIsImhhbmRsZWJhcnNfcmF3X2Nsb3NlIiwiY29tbWVudCIsImNkYXRhIiwiY29uZGl0aW9uYWxfY29tbWVudCIsInByb2Nlc3NpbmciLCJfdW5mb3JtYXR0ZWRfY29udGVudF9kZWxpbWl0ZXIiLCJsaXRlcmFsX3JlZ2V4cCIsImVuZHNXaXRoIiwiX3JlYWRfb3Blbl9oYW5kbGViYXJzIiwiX3JlYWRfYXR0cmlidXRlIiwiX3JlYWRfY2xvc2UiLCJfcmVhZF9jb250cm9sX2Zsb3dzIiwiX3JlYWRfcmF3X2NvbnRlbnQiLCJfcmVhZF9jb250ZW50X3dvcmQiLCJfcmVhZF9jb21tZW50X29yX2NkYXRhIiwiX3JlYWRfcHJvY2Vzc2luZyIsIl9yZWFkX29wZW4iLCJpZ25vcmUiLCJvcGVuaW5nX3BhcmVudGhlc2VzX2NvdW50IiwiY2xvc2luZ19wYXJlbnRoZXNlc19jb3VudCIsIm5leHRfY2hhciIsImNvbnRlbnQiLCJfaXNfY29udGVudF91bmZvcm1hdHRlZCIsIl9fd2VicGFja19tb2R1bGVfY2FjaGVfXyIsIm1vZHVsZUlkIiwiY2FjaGVkTW9kdWxlIiwiX193ZWJwYWNrX2V4cG9ydHNfXyIsImRlZmluZSIsImFtZCIsInJlcXVpcmVhbWQiLCJodG1sX2JlYXV0aWZ5IiwicmVxdWlyZSIsIndpbmRvdyIsImdsb2JhbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/js-beautify/js/lib/beautify-html.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/js-beautify/js/lib/beautify.js":
/*!*****************************************************!*\
  !*** ./node_modules/js-beautify/js/lib/beautify.js ***!
  \*****************************************************/
/***/ ((module, exports) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* AUTO-GENERATED. DO NOT MODIFY. */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n\n JS Beautifier\n---------------\n\n\n  Written by Einar Lielmanis, <einar@beautifier.io>\n      https://beautifier.io/\n\n  Originally converted to javascript by Vital, <vital76@gmail.com>\n  \"End braces on own line\" added by Chris J. Shull, <chrisjshull@gmail.com>\n  Parsing improvements for brace-less statements by Liam Newman <bitwiseman@beautifier.io>\n\n\n  Usage:\n    js_beautify(js_source_text);\n    js_beautify(js_source_text, options);\n\n  The options are:\n    indent_size (default 4)          - indentation size,\n    indent_char (default space)      - character to indent with,\n    preserve_newlines (default true) - whether existing line breaks should be preserved,\n    max_preserve_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk,\n\n    jslint_happy (default false) - if true, then jslint-stricter mode is enforced.\n\n            jslint_happy        !jslint_happy\n            ---------------------------------\n            function ()         function()\n\n            switch () {         switch() {\n            case 1:               case 1:\n              break;                break;\n            }                   }\n\n    space_after_anon_function (default false) - should the space before an anonymous function's parens be added, \"function()\" vs \"function ()\",\n          NOTE: This option is overridden by jslint_happy (i.e. if jslint_happy is true, space_after_anon_function is true by design)\n\n    brace_style (default \"collapse\") - \"collapse\" | \"expand\" | \"end-expand\" | \"none\" | any of the former + \",preserve-inline\"\n            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line, or attempt to keep them where they are.\n            preserve-inline will try to preserve inline blocks of curly braces\n\n    space_before_conditional (default true) - should the space before conditional statement be added, \"if(true)\" vs \"if (true)\",\n\n    unescape_strings (default false) - should printable characters in strings encoded in \\xNN notation be unescaped, \"example\" vs \"\\x65\\x78\\x61\\x6d\\x70\\x6c\\x65\"\n\n    wrap_line_length (default unlimited) - lines should wrap at next opportunity after this number of characters.\n          NOTE: This is not a hard limit. Lines will continue until a point where a newline would\n                be preserved if it were present.\n\n    end_with_newline (default false)  - end output with a newline\n\n\n    e.g\n\n    js_beautify(js_source_text, {\n      'indent_size': 1,\n      'indent_char': '\\t'\n    });\n\n*/ (function() {\n    /* GENERATED_BUILD_OUTPUT */ var legacy_beautify_js;\n    /******/ (function() {\n        /******/ \"use strict\";\n        /******/ var __webpack_modules__ = [\n            /* 0 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_4010__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var Beautifier = __nested_webpack_require_4010__(1).Beautifier, Options = __nested_webpack_require_4010__(5).Options;\n                function js_beautify(js_source_text, options) {\n                    var beautifier = new Beautifier(js_source_text, options);\n                    return beautifier.beautify();\n                }\n                module.exports = js_beautify;\n                module.exports.defaultOptions = function() {\n                    return new Options();\n                };\n            /***/ },\n            /* 1 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_5797__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var Output = __nested_webpack_require_5797__(2).Output;\n                var Token = __nested_webpack_require_5797__(3).Token;\n                var acorn = __nested_webpack_require_5797__(4);\n                var Options = __nested_webpack_require_5797__(5).Options;\n                var Tokenizer = __nested_webpack_require_5797__(7).Tokenizer;\n                var line_starters = __nested_webpack_require_5797__(7).line_starters;\n                var positionable_operators = __nested_webpack_require_5797__(7).positionable_operators;\n                var TOKEN = __nested_webpack_require_5797__(7).TOKEN;\n                function in_array(what, arr) {\n                    return arr.indexOf(what) !== -1;\n                }\n                function ltrim(s) {\n                    return s.replace(/^\\s+/g, \"\");\n                }\n                function generateMapFromStrings(list) {\n                    var result = {};\n                    for(var x = 0; x < list.length; x++){\n                        // make the mapped names underscored instead of dash\n                        result[list[x].replace(/-/g, \"_\")] = list[x];\n                    }\n                    return result;\n                }\n                function reserved_word(token, word) {\n                    return token && token.type === TOKEN.RESERVED && token.text === word;\n                }\n                function reserved_array(token, words) {\n                    return token && token.type === TOKEN.RESERVED && in_array(token.text, words);\n                }\n                // Unsure of what they mean, but they work. Worth cleaning up in future.\n                var special_words = [\n                    \"case\",\n                    \"return\",\n                    \"do\",\n                    \"if\",\n                    \"throw\",\n                    \"else\",\n                    \"await\",\n                    \"break\",\n                    \"continue\",\n                    \"async\"\n                ];\n                var validPositionValues = [\n                    \"before-newline\",\n                    \"after-newline\",\n                    \"preserve-newline\"\n                ];\n                // Generate map from array\n                var OPERATOR_POSITION = generateMapFromStrings(validPositionValues);\n                var OPERATOR_POSITION_BEFORE_OR_PRESERVE = [\n                    OPERATOR_POSITION.before_newline,\n                    OPERATOR_POSITION.preserve_newline\n                ];\n                var MODE = {\n                    BlockStatement: \"BlockStatement\",\n                    Statement: \"Statement\",\n                    ObjectLiteral: \"ObjectLiteral\",\n                    ArrayLiteral: \"ArrayLiteral\",\n                    ForInitializer: \"ForInitializer\",\n                    Conditional: \"Conditional\",\n                    Expression: \"Expression\" //'(EXPRESSION)'\n                };\n                function remove_redundant_indentation(output, frame) {\n                    // This implementation is effective but has some issues:\n                    //     - can cause line wrap to happen too soon due to indent removal\n                    //           after wrap points are calculated\n                    // These issues are minor compared to ugly indentation.\n                    if (frame.multiline_frame || frame.mode === MODE.ForInitializer || frame.mode === MODE.Conditional) {\n                        return;\n                    }\n                    // remove one indent from each line inside this section\n                    output.remove_indent(frame.start_line_index);\n                }\n                // we could use just string.split, but\n                // IE doesn't like returning empty strings\n                function split_linebreaks(s) {\n                    //return s.split(/\\x0d\\x0a|\\x0a/);\n                    s = s.replace(acorn.allLineBreaks, \"\\n\");\n                    var out = [], idx = s.indexOf(\"\\n\");\n                    while(idx !== -1){\n                        out.push(s.substring(0, idx));\n                        s = s.substring(idx + 1);\n                        idx = s.indexOf(\"\\n\");\n                    }\n                    if (s.length) {\n                        out.push(s);\n                    }\n                    return out;\n                }\n                function is_array(mode) {\n                    return mode === MODE.ArrayLiteral;\n                }\n                function is_expression(mode) {\n                    return in_array(mode, [\n                        MODE.Expression,\n                        MODE.ForInitializer,\n                        MODE.Conditional\n                    ]);\n                }\n                function all_lines_start_with(lines, c) {\n                    for(var i = 0; i < lines.length; i++){\n                        var line = lines[i].trim();\n                        if (line.charAt(0) !== c) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n                function each_line_matches_indent(lines, indent) {\n                    var i = 0, len = lines.length, line;\n                    for(; i < len; i++){\n                        line = lines[i];\n                        // allow empty lines to pass through\n                        if (line && line.indexOf(indent) !== 0) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n                function Beautifier(source_text, options) {\n                    options = options || {};\n                    this._source_text = source_text || \"\";\n                    this._output = null;\n                    this._tokens = null;\n                    this._last_last_text = null;\n                    this._flags = null;\n                    this._previous_flags = null;\n                    this._flag_store = null;\n                    this._options = new Options(options);\n                }\n                Beautifier.prototype.create_flags = function(flags_base, mode) {\n                    var next_indent_level = 0;\n                    if (flags_base) {\n                        next_indent_level = flags_base.indentation_level;\n                        if (!this._output.just_added_newline() && flags_base.line_indent_level > next_indent_level) {\n                            next_indent_level = flags_base.line_indent_level;\n                        }\n                    }\n                    var next_flags = {\n                        mode: mode,\n                        parent: flags_base,\n                        last_token: flags_base ? flags_base.last_token : new Token(TOKEN.START_BLOCK, \"\"),\n                        last_word: flags_base ? flags_base.last_word : \"\",\n                        declaration_statement: false,\n                        declaration_assignment: false,\n                        multiline_frame: false,\n                        inline_frame: false,\n                        if_block: false,\n                        else_block: false,\n                        class_start_block: false,\n                        do_block: false,\n                        do_while: false,\n                        import_block: false,\n                        in_case_statement: false,\n                        in_case: false,\n                        case_body: false,\n                        case_block: false,\n                        indentation_level: next_indent_level,\n                        alignment: 0,\n                        line_indent_level: flags_base ? flags_base.line_indent_level : next_indent_level,\n                        start_line_index: this._output.get_line_number(),\n                        ternary_depth: 0\n                    };\n                    return next_flags;\n                };\n                Beautifier.prototype._reset = function(source_text) {\n                    var baseIndentString = source_text.match(/^[\\t ]*/)[0];\n                    this._last_last_text = \"\"; // pre-last token text\n                    this._output = new Output(this._options, baseIndentString);\n                    // If testing the ignore directive, start with output disable set to true\n                    this._output.raw = this._options.test_output_raw;\n                    // Stack of parsing/formatting states, including MODE.\n                    // We tokenize, parse, and output in an almost purely a forward-only stream of token input\n                    // and formatted output.  This makes the beautifier less accurate than full parsers\n                    // but also far more tolerant of syntax errors.\n                    //\n                    // For example, the default mode is MODE.BlockStatement. If we see a '{' we push a new frame of type\n                    // MODE.BlockStatement on the the stack, even though it could be object literal.  If we later\n                    // encounter a \":\", we'll switch to to MODE.ObjectLiteral.  If we then see a \";\",\n                    // most full parsers would die, but the beautifier gracefully falls back to\n                    // MODE.BlockStatement and continues on.\n                    this._flag_store = [];\n                    this.set_mode(MODE.BlockStatement);\n                    var tokenizer = new Tokenizer(source_text, this._options);\n                    this._tokens = tokenizer.tokenize();\n                    return source_text;\n                };\n                Beautifier.prototype.beautify = function() {\n                    // if disabled, return the input unchanged.\n                    if (this._options.disabled) {\n                        return this._source_text;\n                    }\n                    var sweet_code;\n                    var source_text = this._reset(this._source_text);\n                    var eol = this._options.eol;\n                    if (this._options.eol === \"auto\") {\n                        eol = \"\\n\";\n                        if (source_text && acorn.lineBreak.test(source_text || \"\")) {\n                            eol = source_text.match(acorn.lineBreak)[0];\n                        }\n                    }\n                    var current_token = this._tokens.next();\n                    while(current_token){\n                        this.handle_token(current_token);\n                        this._last_last_text = this._flags.last_token.text;\n                        this._flags.last_token = current_token;\n                        current_token = this._tokens.next();\n                    }\n                    sweet_code = this._output.get_code(eol);\n                    return sweet_code;\n                };\n                Beautifier.prototype.handle_token = function(current_token, preserve_statement_flags) {\n                    if (current_token.type === TOKEN.START_EXPR) {\n                        this.handle_start_expr(current_token);\n                    } else if (current_token.type === TOKEN.END_EXPR) {\n                        this.handle_end_expr(current_token);\n                    } else if (current_token.type === TOKEN.START_BLOCK) {\n                        this.handle_start_block(current_token);\n                    } else if (current_token.type === TOKEN.END_BLOCK) {\n                        this.handle_end_block(current_token);\n                    } else if (current_token.type === TOKEN.WORD) {\n                        this.handle_word(current_token);\n                    } else if (current_token.type === TOKEN.RESERVED) {\n                        this.handle_word(current_token);\n                    } else if (current_token.type === TOKEN.SEMICOLON) {\n                        this.handle_semicolon(current_token);\n                    } else if (current_token.type === TOKEN.STRING) {\n                        this.handle_string(current_token);\n                    } else if (current_token.type === TOKEN.EQUALS) {\n                        this.handle_equals(current_token);\n                    } else if (current_token.type === TOKEN.OPERATOR) {\n                        this.handle_operator(current_token);\n                    } else if (current_token.type === TOKEN.COMMA) {\n                        this.handle_comma(current_token);\n                    } else if (current_token.type === TOKEN.BLOCK_COMMENT) {\n                        this.handle_block_comment(current_token, preserve_statement_flags);\n                    } else if (current_token.type === TOKEN.COMMENT) {\n                        this.handle_comment(current_token, preserve_statement_flags);\n                    } else if (current_token.type === TOKEN.DOT) {\n                        this.handle_dot(current_token);\n                    } else if (current_token.type === TOKEN.EOF) {\n                        this.handle_eof(current_token);\n                    } else if (current_token.type === TOKEN.UNKNOWN) {\n                        this.handle_unknown(current_token, preserve_statement_flags);\n                    } else {\n                        this.handle_unknown(current_token, preserve_statement_flags);\n                    }\n                };\n                Beautifier.prototype.handle_whitespace_and_comments = function(current_token, preserve_statement_flags) {\n                    var newlines = current_token.newlines;\n                    var keep_whitespace = this._options.keep_array_indentation && is_array(this._flags.mode);\n                    if (current_token.comments_before) {\n                        var comment_token = current_token.comments_before.next();\n                        while(comment_token){\n                            // The cleanest handling of inline comments is to treat them as though they aren't there.\n                            // Just continue formatting and the behavior should be logical.\n                            // Also ignore unknown tokens.  Again, this should result in better behavior.\n                            this.handle_whitespace_and_comments(comment_token, preserve_statement_flags);\n                            this.handle_token(comment_token, preserve_statement_flags);\n                            comment_token = current_token.comments_before.next();\n                        }\n                    }\n                    if (keep_whitespace) {\n                        for(var i = 0; i < newlines; i += 1){\n                            this.print_newline(i > 0, preserve_statement_flags);\n                        }\n                    } else {\n                        if (this._options.max_preserve_newlines && newlines > this._options.max_preserve_newlines) {\n                            newlines = this._options.max_preserve_newlines;\n                        }\n                        if (this._options.preserve_newlines) {\n                            if (newlines > 1) {\n                                this.print_newline(false, preserve_statement_flags);\n                                for(var j = 1; j < newlines; j += 1){\n                                    this.print_newline(true, preserve_statement_flags);\n                                }\n                            }\n                        }\n                    }\n                };\n                var newline_restricted_tokens = [\n                    \"async\",\n                    \"break\",\n                    \"continue\",\n                    \"return\",\n                    \"throw\",\n                    \"yield\"\n                ];\n                Beautifier.prototype.allow_wrap_or_preserved_newline = function(current_token, force_linewrap) {\n                    force_linewrap = force_linewrap === undefined ? false : force_linewrap;\n                    // Never wrap the first token on a line\n                    if (this._output.just_added_newline()) {\n                        return;\n                    }\n                    var shouldPreserveOrForce = this._options.preserve_newlines && current_token.newlines || force_linewrap;\n                    var operatorLogicApplies = in_array(this._flags.last_token.text, positionable_operators) || in_array(current_token.text, positionable_operators);\n                    if (operatorLogicApplies) {\n                        var shouldPrintOperatorNewline = in_array(this._flags.last_token.text, positionable_operators) && in_array(this._options.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE) || in_array(current_token.text, positionable_operators);\n                        shouldPreserveOrForce = shouldPreserveOrForce && shouldPrintOperatorNewline;\n                    }\n                    if (shouldPreserveOrForce) {\n                        this.print_newline(false, true);\n                    } else if (this._options.wrap_line_length) {\n                        if (reserved_array(this._flags.last_token, newline_restricted_tokens)) {\n                            // These tokens should never have a newline inserted\n                            // between them and the following expression.\n                            return;\n                        }\n                        this._output.set_wrap_point();\n                    }\n                };\n                Beautifier.prototype.print_newline = function(force_newline, preserve_statement_flags) {\n                    if (!preserve_statement_flags) {\n                        if (this._flags.last_token.text !== \";\" && this._flags.last_token.text !== \",\" && this._flags.last_token.text !== \"=\" && (this._flags.last_token.type !== TOKEN.OPERATOR || this._flags.last_token.text === \"--\" || this._flags.last_token.text === \"++\")) {\n                            var next_token = this._tokens.peek();\n                            while(this._flags.mode === MODE.Statement && !(this._flags.if_block && reserved_word(next_token, \"else\")) && !this._flags.do_block){\n                                this.restore_mode();\n                            }\n                        }\n                    }\n                    if (this._output.add_new_line(force_newline)) {\n                        this._flags.multiline_frame = true;\n                    }\n                };\n                Beautifier.prototype.print_token_line_indentation = function(current_token) {\n                    if (this._output.just_added_newline()) {\n                        if (this._options.keep_array_indentation && current_token.newlines && (current_token.text === \"[\" || is_array(this._flags.mode))) {\n                            this._output.current_line.set_indent(-1);\n                            this._output.current_line.push(current_token.whitespace_before);\n                            this._output.space_before_token = false;\n                        } else if (this._output.set_indent(this._flags.indentation_level, this._flags.alignment)) {\n                            this._flags.line_indent_level = this._flags.indentation_level;\n                        }\n                    }\n                };\n                Beautifier.prototype.print_token = function(current_token) {\n                    if (this._output.raw) {\n                        this._output.add_raw_token(current_token);\n                        return;\n                    }\n                    if (this._options.comma_first && current_token.previous && current_token.previous.type === TOKEN.COMMA && this._output.just_added_newline()) {\n                        if (this._output.previous_line.last() === \",\") {\n                            var popped = this._output.previous_line.pop();\n                            // if the comma was already at the start of the line,\n                            // pull back onto that line and reprint the indentation\n                            if (this._output.previous_line.is_empty()) {\n                                this._output.previous_line.push(popped);\n                                this._output.trim(true);\n                                this._output.current_line.pop();\n                                this._output.trim();\n                            }\n                            // add the comma in front of the next token\n                            this.print_token_line_indentation(current_token);\n                            this._output.add_token(\",\");\n                            this._output.space_before_token = true;\n                        }\n                    }\n                    this.print_token_line_indentation(current_token);\n                    this._output.non_breaking_space = true;\n                    this._output.add_token(current_token.text);\n                    if (this._output.previous_token_wrapped) {\n                        this._flags.multiline_frame = true;\n                    }\n                };\n                Beautifier.prototype.indent = function() {\n                    this._flags.indentation_level += 1;\n                    this._output.set_indent(this._flags.indentation_level, this._flags.alignment);\n                };\n                Beautifier.prototype.deindent = function() {\n                    if (this._flags.indentation_level > 0 && (!this._flags.parent || this._flags.indentation_level > this._flags.parent.indentation_level)) {\n                        this._flags.indentation_level -= 1;\n                        this._output.set_indent(this._flags.indentation_level, this._flags.alignment);\n                    }\n                };\n                Beautifier.prototype.set_mode = function(mode) {\n                    if (this._flags) {\n                        this._flag_store.push(this._flags);\n                        this._previous_flags = this._flags;\n                    } else {\n                        this._previous_flags = this.create_flags(null, mode);\n                    }\n                    this._flags = this.create_flags(this._previous_flags, mode);\n                    this._output.set_indent(this._flags.indentation_level, this._flags.alignment);\n                };\n                Beautifier.prototype.restore_mode = function() {\n                    if (this._flag_store.length > 0) {\n                        this._previous_flags = this._flags;\n                        this._flags = this._flag_store.pop();\n                        if (this._previous_flags.mode === MODE.Statement) {\n                            remove_redundant_indentation(this._output, this._previous_flags);\n                        }\n                        this._output.set_indent(this._flags.indentation_level, this._flags.alignment);\n                    }\n                };\n                Beautifier.prototype.start_of_object_property = function() {\n                    return this._flags.parent.mode === MODE.ObjectLiteral && this._flags.mode === MODE.Statement && (this._flags.last_token.text === \":\" && this._flags.ternary_depth === 0 || reserved_array(this._flags.last_token, [\n                        \"get\",\n                        \"set\"\n                    ]));\n                };\n                Beautifier.prototype.start_of_statement = function(current_token) {\n                    var start = false;\n                    start = start || reserved_array(this._flags.last_token, [\n                        \"var\",\n                        \"let\",\n                        \"const\"\n                    ]) && current_token.type === TOKEN.WORD;\n                    start = start || reserved_word(this._flags.last_token, \"do\");\n                    start = start || !(this._flags.parent.mode === MODE.ObjectLiteral && this._flags.mode === MODE.Statement) && reserved_array(this._flags.last_token, newline_restricted_tokens) && !current_token.newlines;\n                    start = start || reserved_word(this._flags.last_token, \"else\") && !(reserved_word(current_token, \"if\") && !current_token.comments_before);\n                    start = start || this._flags.last_token.type === TOKEN.END_EXPR && (this._previous_flags.mode === MODE.ForInitializer || this._previous_flags.mode === MODE.Conditional);\n                    start = start || this._flags.last_token.type === TOKEN.WORD && this._flags.mode === MODE.BlockStatement && !this._flags.in_case && !(current_token.text === \"--\" || current_token.text === \"++\") && this._last_last_text !== \"function\" && current_token.type !== TOKEN.WORD && current_token.type !== TOKEN.RESERVED;\n                    start = start || this._flags.mode === MODE.ObjectLiteral && (this._flags.last_token.text === \":\" && this._flags.ternary_depth === 0 || reserved_array(this._flags.last_token, [\n                        \"get\",\n                        \"set\"\n                    ]));\n                    if (start) {\n                        this.set_mode(MODE.Statement);\n                        this.indent();\n                        this.handle_whitespace_and_comments(current_token, true);\n                        // Issue #276:\n                        // If starting a new statement with [if, for, while, do], push to a new line.\n                        // if (a) if (b) if(c) d(); else e(); else f();\n                        if (!this.start_of_object_property()) {\n                            this.allow_wrap_or_preserved_newline(current_token, reserved_array(current_token, [\n                                \"do\",\n                                \"for\",\n                                \"if\",\n                                \"while\"\n                            ]));\n                        }\n                        return true;\n                    }\n                    return false;\n                };\n                Beautifier.prototype.handle_start_expr = function(current_token) {\n                    // The conditional starts the statement if appropriate.\n                    if (!this.start_of_statement(current_token)) {\n                        this.handle_whitespace_and_comments(current_token);\n                    }\n                    var next_mode = MODE.Expression;\n                    if (current_token.text === \"[\") {\n                        if (this._flags.last_token.type === TOKEN.WORD || this._flags.last_token.text === \")\") {\n                            // this is array index specifier, break immediately\n                            // a[x], fn()[x]\n                            if (reserved_array(this._flags.last_token, line_starters)) {\n                                this._output.space_before_token = true;\n                            }\n                            this.print_token(current_token);\n                            this.set_mode(next_mode);\n                            this.indent();\n                            if (this._options.space_in_paren) {\n                                this._output.space_before_token = true;\n                            }\n                            return;\n                        }\n                        next_mode = MODE.ArrayLiteral;\n                        if (is_array(this._flags.mode)) {\n                            if (this._flags.last_token.text === \"[\" || this._flags.last_token.text === \",\" && (this._last_last_text === \"]\" || this._last_last_text === \"}\")) {\n                                // ], [ goes to new line\n                                // }, [ goes to new line\n                                if (!this._options.keep_array_indentation) {\n                                    this.print_newline();\n                                }\n                            }\n                        }\n                        if (!in_array(this._flags.last_token.type, [\n                            TOKEN.START_EXPR,\n                            TOKEN.END_EXPR,\n                            TOKEN.WORD,\n                            TOKEN.OPERATOR,\n                            TOKEN.DOT\n                        ])) {\n                            this._output.space_before_token = true;\n                        }\n                    } else {\n                        if (this._flags.last_token.type === TOKEN.RESERVED) {\n                            if (this._flags.last_token.text === \"for\") {\n                                this._output.space_before_token = this._options.space_before_conditional;\n                                next_mode = MODE.ForInitializer;\n                            } else if (in_array(this._flags.last_token.text, [\n                                \"if\",\n                                \"while\",\n                                \"switch\"\n                            ])) {\n                                this._output.space_before_token = this._options.space_before_conditional;\n                                next_mode = MODE.Conditional;\n                            } else if (in_array(this._flags.last_word, [\n                                \"await\",\n                                \"async\"\n                            ])) {\n                                // Should be a space between await and an IIFE, or async and an arrow function\n                                this._output.space_before_token = true;\n                            } else if (this._flags.last_token.text === \"import\" && current_token.whitespace_before === \"\") {\n                                this._output.space_before_token = false;\n                            } else if (in_array(this._flags.last_token.text, line_starters) || this._flags.last_token.text === \"catch\") {\n                                this._output.space_before_token = true;\n                            }\n                        } else if (this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {\n                            // Support of this kind of newline preservation.\n                            // a = (b &&\n                            //     (c || d));\n                            if (!this.start_of_object_property()) {\n                                this.allow_wrap_or_preserved_newline(current_token);\n                            }\n                        } else if (this._flags.last_token.type === TOKEN.WORD) {\n                            this._output.space_before_token = false;\n                            // function name() vs function name ()\n                            // function* name() vs function* name ()\n                            // async name() vs async name ()\n                            // In ES6, you can also define the method properties of an object\n                            // var obj = {a: function() {}}\n                            // It can be abbreviated\n                            // var obj = {a() {}}\n                            // var obj = { a() {}} vs var obj = { a () {}}\n                            // var obj = { * a() {}} vs var obj = { * a () {}}\n                            var peek_back_two = this._tokens.peek(-3);\n                            if (this._options.space_after_named_function && peek_back_two) {\n                                // peek starts at next character so -1 is current token\n                                var peek_back_three = this._tokens.peek(-4);\n                                if (reserved_array(peek_back_two, [\n                                    \"async\",\n                                    \"function\"\n                                ]) || peek_back_two.text === \"*\" && reserved_array(peek_back_three, [\n                                    \"async\",\n                                    \"function\"\n                                ])) {\n                                    this._output.space_before_token = true;\n                                } else if (this._flags.mode === MODE.ObjectLiteral) {\n                                    if (peek_back_two.text === \"{\" || peek_back_two.text === \",\" || peek_back_two.text === \"*\" && (peek_back_three.text === \"{\" || peek_back_three.text === \",\")) {\n                                        this._output.space_before_token = true;\n                                    }\n                                } else if (this._flags.parent && this._flags.parent.class_start_block) {\n                                    this._output.space_before_token = true;\n                                }\n                            }\n                        } else {\n                            // Support preserving wrapped arrow function expressions\n                            // a.b('c',\n                            //     () => d.e\n                            // )\n                            this.allow_wrap_or_preserved_newline(current_token);\n                        }\n                        // function() vs function ()\n                        // yield*() vs yield* ()\n                        // function*() vs function* ()\n                        if (this._flags.last_token.type === TOKEN.RESERVED && (this._flags.last_word === \"function\" || this._flags.last_word === \"typeof\") || this._flags.last_token.text === \"*\" && (in_array(this._last_last_text, [\n                            \"function\",\n                            \"yield\"\n                        ]) || this._flags.mode === MODE.ObjectLiteral && in_array(this._last_last_text, [\n                            \"{\",\n                            \",\"\n                        ]))) {\n                            this._output.space_before_token = this._options.space_after_anon_function;\n                        }\n                    }\n                    if (this._flags.last_token.text === \";\" || this._flags.last_token.type === TOKEN.START_BLOCK) {\n                        this.print_newline();\n                    } else if (this._flags.last_token.type === TOKEN.END_EXPR || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.END_BLOCK || this._flags.last_token.text === \".\" || this._flags.last_token.type === TOKEN.COMMA) {\n                        // do nothing on (( and )( and ][ and ]( and .(\n                        // TODO: Consider whether forcing this is required.  Review failing tests when removed.\n                        this.allow_wrap_or_preserved_newline(current_token, current_token.newlines);\n                    }\n                    this.print_token(current_token);\n                    this.set_mode(next_mode);\n                    if (this._options.space_in_paren) {\n                        this._output.space_before_token = true;\n                    }\n                    // In all cases, if we newline while inside an expression it should be indented.\n                    this.indent();\n                };\n                Beautifier.prototype.handle_end_expr = function(current_token) {\n                    // statements inside expressions are not valid syntax, but...\n                    // statements must all be closed when their container closes\n                    while(this._flags.mode === MODE.Statement){\n                        this.restore_mode();\n                    }\n                    this.handle_whitespace_and_comments(current_token);\n                    if (this._flags.multiline_frame) {\n                        this.allow_wrap_or_preserved_newline(current_token, current_token.text === \"]\" && is_array(this._flags.mode) && !this._options.keep_array_indentation);\n                    }\n                    if (this._options.space_in_paren) {\n                        if (this._flags.last_token.type === TOKEN.START_EXPR && !this._options.space_in_empty_paren) {\n                            // () [] no inner space in empty parens like these, ever, ref #320\n                            this._output.trim();\n                            this._output.space_before_token = false;\n                        } else {\n                            this._output.space_before_token = true;\n                        }\n                    }\n                    this.deindent();\n                    this.print_token(current_token);\n                    this.restore_mode();\n                    remove_redundant_indentation(this._output, this._previous_flags);\n                    // do {} while () // no statement required after\n                    if (this._flags.do_while && this._previous_flags.mode === MODE.Conditional) {\n                        this._previous_flags.mode = MODE.Expression;\n                        this._flags.do_block = false;\n                        this._flags.do_while = false;\n                    }\n                };\n                Beautifier.prototype.handle_start_block = function(current_token) {\n                    this.handle_whitespace_and_comments(current_token);\n                    // Check if this is should be treated as a ObjectLiteral\n                    var next_token = this._tokens.peek();\n                    var second_token = this._tokens.peek(1);\n                    if (this._flags.last_word === \"switch\" && this._flags.last_token.type === TOKEN.END_EXPR) {\n                        this.set_mode(MODE.BlockStatement);\n                        this._flags.in_case_statement = true;\n                    } else if (this._flags.case_body) {\n                        this.set_mode(MODE.BlockStatement);\n                    } else if (second_token && (in_array(second_token.text, [\n                        \":\",\n                        \",\"\n                    ]) && in_array(next_token.type, [\n                        TOKEN.STRING,\n                        TOKEN.WORD,\n                        TOKEN.RESERVED\n                    ]) || in_array(next_token.text, [\n                        \"get\",\n                        \"set\",\n                        \"...\"\n                    ]) && in_array(second_token.type, [\n                        TOKEN.WORD,\n                        TOKEN.RESERVED\n                    ]))) {\n                        // We don't support TypeScript,but we didn't break it for a very long time.\n                        // We'll try to keep not breaking it.\n                        if (in_array(this._last_last_text, [\n                            \"class\",\n                            \"interface\"\n                        ]) && !in_array(second_token.text, [\n                            \":\",\n                            \",\"\n                        ])) {\n                            this.set_mode(MODE.BlockStatement);\n                        } else {\n                            this.set_mode(MODE.ObjectLiteral);\n                        }\n                    } else if (this._flags.last_token.type === TOKEN.OPERATOR && this._flags.last_token.text === \"=>\") {\n                        // arrow function: (param1, paramN) => { statements }\n                        this.set_mode(MODE.BlockStatement);\n                    } else if (in_array(this._flags.last_token.type, [\n                        TOKEN.EQUALS,\n                        TOKEN.START_EXPR,\n                        TOKEN.COMMA,\n                        TOKEN.OPERATOR\n                    ]) || reserved_array(this._flags.last_token, [\n                        \"return\",\n                        \"throw\",\n                        \"import\",\n                        \"default\"\n                    ])) {\n                        // Detecting shorthand function syntax is difficult by scanning forward,\n                        //     so check the surrounding context.\n                        // If the block is being returned, imported, export default, passed as arg,\n                        //     assigned with = or assigned in a nested object, treat as an ObjectLiteral.\n                        this.set_mode(MODE.ObjectLiteral);\n                    } else {\n                        this.set_mode(MODE.BlockStatement);\n                    }\n                    if (this._flags.last_token) {\n                        if (reserved_array(this._flags.last_token.previous, [\n                            \"class\",\n                            \"extends\"\n                        ])) {\n                            this._flags.class_start_block = true;\n                        }\n                    }\n                    var empty_braces = !next_token.comments_before && next_token.text === \"}\";\n                    var empty_anonymous_function = empty_braces && this._flags.last_word === \"function\" && this._flags.last_token.type === TOKEN.END_EXPR;\n                    if (this._options.brace_preserve_inline) {\n                        // search forward for a newline wanted inside this block\n                        var index = 0;\n                        var check_token = null;\n                        this._flags.inline_frame = true;\n                        do {\n                            index += 1;\n                            check_token = this._tokens.peek(index - 1);\n                            if (check_token.newlines) {\n                                this._flags.inline_frame = false;\n                                break;\n                            }\n                        }while (check_token.type !== TOKEN.EOF && !(check_token.type === TOKEN.END_BLOCK && check_token.opened === current_token));\n                    }\n                    if ((this._options.brace_style === \"expand\" || this._options.brace_style === \"none\" && current_token.newlines) && !this._flags.inline_frame) {\n                        if (this._flags.last_token.type !== TOKEN.OPERATOR && (empty_anonymous_function || this._flags.last_token.type === TOKEN.EQUALS || reserved_array(this._flags.last_token, special_words) && this._flags.last_token.text !== \"else\")) {\n                            this._output.space_before_token = true;\n                        } else {\n                            this.print_newline(false, true);\n                        }\n                    } else {\n                        if (is_array(this._previous_flags.mode) && (this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.COMMA)) {\n                            if (this._flags.last_token.type === TOKEN.COMMA || this._options.space_in_paren) {\n                                this._output.space_before_token = true;\n                            }\n                            if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR && this._flags.inline_frame) {\n                                this.allow_wrap_or_preserved_newline(current_token);\n                                this._previous_flags.multiline_frame = this._previous_flags.multiline_frame || this._flags.multiline_frame;\n                                this._flags.multiline_frame = false;\n                            }\n                        }\n                        if (this._flags.last_token.type !== TOKEN.OPERATOR && this._flags.last_token.type !== TOKEN.START_EXPR) {\n                            if (in_array(this._flags.last_token.type, [\n                                TOKEN.START_BLOCK,\n                                TOKEN.SEMICOLON\n                            ]) && !this._flags.inline_frame) {\n                                this.print_newline();\n                            } else {\n                                this._output.space_before_token = true;\n                            }\n                        }\n                    }\n                    this.print_token(current_token);\n                    this.indent();\n                    // Except for specific cases, open braces are followed by a new line.\n                    if (!empty_braces && !(this._options.brace_preserve_inline && this._flags.inline_frame)) {\n                        this.print_newline();\n                    }\n                };\n                Beautifier.prototype.handle_end_block = function(current_token) {\n                    // statements must all be closed when their container closes\n                    this.handle_whitespace_and_comments(current_token);\n                    while(this._flags.mode === MODE.Statement){\n                        this.restore_mode();\n                    }\n                    var empty_braces = this._flags.last_token.type === TOKEN.START_BLOCK;\n                    if (this._flags.inline_frame && !empty_braces) {\n                        this._output.space_before_token = true;\n                    } else if (this._options.brace_style === \"expand\") {\n                        if (!empty_braces) {\n                            this.print_newline();\n                        }\n                    } else {\n                        // skip {}\n                        if (!empty_braces) {\n                            if (is_array(this._flags.mode) && this._options.keep_array_indentation) {\n                                // we REALLY need a newline here, but newliner would skip that\n                                this._options.keep_array_indentation = false;\n                                this.print_newline();\n                                this._options.keep_array_indentation = true;\n                            } else {\n                                this.print_newline();\n                            }\n                        }\n                    }\n                    this.restore_mode();\n                    this.print_token(current_token);\n                };\n                Beautifier.prototype.handle_word = function(current_token) {\n                    if (current_token.type === TOKEN.RESERVED) {\n                        if (in_array(current_token.text, [\n                            \"set\",\n                            \"get\"\n                        ]) && this._flags.mode !== MODE.ObjectLiteral) {\n                            current_token.type = TOKEN.WORD;\n                        } else if (current_token.text === \"import\" && in_array(this._tokens.peek().text, [\n                            \"(\",\n                            \".\"\n                        ])) {\n                            current_token.type = TOKEN.WORD;\n                        } else if (in_array(current_token.text, [\n                            \"as\",\n                            \"from\"\n                        ]) && !this._flags.import_block) {\n                            current_token.type = TOKEN.WORD;\n                        } else if (this._flags.mode === MODE.ObjectLiteral) {\n                            var next_token = this._tokens.peek();\n                            if (next_token.text === \":\") {\n                                current_token.type = TOKEN.WORD;\n                            }\n                        }\n                    }\n                    if (this.start_of_statement(current_token)) {\n                        // The conditional starts the statement if appropriate.\n                        if (reserved_array(this._flags.last_token, [\n                            \"var\",\n                            \"let\",\n                            \"const\"\n                        ]) && current_token.type === TOKEN.WORD) {\n                            this._flags.declaration_statement = true;\n                        }\n                    } else if (current_token.newlines && !is_expression(this._flags.mode) && (this._flags.last_token.type !== TOKEN.OPERATOR || this._flags.last_token.text === \"--\" || this._flags.last_token.text === \"++\") && this._flags.last_token.type !== TOKEN.EQUALS && (this._options.preserve_newlines || !reserved_array(this._flags.last_token, [\n                        \"var\",\n                        \"let\",\n                        \"const\",\n                        \"set\",\n                        \"get\"\n                    ]))) {\n                        this.handle_whitespace_and_comments(current_token);\n                        this.print_newline();\n                    } else {\n                        this.handle_whitespace_and_comments(current_token);\n                    }\n                    if (this._flags.do_block && !this._flags.do_while) {\n                        if (reserved_word(current_token, \"while\")) {\n                            // do {} ## while ()\n                            this._output.space_before_token = true;\n                            this.print_token(current_token);\n                            this._output.space_before_token = true;\n                            this._flags.do_while = true;\n                            return;\n                        } else {\n                            // do {} should always have while as the next word.\n                            // if we don't see the expected while, recover\n                            this.print_newline();\n                            this._flags.do_block = false;\n                        }\n                    }\n                    // if may be followed by else, or not\n                    // Bare/inline ifs are tricky\n                    // Need to unwind the modes correctly: if (a) if (b) c(); else d(); else e();\n                    if (this._flags.if_block) {\n                        if (!this._flags.else_block && reserved_word(current_token, \"else\")) {\n                            this._flags.else_block = true;\n                        } else {\n                            while(this._flags.mode === MODE.Statement){\n                                this.restore_mode();\n                            }\n                            this._flags.if_block = false;\n                            this._flags.else_block = false;\n                        }\n                    }\n                    if (this._flags.in_case_statement && reserved_array(current_token, [\n                        \"case\",\n                        \"default\"\n                    ])) {\n                        this.print_newline();\n                        if (!this._flags.case_block && (this._flags.case_body || this._options.jslint_happy)) {\n                            // switch cases following one another\n                            this.deindent();\n                        }\n                        this._flags.case_body = false;\n                        this.print_token(current_token);\n                        this._flags.in_case = true;\n                        return;\n                    }\n                    if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {\n                        if (!this.start_of_object_property() && !// start of object property is different for numeric values with +/- prefix operators\n                        (in_array(this._flags.last_token.text, [\n                            \"+\",\n                            \"-\"\n                        ]) && this._last_last_text === \":\" && this._flags.parent.mode === MODE.ObjectLiteral)) {\n                            this.allow_wrap_or_preserved_newline(current_token);\n                        }\n                    }\n                    if (reserved_word(current_token, \"function\")) {\n                        if (in_array(this._flags.last_token.text, [\n                            \"}\",\n                            \";\"\n                        ]) || this._output.just_added_newline() && !(in_array(this._flags.last_token.text, [\n                            \"(\",\n                            \"[\",\n                            \"{\",\n                            \":\",\n                            \"=\",\n                            \",\"\n                        ]) || this._flags.last_token.type === TOKEN.OPERATOR)) {\n                            // make sure there is a nice clean space of at least one blank line\n                            // before a new function definition\n                            if (!this._output.just_added_blankline() && !current_token.comments_before) {\n                                this.print_newline();\n                                this.print_newline(true);\n                            }\n                        }\n                        if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD) {\n                            if (reserved_array(this._flags.last_token, [\n                                \"get\",\n                                \"set\",\n                                \"new\",\n                                \"export\"\n                            ]) || reserved_array(this._flags.last_token, newline_restricted_tokens)) {\n                                this._output.space_before_token = true;\n                            } else if (reserved_word(this._flags.last_token, \"default\") && this._last_last_text === \"export\") {\n                                this._output.space_before_token = true;\n                            } else if (this._flags.last_token.text === \"declare\") {\n                                // accomodates Typescript declare function formatting\n                                this._output.space_before_token = true;\n                            } else {\n                                this.print_newline();\n                            }\n                        } else if (this._flags.last_token.type === TOKEN.OPERATOR || this._flags.last_token.text === \"=\") {\n                            // foo = function\n                            this._output.space_before_token = true;\n                        } else if (!this._flags.multiline_frame && (is_expression(this._flags.mode) || is_array(this._flags.mode))) {\n                        // (function\n                        } else {\n                            this.print_newline();\n                        }\n                        this.print_token(current_token);\n                        this._flags.last_word = current_token.text;\n                        return;\n                    }\n                    var prefix = \"NONE\";\n                    if (this._flags.last_token.type === TOKEN.END_BLOCK) {\n                        if (this._previous_flags.inline_frame) {\n                            prefix = \"SPACE\";\n                        } else if (!reserved_array(current_token, [\n                            \"else\",\n                            \"catch\",\n                            \"finally\",\n                            \"from\"\n                        ])) {\n                            prefix = \"NEWLINE\";\n                        } else {\n                            if (this._options.brace_style === \"expand\" || this._options.brace_style === \"end-expand\" || this._options.brace_style === \"none\" && current_token.newlines) {\n                                prefix = \"NEWLINE\";\n                            } else {\n                                prefix = \"SPACE\";\n                                this._output.space_before_token = true;\n                            }\n                        }\n                    } else if (this._flags.last_token.type === TOKEN.SEMICOLON && this._flags.mode === MODE.BlockStatement) {\n                        // TODO: Should this be for STATEMENT as well?\n                        prefix = \"NEWLINE\";\n                    } else if (this._flags.last_token.type === TOKEN.SEMICOLON && is_expression(this._flags.mode)) {\n                        prefix = \"SPACE\";\n                    } else if (this._flags.last_token.type === TOKEN.STRING) {\n                        prefix = \"NEWLINE\";\n                    } else if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD || this._flags.last_token.text === \"*\" && (in_array(this._last_last_text, [\n                        \"function\",\n                        \"yield\"\n                    ]) || this._flags.mode === MODE.ObjectLiteral && in_array(this._last_last_text, [\n                        \"{\",\n                        \",\"\n                    ]))) {\n                        prefix = \"SPACE\";\n                    } else if (this._flags.last_token.type === TOKEN.START_BLOCK) {\n                        if (this._flags.inline_frame) {\n                            prefix = \"SPACE\";\n                        } else {\n                            prefix = \"NEWLINE\";\n                        }\n                    } else if (this._flags.last_token.type === TOKEN.END_EXPR) {\n                        this._output.space_before_token = true;\n                        prefix = \"NEWLINE\";\n                    }\n                    if (reserved_array(current_token, line_starters) && this._flags.last_token.text !== \")\") {\n                        if (this._flags.inline_frame || this._flags.last_token.text === \"else\" || this._flags.last_token.text === \"export\") {\n                            prefix = \"SPACE\";\n                        } else {\n                            prefix = \"NEWLINE\";\n                        }\n                    }\n                    if (reserved_array(current_token, [\n                        \"else\",\n                        \"catch\",\n                        \"finally\"\n                    ])) {\n                        if ((!(this._flags.last_token.type === TOKEN.END_BLOCK && this._previous_flags.mode === MODE.BlockStatement) || this._options.brace_style === \"expand\" || this._options.brace_style === \"end-expand\" || this._options.brace_style === \"none\" && current_token.newlines) && !this._flags.inline_frame) {\n                            this.print_newline();\n                        } else {\n                            this._output.trim(true);\n                            var line = this._output.current_line;\n                            // If we trimmed and there's something other than a close block before us\n                            // put a newline back in.  Handles '} // comment' scenario.\n                            if (line.last() !== \"}\") {\n                                this.print_newline();\n                            }\n                            this._output.space_before_token = true;\n                        }\n                    } else if (prefix === \"NEWLINE\") {\n                        if (reserved_array(this._flags.last_token, special_words)) {\n                            // no newline between 'return nnn'\n                            this._output.space_before_token = true;\n                        } else if (this._flags.last_token.text === \"declare\" && reserved_array(current_token, [\n                            \"var\",\n                            \"let\",\n                            \"const\"\n                        ])) {\n                            // accomodates Typescript declare formatting\n                            this._output.space_before_token = true;\n                        } else if (this._flags.last_token.type !== TOKEN.END_EXPR) {\n                            if ((this._flags.last_token.type !== TOKEN.START_EXPR || !reserved_array(current_token, [\n                                \"var\",\n                                \"let\",\n                                \"const\"\n                            ])) && this._flags.last_token.text !== \":\") {\n                                // no need to force newline on 'var': for (var x = 0...)\n                                if (reserved_word(current_token, \"if\") && reserved_word(current_token.previous, \"else\")) {\n                                    // no newline for } else if {\n                                    this._output.space_before_token = true;\n                                } else {\n                                    this.print_newline();\n                                }\n                            }\n                        } else if (reserved_array(current_token, line_starters) && this._flags.last_token.text !== \")\") {\n                            this.print_newline();\n                        }\n                    } else if (this._flags.multiline_frame && is_array(this._flags.mode) && this._flags.last_token.text === \",\" && this._last_last_text === \"}\") {\n                        this.print_newline(); // }, in lists get a newline treatment\n                    } else if (prefix === \"SPACE\") {\n                        this._output.space_before_token = true;\n                    }\n                    if (current_token.previous && (current_token.previous.type === TOKEN.WORD || current_token.previous.type === TOKEN.RESERVED)) {\n                        this._output.space_before_token = true;\n                    }\n                    this.print_token(current_token);\n                    this._flags.last_word = current_token.text;\n                    if (current_token.type === TOKEN.RESERVED) {\n                        if (current_token.text === \"do\") {\n                            this._flags.do_block = true;\n                        } else if (current_token.text === \"if\") {\n                            this._flags.if_block = true;\n                        } else if (current_token.text === \"import\") {\n                            this._flags.import_block = true;\n                        } else if (this._flags.import_block && reserved_word(current_token, \"from\")) {\n                            this._flags.import_block = false;\n                        }\n                    }\n                };\n                Beautifier.prototype.handle_semicolon = function(current_token) {\n                    if (this.start_of_statement(current_token)) {\n                        // The conditional starts the statement if appropriate.\n                        // Semicolon can be the start (and end) of a statement\n                        this._output.space_before_token = false;\n                    } else {\n                        this.handle_whitespace_and_comments(current_token);\n                    }\n                    var next_token = this._tokens.peek();\n                    while(this._flags.mode === MODE.Statement && !(this._flags.if_block && reserved_word(next_token, \"else\")) && !this._flags.do_block){\n                        this.restore_mode();\n                    }\n                    // hacky but effective for the moment\n                    if (this._flags.import_block) {\n                        this._flags.import_block = false;\n                    }\n                    this.print_token(current_token);\n                };\n                Beautifier.prototype.handle_string = function(current_token) {\n                    if (current_token.text.startsWith(\"`\") && current_token.newlines === 0 && current_token.whitespace_before === \"\" && (current_token.previous.text === \")\" || this._flags.last_token.type === TOKEN.WORD)) {\n                    //Conditional for detectign backtick strings\n                    } else if (this.start_of_statement(current_token)) {\n                        // The conditional starts the statement if appropriate.\n                        // One difference - strings want at least a space before\n                        this._output.space_before_token = true;\n                    } else {\n                        this.handle_whitespace_and_comments(current_token);\n                        if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD || this._flags.inline_frame) {\n                            this._output.space_before_token = true;\n                        } else if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {\n                            if (!this.start_of_object_property()) {\n                                this.allow_wrap_or_preserved_newline(current_token);\n                            }\n                        } else if (current_token.text.startsWith(\"`\") && this._flags.last_token.type === TOKEN.END_EXPR && (current_token.previous.text === \"]\" || current_token.previous.text === \")\") && current_token.newlines === 0) {\n                            this._output.space_before_token = true;\n                        } else {\n                            this.print_newline();\n                        }\n                    }\n                    this.print_token(current_token);\n                };\n                Beautifier.prototype.handle_equals = function(current_token) {\n                    if (this.start_of_statement(current_token)) {\n                    // The conditional starts the statement if appropriate.\n                    } else {\n                        this.handle_whitespace_and_comments(current_token);\n                    }\n                    if (this._flags.declaration_statement) {\n                        // just got an '=' in a var-line, different formatting/line-breaking, etc will now be done\n                        this._flags.declaration_assignment = true;\n                    }\n                    this._output.space_before_token = true;\n                    this.print_token(current_token);\n                    this._output.space_before_token = true;\n                };\n                Beautifier.prototype.handle_comma = function(current_token) {\n                    this.handle_whitespace_and_comments(current_token, true);\n                    this.print_token(current_token);\n                    this._output.space_before_token = true;\n                    if (this._flags.declaration_statement) {\n                        if (is_expression(this._flags.parent.mode)) {\n                            // do not break on comma, for(var a = 1, b = 2)\n                            this._flags.declaration_assignment = false;\n                        }\n                        if (this._flags.declaration_assignment) {\n                            this._flags.declaration_assignment = false;\n                            this.print_newline(false, true);\n                        } else if (this._options.comma_first) {\n                            // for comma-first, we want to allow a newline before the comma\n                            // to turn into a newline after the comma, which we will fixup later\n                            this.allow_wrap_or_preserved_newline(current_token);\n                        }\n                    } else if (this._flags.mode === MODE.ObjectLiteral || this._flags.mode === MODE.Statement && this._flags.parent.mode === MODE.ObjectLiteral) {\n                        if (this._flags.mode === MODE.Statement) {\n                            this.restore_mode();\n                        }\n                        if (!this._flags.inline_frame) {\n                            this.print_newline();\n                        }\n                    } else if (this._options.comma_first) {\n                        // EXPR or DO_BLOCK\n                        // for comma-first, we want to allow a newline before the comma\n                        // to turn into a newline after the comma, which we will fixup later\n                        this.allow_wrap_or_preserved_newline(current_token);\n                    }\n                };\n                Beautifier.prototype.handle_operator = function(current_token) {\n                    var isGeneratorAsterisk = current_token.text === \"*\" && (reserved_array(this._flags.last_token, [\n                        \"function\",\n                        \"yield\"\n                    ]) || in_array(this._flags.last_token.type, [\n                        TOKEN.START_BLOCK,\n                        TOKEN.COMMA,\n                        TOKEN.END_BLOCK,\n                        TOKEN.SEMICOLON\n                    ]));\n                    var isUnary = in_array(current_token.text, [\n                        \"-\",\n                        \"+\"\n                    ]) && (in_array(this._flags.last_token.type, [\n                        TOKEN.START_BLOCK,\n                        TOKEN.START_EXPR,\n                        TOKEN.EQUALS,\n                        TOKEN.OPERATOR\n                    ]) || in_array(this._flags.last_token.text, line_starters) || this._flags.last_token.text === \",\");\n                    if (this.start_of_statement(current_token)) {\n                    // The conditional starts the statement if appropriate.\n                    } else {\n                        var preserve_statement_flags = !isGeneratorAsterisk;\n                        this.handle_whitespace_and_comments(current_token, preserve_statement_flags);\n                    }\n                    // hack for actionscript's import .*;\n                    if (current_token.text === \"*\" && this._flags.last_token.type === TOKEN.DOT) {\n                        this.print_token(current_token);\n                        return;\n                    }\n                    if (current_token.text === \"::\") {\n                        // no spaces around exotic namespacing syntax operator\n                        this.print_token(current_token);\n                        return;\n                    }\n                    if (in_array(current_token.text, [\n                        \"-\",\n                        \"+\"\n                    ]) && this.start_of_object_property()) {\n                        // numeric value with +/- symbol in front as a property\n                        this.print_token(current_token);\n                        return;\n                    }\n                    // Allow line wrapping between operators when operator_position is\n                    //   set to before or preserve\n                    if (this._flags.last_token.type === TOKEN.OPERATOR && in_array(this._options.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE)) {\n                        this.allow_wrap_or_preserved_newline(current_token);\n                    }\n                    if (current_token.text === \":\" && this._flags.in_case) {\n                        this.print_token(current_token);\n                        this._flags.in_case = false;\n                        this._flags.case_body = true;\n                        if (this._tokens.peek().type !== TOKEN.START_BLOCK) {\n                            this.indent();\n                            this.print_newline();\n                            this._flags.case_block = false;\n                        } else {\n                            this._flags.case_block = true;\n                            this._output.space_before_token = true;\n                        }\n                        return;\n                    }\n                    var space_before = true;\n                    var space_after = true;\n                    var in_ternary = false;\n                    if (current_token.text === \":\") {\n                        if (this._flags.ternary_depth === 0) {\n                            // Colon is invalid javascript outside of ternary and object, but do our best to guess what was meant.\n                            space_before = false;\n                        } else {\n                            this._flags.ternary_depth -= 1;\n                            in_ternary = true;\n                        }\n                    } else if (current_token.text === \"?\") {\n                        this._flags.ternary_depth += 1;\n                    }\n                    // let's handle the operator_position option prior to any conflicting logic\n                    if (!isUnary && !isGeneratorAsterisk && this._options.preserve_newlines && in_array(current_token.text, positionable_operators)) {\n                        var isColon = current_token.text === \":\";\n                        var isTernaryColon = isColon && in_ternary;\n                        var isOtherColon = isColon && !in_ternary;\n                        switch(this._options.operator_position){\n                            case OPERATOR_POSITION.before_newline:\n                                // if the current token is : and it's not a ternary statement then we set space_before to false\n                                this._output.space_before_token = !isOtherColon;\n                                this.print_token(current_token);\n                                if (!isColon || isTernaryColon) {\n                                    this.allow_wrap_or_preserved_newline(current_token);\n                                }\n                                this._output.space_before_token = true;\n                                return;\n                            case OPERATOR_POSITION.after_newline:\n                                // if the current token is anything but colon, or (via deduction) it's a colon and in a ternary statement,\n                                //   then print a newline.\n                                this._output.space_before_token = true;\n                                if (!isColon || isTernaryColon) {\n                                    if (this._tokens.peek().newlines) {\n                                        this.print_newline(false, true);\n                                    } else {\n                                        this.allow_wrap_or_preserved_newline(current_token);\n                                    }\n                                } else {\n                                    this._output.space_before_token = false;\n                                }\n                                this.print_token(current_token);\n                                this._output.space_before_token = true;\n                                return;\n                            case OPERATOR_POSITION.preserve_newline:\n                                if (!isOtherColon) {\n                                    this.allow_wrap_or_preserved_newline(current_token);\n                                }\n                                // if we just added a newline, or the current token is : and it's not a ternary statement,\n                                //   then we set space_before to false\n                                space_before = !(this._output.just_added_newline() || isOtherColon);\n                                this._output.space_before_token = space_before;\n                                this.print_token(current_token);\n                                this._output.space_before_token = true;\n                                return;\n                        }\n                    }\n                    if (isGeneratorAsterisk) {\n                        this.allow_wrap_or_preserved_newline(current_token);\n                        space_before = false;\n                        var next_token = this._tokens.peek();\n                        space_after = next_token && in_array(next_token.type, [\n                            TOKEN.WORD,\n                            TOKEN.RESERVED\n                        ]);\n                    } else if (current_token.text === \"...\") {\n                        this.allow_wrap_or_preserved_newline(current_token);\n                        space_before = this._flags.last_token.type === TOKEN.START_BLOCK;\n                        space_after = false;\n                    } else if (in_array(current_token.text, [\n                        \"--\",\n                        \"++\",\n                        \"!\",\n                        \"~\"\n                    ]) || isUnary) {\n                        // unary operators (and binary +/- pretending to be unary) special cases\n                        if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR) {\n                            this.allow_wrap_or_preserved_newline(current_token);\n                        }\n                        space_before = false;\n                        space_after = false;\n                        // http://www.ecma-international.org/ecma-262/5.1/#sec-7.9.1\n                        // if there is a newline between -- or ++ and anything else we should preserve it.\n                        if (current_token.newlines && (current_token.text === \"--\" || current_token.text === \"++\" || current_token.text === \"~\")) {\n                            var new_line_needed = reserved_array(this._flags.last_token, special_words) && current_token.newlines;\n                            if (new_line_needed && (this._previous_flags.if_block || this._previous_flags.else_block)) {\n                                this.restore_mode();\n                            }\n                            this.print_newline(new_line_needed, true);\n                        }\n                        if (this._flags.last_token.text === \";\" && is_expression(this._flags.mode)) {\n                            // for (;; ++i)\n                            //        ^^^\n                            space_before = true;\n                        }\n                        if (this._flags.last_token.type === TOKEN.RESERVED) {\n                            space_before = true;\n                        } else if (this._flags.last_token.type === TOKEN.END_EXPR) {\n                            space_before = !(this._flags.last_token.text === \"]\" && (current_token.text === \"--\" || current_token.text === \"++\"));\n                        } else if (this._flags.last_token.type === TOKEN.OPERATOR) {\n                            // a++ + ++b;\n                            // a - -b\n                            space_before = in_array(current_token.text, [\n                                \"--\",\n                                \"-\",\n                                \"++\",\n                                \"+\"\n                            ]) && in_array(this._flags.last_token.text, [\n                                \"--\",\n                                \"-\",\n                                \"++\",\n                                \"+\"\n                            ]);\n                            // + and - are not unary when preceeded by -- or ++ operator\n                            // a-- + b\n                            // a * +b\n                            // a - -b\n                            if (in_array(current_token.text, [\n                                \"+\",\n                                \"-\"\n                            ]) && in_array(this._flags.last_token.text, [\n                                \"--\",\n                                \"++\"\n                            ])) {\n                                space_after = true;\n                            }\n                        }\n                        if ((this._flags.mode === MODE.BlockStatement && !this._flags.inline_frame || this._flags.mode === MODE.Statement) && (this._flags.last_token.text === \"{\" || this._flags.last_token.text === \";\")) {\n                            // { foo; --i }\n                            // foo(); --bar;\n                            this.print_newline();\n                        }\n                    }\n                    this._output.space_before_token = this._output.space_before_token || space_before;\n                    this.print_token(current_token);\n                    this._output.space_before_token = space_after;\n                };\n                Beautifier.prototype.handle_block_comment = function(current_token, preserve_statement_flags) {\n                    if (this._output.raw) {\n                        this._output.add_raw_token(current_token);\n                        if (current_token.directives && current_token.directives.preserve === \"end\") {\n                            // If we're testing the raw output behavior, do not allow a directive to turn it off.\n                            this._output.raw = this._options.test_output_raw;\n                        }\n                        return;\n                    }\n                    if (current_token.directives) {\n                        this.print_newline(false, preserve_statement_flags);\n                        this.print_token(current_token);\n                        if (current_token.directives.preserve === \"start\") {\n                            this._output.raw = true;\n                        }\n                        this.print_newline(false, true);\n                        return;\n                    }\n                    // inline block\n                    if (!acorn.newline.test(current_token.text) && !current_token.newlines) {\n                        this._output.space_before_token = true;\n                        this.print_token(current_token);\n                        this._output.space_before_token = true;\n                        return;\n                    } else {\n                        this.print_block_commment(current_token, preserve_statement_flags);\n                    }\n                };\n                Beautifier.prototype.print_block_commment = function(current_token, preserve_statement_flags) {\n                    var lines = split_linebreaks(current_token.text);\n                    var j; // iterator for this case\n                    var javadoc = false;\n                    var starless = false;\n                    var lastIndent = current_token.whitespace_before;\n                    var lastIndentLength = lastIndent.length;\n                    // block comment starts with a new line\n                    this.print_newline(false, preserve_statement_flags);\n                    // first line always indented\n                    this.print_token_line_indentation(current_token);\n                    this._output.add_token(lines[0]);\n                    this.print_newline(false, preserve_statement_flags);\n                    if (lines.length > 1) {\n                        lines = lines.slice(1);\n                        javadoc = all_lines_start_with(lines, \"*\");\n                        starless = each_line_matches_indent(lines, lastIndent);\n                        if (javadoc) {\n                            this._flags.alignment = 1;\n                        }\n                        for(j = 0; j < lines.length; j++){\n                            if (javadoc) {\n                                // javadoc: reformat and re-indent\n                                this.print_token_line_indentation(current_token);\n                                this._output.add_token(ltrim(lines[j]));\n                            } else if (starless && lines[j]) {\n                                // starless: re-indent non-empty content, avoiding trim\n                                this.print_token_line_indentation(current_token);\n                                this._output.add_token(lines[j].substring(lastIndentLength));\n                            } else {\n                                // normal comments output raw\n                                this._output.current_line.set_indent(-1);\n                                this._output.add_token(lines[j]);\n                            }\n                            // for comments on their own line or  more than one line, make sure there's a new line after\n                            this.print_newline(false, preserve_statement_flags);\n                        }\n                        this._flags.alignment = 0;\n                    }\n                };\n                Beautifier.prototype.handle_comment = function(current_token, preserve_statement_flags) {\n                    if (current_token.newlines) {\n                        this.print_newline(false, preserve_statement_flags);\n                    } else {\n                        this._output.trim(true);\n                    }\n                    this._output.space_before_token = true;\n                    this.print_token(current_token);\n                    this.print_newline(false, preserve_statement_flags);\n                };\n                Beautifier.prototype.handle_dot = function(current_token) {\n                    if (this.start_of_statement(current_token)) {\n                    // The conditional starts the statement if appropriate.\n                    } else {\n                        this.handle_whitespace_and_comments(current_token, true);\n                    }\n                    if (this._flags.last_token.text.match(\"^[0-9]+$\")) {\n                        this._output.space_before_token = true;\n                    }\n                    if (reserved_array(this._flags.last_token, special_words)) {\n                        this._output.space_before_token = false;\n                    } else {\n                        // allow preserved newlines before dots in general\n                        // force newlines on dots after close paren when break_chained - for bar().baz()\n                        this.allow_wrap_or_preserved_newline(current_token, this._flags.last_token.text === \")\" && this._options.break_chained_methods);\n                    }\n                    // Only unindent chained method dot if this dot starts a new line.\n                    // Otherwise the automatic extra indentation removal will handle the over indent\n                    if (this._options.unindent_chained_methods && this._output.just_added_newline()) {\n                        this.deindent();\n                    }\n                    this.print_token(current_token);\n                };\n                Beautifier.prototype.handle_unknown = function(current_token, preserve_statement_flags) {\n                    this.print_token(current_token);\n                    if (current_token.text[current_token.text.length - 1] === \"\\n\") {\n                        this.print_newline(false, preserve_statement_flags);\n                    }\n                };\n                Beautifier.prototype.handle_eof = function(current_token) {\n                    // Unwind any open statements\n                    while(this._flags.mode === MODE.Statement){\n                        this.restore_mode();\n                    }\n                    this.handle_whitespace_and_comments(current_token);\n                };\n                module.exports.Beautifier = Beautifier;\n            /***/ },\n            /* 2 */ /***/ function(module) {\n                /*jshint node:true */ /*\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ function OutputLine(parent) {\n                    this.__parent = parent;\n                    this.__character_count = 0;\n                    // use indent_count as a marker for this.__lines that have preserved indentation\n                    this.__indent_count = -1;\n                    this.__alignment_count = 0;\n                    this.__wrap_point_index = 0;\n                    this.__wrap_point_character_count = 0;\n                    this.__wrap_point_indent_count = -1;\n                    this.__wrap_point_alignment_count = 0;\n                    this.__items = [];\n                }\n                OutputLine.prototype.clone_empty = function() {\n                    var line = new OutputLine(this.__parent);\n                    line.set_indent(this.__indent_count, this.__alignment_count);\n                    return line;\n                };\n                OutputLine.prototype.item = function(index) {\n                    if (index < 0) {\n                        return this.__items[this.__items.length + index];\n                    } else {\n                        return this.__items[index];\n                    }\n                };\n                OutputLine.prototype.has_match = function(pattern) {\n                    for(var lastCheckedOutput = this.__items.length - 1; lastCheckedOutput >= 0; lastCheckedOutput--){\n                        if (this.__items[lastCheckedOutput].match(pattern)) {\n                            return true;\n                        }\n                    }\n                    return false;\n                };\n                OutputLine.prototype.set_indent = function(indent, alignment) {\n                    if (this.is_empty()) {\n                        this.__indent_count = indent || 0;\n                        this.__alignment_count = alignment || 0;\n                        this.__character_count = this.__parent.get_indent_size(this.__indent_count, this.__alignment_count);\n                    }\n                };\n                OutputLine.prototype._set_wrap_point = function() {\n                    if (this.__parent.wrap_line_length) {\n                        this.__wrap_point_index = this.__items.length;\n                        this.__wrap_point_character_count = this.__character_count;\n                        this.__wrap_point_indent_count = this.__parent.next_line.__indent_count;\n                        this.__wrap_point_alignment_count = this.__parent.next_line.__alignment_count;\n                    }\n                };\n                OutputLine.prototype._should_wrap = function() {\n                    return this.__wrap_point_index && this.__character_count > this.__parent.wrap_line_length && this.__wrap_point_character_count > this.__parent.next_line.__character_count;\n                };\n                OutputLine.prototype._allow_wrap = function() {\n                    if (this._should_wrap()) {\n                        this.__parent.add_new_line();\n                        var next = this.__parent.current_line;\n                        next.set_indent(this.__wrap_point_indent_count, this.__wrap_point_alignment_count);\n                        next.__items = this.__items.slice(this.__wrap_point_index);\n                        this.__items = this.__items.slice(0, this.__wrap_point_index);\n                        next.__character_count += this.__character_count - this.__wrap_point_character_count;\n                        this.__character_count = this.__wrap_point_character_count;\n                        if (next.__items[0] === \" \") {\n                            next.__items.splice(0, 1);\n                            next.__character_count -= 1;\n                        }\n                        return true;\n                    }\n                    return false;\n                };\n                OutputLine.prototype.is_empty = function() {\n                    return this.__items.length === 0;\n                };\n                OutputLine.prototype.last = function() {\n                    if (!this.is_empty()) {\n                        return this.__items[this.__items.length - 1];\n                    } else {\n                        return null;\n                    }\n                };\n                OutputLine.prototype.push = function(item) {\n                    this.__items.push(item);\n                    var last_newline_index = item.lastIndexOf(\"\\n\");\n                    if (last_newline_index !== -1) {\n                        this.__character_count = item.length - last_newline_index;\n                    } else {\n                        this.__character_count += item.length;\n                    }\n                };\n                OutputLine.prototype.pop = function() {\n                    var item = null;\n                    if (!this.is_empty()) {\n                        item = this.__items.pop();\n                        this.__character_count -= item.length;\n                    }\n                    return item;\n                };\n                OutputLine.prototype._remove_indent = function() {\n                    if (this.__indent_count > 0) {\n                        this.__indent_count -= 1;\n                        this.__character_count -= this.__parent.indent_size;\n                    }\n                };\n                OutputLine.prototype._remove_wrap_indent = function() {\n                    if (this.__wrap_point_indent_count > 0) {\n                        this.__wrap_point_indent_count -= 1;\n                    }\n                };\n                OutputLine.prototype.trim = function() {\n                    while(this.last() === \" \"){\n                        this.__items.pop();\n                        this.__character_count -= 1;\n                    }\n                };\n                OutputLine.prototype.toString = function() {\n                    var result = \"\";\n                    if (this.is_empty()) {\n                        if (this.__parent.indent_empty_lines) {\n                            result = this.__parent.get_indent_string(this.__indent_count);\n                        }\n                    } else {\n                        result = this.__parent.get_indent_string(this.__indent_count, this.__alignment_count);\n                        result += this.__items.join(\"\");\n                    }\n                    return result;\n                };\n                function IndentStringCache(options, baseIndentString) {\n                    this.__cache = [\n                        \"\"\n                    ];\n                    this.__indent_size = options.indent_size;\n                    this.__indent_string = options.indent_char;\n                    if (!options.indent_with_tabs) {\n                        this.__indent_string = new Array(options.indent_size + 1).join(options.indent_char);\n                    }\n                    // Set to null to continue support for auto detection of base indent\n                    baseIndentString = baseIndentString || \"\";\n                    if (options.indent_level > 0) {\n                        baseIndentString = new Array(options.indent_level + 1).join(this.__indent_string);\n                    }\n                    this.__base_string = baseIndentString;\n                    this.__base_string_length = baseIndentString.length;\n                }\n                IndentStringCache.prototype.get_indent_size = function(indent, column) {\n                    var result = this.__base_string_length;\n                    column = column || 0;\n                    if (indent < 0) {\n                        result = 0;\n                    }\n                    result += indent * this.__indent_size;\n                    result += column;\n                    return result;\n                };\n                IndentStringCache.prototype.get_indent_string = function(indent_level, column) {\n                    var result = this.__base_string;\n                    column = column || 0;\n                    if (indent_level < 0) {\n                        indent_level = 0;\n                        result = \"\";\n                    }\n                    column += indent_level * this.__indent_size;\n                    this.__ensure_cache(column);\n                    result += this.__cache[column];\n                    return result;\n                };\n                IndentStringCache.prototype.__ensure_cache = function(column) {\n                    while(column >= this.__cache.length){\n                        this.__add_column();\n                    }\n                };\n                IndentStringCache.prototype.__add_column = function() {\n                    var column = this.__cache.length;\n                    var indent = 0;\n                    var result = \"\";\n                    if (this.__indent_size && column >= this.__indent_size) {\n                        indent = Math.floor(column / this.__indent_size);\n                        column -= indent * this.__indent_size;\n                        result = new Array(indent + 1).join(this.__indent_string);\n                    }\n                    if (column) {\n                        result += new Array(column + 1).join(\" \");\n                    }\n                    this.__cache.push(result);\n                };\n                function Output(options, baseIndentString) {\n                    this.__indent_cache = new IndentStringCache(options, baseIndentString);\n                    this.raw = false;\n                    this._end_with_newline = options.end_with_newline;\n                    this.indent_size = options.indent_size;\n                    this.wrap_line_length = options.wrap_line_length;\n                    this.indent_empty_lines = options.indent_empty_lines;\n                    this.__lines = [];\n                    this.previous_line = null;\n                    this.current_line = null;\n                    this.next_line = new OutputLine(this);\n                    this.space_before_token = false;\n                    this.non_breaking_space = false;\n                    this.previous_token_wrapped = false;\n                    // initialize\n                    this.__add_outputline();\n                }\n                Output.prototype.__add_outputline = function() {\n                    this.previous_line = this.current_line;\n                    this.current_line = this.next_line.clone_empty();\n                    this.__lines.push(this.current_line);\n                };\n                Output.prototype.get_line_number = function() {\n                    return this.__lines.length;\n                };\n                Output.prototype.get_indent_string = function(indent, column) {\n                    return this.__indent_cache.get_indent_string(indent, column);\n                };\n                Output.prototype.get_indent_size = function(indent, column) {\n                    return this.__indent_cache.get_indent_size(indent, column);\n                };\n                Output.prototype.is_empty = function() {\n                    return !this.previous_line && this.current_line.is_empty();\n                };\n                Output.prototype.add_new_line = function(force_newline) {\n                    // never newline at the start of file\n                    // otherwise, newline only if we didn't just add one or we're forced\n                    if (this.is_empty() || !force_newline && this.just_added_newline()) {\n                        return false;\n                    }\n                    // if raw output is enabled, don't print additional newlines,\n                    // but still return True as though you had\n                    if (!this.raw) {\n                        this.__add_outputline();\n                    }\n                    return true;\n                };\n                Output.prototype.get_code = function(eol) {\n                    this.trim(true);\n                    // handle some edge cases where the last tokens\n                    // has text that ends with newline(s)\n                    var last_item = this.current_line.pop();\n                    if (last_item) {\n                        if (last_item[last_item.length - 1] === \"\\n\") {\n                            last_item = last_item.replace(/\\n+$/g, \"\");\n                        }\n                        this.current_line.push(last_item);\n                    }\n                    if (this._end_with_newline) {\n                        this.__add_outputline();\n                    }\n                    var sweet_code = this.__lines.join(\"\\n\");\n                    if (eol !== \"\\n\") {\n                        sweet_code = sweet_code.replace(/[\\n]/g, eol);\n                    }\n                    return sweet_code;\n                };\n                Output.prototype.set_wrap_point = function() {\n                    this.current_line._set_wrap_point();\n                };\n                Output.prototype.set_indent = function(indent, alignment) {\n                    indent = indent || 0;\n                    alignment = alignment || 0;\n                    // Next line stores alignment values\n                    this.next_line.set_indent(indent, alignment);\n                    // Never indent your first output indent at the start of the file\n                    if (this.__lines.length > 1) {\n                        this.current_line.set_indent(indent, alignment);\n                        return true;\n                    }\n                    this.current_line.set_indent();\n                    return false;\n                };\n                Output.prototype.add_raw_token = function(token) {\n                    for(var x = 0; x < token.newlines; x++){\n                        this.__add_outputline();\n                    }\n                    this.current_line.set_indent(-1);\n                    this.current_line.push(token.whitespace_before);\n                    this.current_line.push(token.text);\n                    this.space_before_token = false;\n                    this.non_breaking_space = false;\n                    this.previous_token_wrapped = false;\n                };\n                Output.prototype.add_token = function(printable_token) {\n                    this.__add_space_before_token();\n                    this.current_line.push(printable_token);\n                    this.space_before_token = false;\n                    this.non_breaking_space = false;\n                    this.previous_token_wrapped = this.current_line._allow_wrap();\n                };\n                Output.prototype.__add_space_before_token = function() {\n                    if (this.space_before_token && !this.just_added_newline()) {\n                        if (!this.non_breaking_space) {\n                            this.set_wrap_point();\n                        }\n                        this.current_line.push(\" \");\n                    }\n                };\n                Output.prototype.remove_indent = function(index) {\n                    var output_length = this.__lines.length;\n                    while(index < output_length){\n                        this.__lines[index]._remove_indent();\n                        index++;\n                    }\n                    this.current_line._remove_wrap_indent();\n                };\n                Output.prototype.trim = function(eat_newlines) {\n                    eat_newlines = eat_newlines === undefined ? false : eat_newlines;\n                    this.current_line.trim();\n                    while(eat_newlines && this.__lines.length > 1 && this.current_line.is_empty()){\n                        this.__lines.pop();\n                        this.current_line = this.__lines[this.__lines.length - 1];\n                        this.current_line.trim();\n                    }\n                    this.previous_line = this.__lines.length > 1 ? this.__lines[this.__lines.length - 2] : null;\n                };\n                Output.prototype.just_added_newline = function() {\n                    return this.current_line.is_empty();\n                };\n                Output.prototype.just_added_blankline = function() {\n                    return this.is_empty() || this.current_line.is_empty() && this.previous_line.is_empty();\n                };\n                Output.prototype.ensure_empty_line_above = function(starts_with, ends_with) {\n                    var index = this.__lines.length - 2;\n                    while(index >= 0){\n                        var potentialEmptyLine = this.__lines[index];\n                        if (potentialEmptyLine.is_empty()) {\n                            break;\n                        } else if (potentialEmptyLine.item(0).indexOf(starts_with) !== 0 && potentialEmptyLine.item(-1) !== ends_with) {\n                            this.__lines.splice(index + 1, 0, new OutputLine(this));\n                            this.previous_line = this.__lines[this.__lines.length - 2];\n                            break;\n                        }\n                        index--;\n                    }\n                };\n                module.exports.Output = Output;\n            /***/ },\n            /* 3 */ /***/ function(module) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ function Token(type, text, newlines, whitespace_before) {\n                    this.type = type;\n                    this.text = text;\n                    // comments_before are\n                    // comments that have a new line before them\n                    // and may or may not have a newline after\n                    // this is a set of comments before\n                    this.comments_before = null; /* inline comment*/ \n                    // this.comments_after =  new TokenStream(); // no new line before and newline after\n                    this.newlines = newlines || 0;\n                    this.whitespace_before = whitespace_before || \"\";\n                    this.parent = null;\n                    this.next = null;\n                    this.previous = null;\n                    this.opened = null;\n                    this.closed = null;\n                    this.directives = null;\n                }\n                module.exports.Token = Token;\n            /***/ },\n            /* 4 */ /***/ function(__unused_webpack_module, exports1) {\n                /* jshint node: true, curly: false */ // Parts of this section of code is taken from acorn.\n                //\n                // Acorn was written by Marijn Haverbeke and released under an MIT\n                // license. The Unicode regexps (for identifiers and whitespace) were\n                // taken from [Esprima](http://esprima.org) by Ariya Hidayat.\n                //\n                // Git repositories for Acorn are available at\n                //\n                //     http://marijnhaverbeke.nl/git/acorn\n                //     https://github.com/marijnh/acorn.git\n                // ## Character categories\n                // acorn used char codes to squeeze the last bit of performance out\n                // Beautifier is okay without that, so we're using regex\n                // permit # (23), $ (36), and @ (64). @ is used in ES7 decorators.\n                // 65 through 91 are uppercase letters.\n                // permit _ (95).\n                // 97 through 123 are lowercase letters.\n                var baseASCIIidentifierStartChars = \"\\\\x23\\\\x24\\\\x40\\\\x41-\\\\x5a\\\\x5f\\\\x61-\\\\x7a\";\n                // inside an identifier @ is not allowed but 0-9 are.\n                var baseASCIIidentifierChars = \"\\\\x24\\\\x30-\\\\x39\\\\x41-\\\\x5a\\\\x5f\\\\x61-\\\\x7a\";\n                // Big ugly regular expressions that match characters in the\n                // whitespace, identifier, and identifier-start categories. These\n                // are only applied when a character is found to actually have a\n                // code point above 128.\n                var nonASCIIidentifierStartChars = \"\\\\xaa\\\\xb5\\\\xba\\\\xc0-\\\\xd6\\\\xd8-\\\\xf6\\\\xf8-\\\\u02c1\\\\u02c6-\\\\u02d1\\\\u02e0-\\\\u02e4\\\\u02ec\\\\u02ee\\\\u0370-\\\\u0374\\\\u0376\\\\u0377\\\\u037a-\\\\u037d\\\\u0386\\\\u0388-\\\\u038a\\\\u038c\\\\u038e-\\\\u03a1\\\\u03a3-\\\\u03f5\\\\u03f7-\\\\u0481\\\\u048a-\\\\u0527\\\\u0531-\\\\u0556\\\\u0559\\\\u0561-\\\\u0587\\\\u05d0-\\\\u05ea\\\\u05f0-\\\\u05f2\\\\u0620-\\\\u064a\\\\u066e\\\\u066f\\\\u0671-\\\\u06d3\\\\u06d5\\\\u06e5\\\\u06e6\\\\u06ee\\\\u06ef\\\\u06fa-\\\\u06fc\\\\u06ff\\\\u0710\\\\u0712-\\\\u072f\\\\u074d-\\\\u07a5\\\\u07b1\\\\u07ca-\\\\u07ea\\\\u07f4\\\\u07f5\\\\u07fa\\\\u0800-\\\\u0815\\\\u081a\\\\u0824\\\\u0828\\\\u0840-\\\\u0858\\\\u08a0\\\\u08a2-\\\\u08ac\\\\u0904-\\\\u0939\\\\u093d\\\\u0950\\\\u0958-\\\\u0961\\\\u0971-\\\\u0977\\\\u0979-\\\\u097f\\\\u0985-\\\\u098c\\\\u098f\\\\u0990\\\\u0993-\\\\u09a8\\\\u09aa-\\\\u09b0\\\\u09b2\\\\u09b6-\\\\u09b9\\\\u09bd\\\\u09ce\\\\u09dc\\\\u09dd\\\\u09df-\\\\u09e1\\\\u09f0\\\\u09f1\\\\u0a05-\\\\u0a0a\\\\u0a0f\\\\u0a10\\\\u0a13-\\\\u0a28\\\\u0a2a-\\\\u0a30\\\\u0a32\\\\u0a33\\\\u0a35\\\\u0a36\\\\u0a38\\\\u0a39\\\\u0a59-\\\\u0a5c\\\\u0a5e\\\\u0a72-\\\\u0a74\\\\u0a85-\\\\u0a8d\\\\u0a8f-\\\\u0a91\\\\u0a93-\\\\u0aa8\\\\u0aaa-\\\\u0ab0\\\\u0ab2\\\\u0ab3\\\\u0ab5-\\\\u0ab9\\\\u0abd\\\\u0ad0\\\\u0ae0\\\\u0ae1\\\\u0b05-\\\\u0b0c\\\\u0b0f\\\\u0b10\\\\u0b13-\\\\u0b28\\\\u0b2a-\\\\u0b30\\\\u0b32\\\\u0b33\\\\u0b35-\\\\u0b39\\\\u0b3d\\\\u0b5c\\\\u0b5d\\\\u0b5f-\\\\u0b61\\\\u0b71\\\\u0b83\\\\u0b85-\\\\u0b8a\\\\u0b8e-\\\\u0b90\\\\u0b92-\\\\u0b95\\\\u0b99\\\\u0b9a\\\\u0b9c\\\\u0b9e\\\\u0b9f\\\\u0ba3\\\\u0ba4\\\\u0ba8-\\\\u0baa\\\\u0bae-\\\\u0bb9\\\\u0bd0\\\\u0c05-\\\\u0c0c\\\\u0c0e-\\\\u0c10\\\\u0c12-\\\\u0c28\\\\u0c2a-\\\\u0c33\\\\u0c35-\\\\u0c39\\\\u0c3d\\\\u0c58\\\\u0c59\\\\u0c60\\\\u0c61\\\\u0c85-\\\\u0c8c\\\\u0c8e-\\\\u0c90\\\\u0c92-\\\\u0ca8\\\\u0caa-\\\\u0cb3\\\\u0cb5-\\\\u0cb9\\\\u0cbd\\\\u0cde\\\\u0ce0\\\\u0ce1\\\\u0cf1\\\\u0cf2\\\\u0d05-\\\\u0d0c\\\\u0d0e-\\\\u0d10\\\\u0d12-\\\\u0d3a\\\\u0d3d\\\\u0d4e\\\\u0d60\\\\u0d61\\\\u0d7a-\\\\u0d7f\\\\u0d85-\\\\u0d96\\\\u0d9a-\\\\u0db1\\\\u0db3-\\\\u0dbb\\\\u0dbd\\\\u0dc0-\\\\u0dc6\\\\u0e01-\\\\u0e30\\\\u0e32\\\\u0e33\\\\u0e40-\\\\u0e46\\\\u0e81\\\\u0e82\\\\u0e84\\\\u0e87\\\\u0e88\\\\u0e8a\\\\u0e8d\\\\u0e94-\\\\u0e97\\\\u0e99-\\\\u0e9f\\\\u0ea1-\\\\u0ea3\\\\u0ea5\\\\u0ea7\\\\u0eaa\\\\u0eab\\\\u0ead-\\\\u0eb0\\\\u0eb2\\\\u0eb3\\\\u0ebd\\\\u0ec0-\\\\u0ec4\\\\u0ec6\\\\u0edc-\\\\u0edf\\\\u0f00\\\\u0f40-\\\\u0f47\\\\u0f49-\\\\u0f6c\\\\u0f88-\\\\u0f8c\\\\u1000-\\\\u102a\\\\u103f\\\\u1050-\\\\u1055\\\\u105a-\\\\u105d\\\\u1061\\\\u1065\\\\u1066\\\\u106e-\\\\u1070\\\\u1075-\\\\u1081\\\\u108e\\\\u10a0-\\\\u10c5\\\\u10c7\\\\u10cd\\\\u10d0-\\\\u10fa\\\\u10fc-\\\\u1248\\\\u124a-\\\\u124d\\\\u1250-\\\\u1256\\\\u1258\\\\u125a-\\\\u125d\\\\u1260-\\\\u1288\\\\u128a-\\\\u128d\\\\u1290-\\\\u12b0\\\\u12b2-\\\\u12b5\\\\u12b8-\\\\u12be\\\\u12c0\\\\u12c2-\\\\u12c5\\\\u12c8-\\\\u12d6\\\\u12d8-\\\\u1310\\\\u1312-\\\\u1315\\\\u1318-\\\\u135a\\\\u1380-\\\\u138f\\\\u13a0-\\\\u13f4\\\\u1401-\\\\u166c\\\\u166f-\\\\u167f\\\\u1681-\\\\u169a\\\\u16a0-\\\\u16ea\\\\u16ee-\\\\u16f0\\\\u1700-\\\\u170c\\\\u170e-\\\\u1711\\\\u1720-\\\\u1731\\\\u1740-\\\\u1751\\\\u1760-\\\\u176c\\\\u176e-\\\\u1770\\\\u1780-\\\\u17b3\\\\u17d7\\\\u17dc\\\\u1820-\\\\u1877\\\\u1880-\\\\u18a8\\\\u18aa\\\\u18b0-\\\\u18f5\\\\u1900-\\\\u191c\\\\u1950-\\\\u196d\\\\u1970-\\\\u1974\\\\u1980-\\\\u19ab\\\\u19c1-\\\\u19c7\\\\u1a00-\\\\u1a16\\\\u1a20-\\\\u1a54\\\\u1aa7\\\\u1b05-\\\\u1b33\\\\u1b45-\\\\u1b4b\\\\u1b83-\\\\u1ba0\\\\u1bae\\\\u1baf\\\\u1bba-\\\\u1be5\\\\u1c00-\\\\u1c23\\\\u1c4d-\\\\u1c4f\\\\u1c5a-\\\\u1c7d\\\\u1ce9-\\\\u1cec\\\\u1cee-\\\\u1cf1\\\\u1cf5\\\\u1cf6\\\\u1d00-\\\\u1dbf\\\\u1e00-\\\\u1f15\\\\u1f18-\\\\u1f1d\\\\u1f20-\\\\u1f45\\\\u1f48-\\\\u1f4d\\\\u1f50-\\\\u1f57\\\\u1f59\\\\u1f5b\\\\u1f5d\\\\u1f5f-\\\\u1f7d\\\\u1f80-\\\\u1fb4\\\\u1fb6-\\\\u1fbc\\\\u1fbe\\\\u1fc2-\\\\u1fc4\\\\u1fc6-\\\\u1fcc\\\\u1fd0-\\\\u1fd3\\\\u1fd6-\\\\u1fdb\\\\u1fe0-\\\\u1fec\\\\u1ff2-\\\\u1ff4\\\\u1ff6-\\\\u1ffc\\\\u2071\\\\u207f\\\\u2090-\\\\u209c\\\\u2102\\\\u2107\\\\u210a-\\\\u2113\\\\u2115\\\\u2119-\\\\u211d\\\\u2124\\\\u2126\\\\u2128\\\\u212a-\\\\u212d\\\\u212f-\\\\u2139\\\\u213c-\\\\u213f\\\\u2145-\\\\u2149\\\\u214e\\\\u2160-\\\\u2188\\\\u2c00-\\\\u2c2e\\\\u2c30-\\\\u2c5e\\\\u2c60-\\\\u2ce4\\\\u2ceb-\\\\u2cee\\\\u2cf2\\\\u2cf3\\\\u2d00-\\\\u2d25\\\\u2d27\\\\u2d2d\\\\u2d30-\\\\u2d67\\\\u2d6f\\\\u2d80-\\\\u2d96\\\\u2da0-\\\\u2da6\\\\u2da8-\\\\u2dae\\\\u2db0-\\\\u2db6\\\\u2db8-\\\\u2dbe\\\\u2dc0-\\\\u2dc6\\\\u2dc8-\\\\u2dce\\\\u2dd0-\\\\u2dd6\\\\u2dd8-\\\\u2dde\\\\u2e2f\\\\u3005-\\\\u3007\\\\u3021-\\\\u3029\\\\u3031-\\\\u3035\\\\u3038-\\\\u303c\\\\u3041-\\\\u3096\\\\u309d-\\\\u309f\\\\u30a1-\\\\u30fa\\\\u30fc-\\\\u30ff\\\\u3105-\\\\u312d\\\\u3131-\\\\u318e\\\\u31a0-\\\\u31ba\\\\u31f0-\\\\u31ff\\\\u3400-\\\\u4db5\\\\u4e00-\\\\u9fcc\\\\ua000-\\\\ua48c\\\\ua4d0-\\\\ua4fd\\\\ua500-\\\\ua60c\\\\ua610-\\\\ua61f\\\\ua62a\\\\ua62b\\\\ua640-\\\\ua66e\\\\ua67f-\\\\ua697\\\\ua6a0-\\\\ua6ef\\\\ua717-\\\\ua71f\\\\ua722-\\\\ua788\\\\ua78b-\\\\ua78e\\\\ua790-\\\\ua793\\\\ua7a0-\\\\ua7aa\\\\ua7f8-\\\\ua801\\\\ua803-\\\\ua805\\\\ua807-\\\\ua80a\\\\ua80c-\\\\ua822\\\\ua840-\\\\ua873\\\\ua882-\\\\ua8b3\\\\ua8f2-\\\\ua8f7\\\\ua8fb\\\\ua90a-\\\\ua925\\\\ua930-\\\\ua946\\\\ua960-\\\\ua97c\\\\ua984-\\\\ua9b2\\\\ua9cf\\\\uaa00-\\\\uaa28\\\\uaa40-\\\\uaa42\\\\uaa44-\\\\uaa4b\\\\uaa60-\\\\uaa76\\\\uaa7a\\\\uaa80-\\\\uaaaf\\\\uaab1\\\\uaab5\\\\uaab6\\\\uaab9-\\\\uaabd\\\\uaac0\\\\uaac2\\\\uaadb-\\\\uaadd\\\\uaae0-\\\\uaaea\\\\uaaf2-\\\\uaaf4\\\\uab01-\\\\uab06\\\\uab09-\\\\uab0e\\\\uab11-\\\\uab16\\\\uab20-\\\\uab26\\\\uab28-\\\\uab2e\\\\uabc0-\\\\uabe2\\\\uac00-\\\\ud7a3\\\\ud7b0-\\\\ud7c6\\\\ud7cb-\\\\ud7fb\\\\uf900-\\\\ufa6d\\\\ufa70-\\\\ufad9\\\\ufb00-\\\\ufb06\\\\ufb13-\\\\ufb17\\\\ufb1d\\\\ufb1f-\\\\ufb28\\\\ufb2a-\\\\ufb36\\\\ufb38-\\\\ufb3c\\\\ufb3e\\\\ufb40\\\\ufb41\\\\ufb43\\\\ufb44\\\\ufb46-\\\\ufbb1\\\\ufbd3-\\\\ufd3d\\\\ufd50-\\\\ufd8f\\\\ufd92-\\\\ufdc7\\\\ufdf0-\\\\ufdfb\\\\ufe70-\\\\ufe74\\\\ufe76-\\\\ufefc\\\\uff21-\\\\uff3a\\\\uff41-\\\\uff5a\\\\uff66-\\\\uffbe\\\\uffc2-\\\\uffc7\\\\uffca-\\\\uffcf\\\\uffd2-\\\\uffd7\\\\uffda-\\\\uffdc\";\n                var nonASCIIidentifierChars = \"\\\\u0300-\\\\u036f\\\\u0483-\\\\u0487\\\\u0591-\\\\u05bd\\\\u05bf\\\\u05c1\\\\u05c2\\\\u05c4\\\\u05c5\\\\u05c7\\\\u0610-\\\\u061a\\\\u0620-\\\\u0649\\\\u0672-\\\\u06d3\\\\u06e7-\\\\u06e8\\\\u06fb-\\\\u06fc\\\\u0730-\\\\u074a\\\\u0800-\\\\u0814\\\\u081b-\\\\u0823\\\\u0825-\\\\u0827\\\\u0829-\\\\u082d\\\\u0840-\\\\u0857\\\\u08e4-\\\\u08fe\\\\u0900-\\\\u0903\\\\u093a-\\\\u093c\\\\u093e-\\\\u094f\\\\u0951-\\\\u0957\\\\u0962-\\\\u0963\\\\u0966-\\\\u096f\\\\u0981-\\\\u0983\\\\u09bc\\\\u09be-\\\\u09c4\\\\u09c7\\\\u09c8\\\\u09d7\\\\u09df-\\\\u09e0\\\\u0a01-\\\\u0a03\\\\u0a3c\\\\u0a3e-\\\\u0a42\\\\u0a47\\\\u0a48\\\\u0a4b-\\\\u0a4d\\\\u0a51\\\\u0a66-\\\\u0a71\\\\u0a75\\\\u0a81-\\\\u0a83\\\\u0abc\\\\u0abe-\\\\u0ac5\\\\u0ac7-\\\\u0ac9\\\\u0acb-\\\\u0acd\\\\u0ae2-\\\\u0ae3\\\\u0ae6-\\\\u0aef\\\\u0b01-\\\\u0b03\\\\u0b3c\\\\u0b3e-\\\\u0b44\\\\u0b47\\\\u0b48\\\\u0b4b-\\\\u0b4d\\\\u0b56\\\\u0b57\\\\u0b5f-\\\\u0b60\\\\u0b66-\\\\u0b6f\\\\u0b82\\\\u0bbe-\\\\u0bc2\\\\u0bc6-\\\\u0bc8\\\\u0bca-\\\\u0bcd\\\\u0bd7\\\\u0be6-\\\\u0bef\\\\u0c01-\\\\u0c03\\\\u0c46-\\\\u0c48\\\\u0c4a-\\\\u0c4d\\\\u0c55\\\\u0c56\\\\u0c62-\\\\u0c63\\\\u0c66-\\\\u0c6f\\\\u0c82\\\\u0c83\\\\u0cbc\\\\u0cbe-\\\\u0cc4\\\\u0cc6-\\\\u0cc8\\\\u0cca-\\\\u0ccd\\\\u0cd5\\\\u0cd6\\\\u0ce2-\\\\u0ce3\\\\u0ce6-\\\\u0cef\\\\u0d02\\\\u0d03\\\\u0d46-\\\\u0d48\\\\u0d57\\\\u0d62-\\\\u0d63\\\\u0d66-\\\\u0d6f\\\\u0d82\\\\u0d83\\\\u0dca\\\\u0dcf-\\\\u0dd4\\\\u0dd6\\\\u0dd8-\\\\u0ddf\\\\u0df2\\\\u0df3\\\\u0e34-\\\\u0e3a\\\\u0e40-\\\\u0e45\\\\u0e50-\\\\u0e59\\\\u0eb4-\\\\u0eb9\\\\u0ec8-\\\\u0ecd\\\\u0ed0-\\\\u0ed9\\\\u0f18\\\\u0f19\\\\u0f20-\\\\u0f29\\\\u0f35\\\\u0f37\\\\u0f39\\\\u0f41-\\\\u0f47\\\\u0f71-\\\\u0f84\\\\u0f86-\\\\u0f87\\\\u0f8d-\\\\u0f97\\\\u0f99-\\\\u0fbc\\\\u0fc6\\\\u1000-\\\\u1029\\\\u1040-\\\\u1049\\\\u1067-\\\\u106d\\\\u1071-\\\\u1074\\\\u1082-\\\\u108d\\\\u108f-\\\\u109d\\\\u135d-\\\\u135f\\\\u170e-\\\\u1710\\\\u1720-\\\\u1730\\\\u1740-\\\\u1750\\\\u1772\\\\u1773\\\\u1780-\\\\u17b2\\\\u17dd\\\\u17e0-\\\\u17e9\\\\u180b-\\\\u180d\\\\u1810-\\\\u1819\\\\u1920-\\\\u192b\\\\u1930-\\\\u193b\\\\u1951-\\\\u196d\\\\u19b0-\\\\u19c0\\\\u19c8-\\\\u19c9\\\\u19d0-\\\\u19d9\\\\u1a00-\\\\u1a15\\\\u1a20-\\\\u1a53\\\\u1a60-\\\\u1a7c\\\\u1a7f-\\\\u1a89\\\\u1a90-\\\\u1a99\\\\u1b46-\\\\u1b4b\\\\u1b50-\\\\u1b59\\\\u1b6b-\\\\u1b73\\\\u1bb0-\\\\u1bb9\\\\u1be6-\\\\u1bf3\\\\u1c00-\\\\u1c22\\\\u1c40-\\\\u1c49\\\\u1c5b-\\\\u1c7d\\\\u1cd0-\\\\u1cd2\\\\u1d00-\\\\u1dbe\\\\u1e01-\\\\u1f15\\\\u200c\\\\u200d\\\\u203f\\\\u2040\\\\u2054\\\\u20d0-\\\\u20dc\\\\u20e1\\\\u20e5-\\\\u20f0\\\\u2d81-\\\\u2d96\\\\u2de0-\\\\u2dff\\\\u3021-\\\\u3028\\\\u3099\\\\u309a\\\\ua640-\\\\ua66d\\\\ua674-\\\\ua67d\\\\ua69f\\\\ua6f0-\\\\ua6f1\\\\ua7f8-\\\\ua800\\\\ua806\\\\ua80b\\\\ua823-\\\\ua827\\\\ua880-\\\\ua881\\\\ua8b4-\\\\ua8c4\\\\ua8d0-\\\\ua8d9\\\\ua8f3-\\\\ua8f7\\\\ua900-\\\\ua909\\\\ua926-\\\\ua92d\\\\ua930-\\\\ua945\\\\ua980-\\\\ua983\\\\ua9b3-\\\\ua9c0\\\\uaa00-\\\\uaa27\\\\uaa40-\\\\uaa41\\\\uaa4c-\\\\uaa4d\\\\uaa50-\\\\uaa59\\\\uaa7b\\\\uaae0-\\\\uaae9\\\\uaaf2-\\\\uaaf3\\\\uabc0-\\\\uabe1\\\\uabec\\\\uabed\\\\uabf0-\\\\uabf9\\\\ufb20-\\\\ufb28\\\\ufe00-\\\\ufe0f\\\\ufe20-\\\\ufe26\\\\ufe33\\\\ufe34\\\\ufe4d-\\\\ufe4f\\\\uff10-\\\\uff19\\\\uff3f\";\n                //var nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\n                //var nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n                var unicodeEscapeOrCodePoint = \"\\\\\\\\u[0-9a-fA-F]{4}|\\\\\\\\u\\\\{[0-9a-fA-F]+\\\\}\";\n                var identifierStart = \"(?:\" + unicodeEscapeOrCodePoint + \"|[\" + baseASCIIidentifierStartChars + nonASCIIidentifierStartChars + \"])\";\n                var identifierChars = \"(?:\" + unicodeEscapeOrCodePoint + \"|[\" + baseASCIIidentifierChars + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"])*\";\n                exports1.identifier = new RegExp(identifierStart + identifierChars, \"g\");\n                exports1.identifierStart = new RegExp(identifierStart);\n                exports1.identifierMatch = new RegExp(\"(?:\" + unicodeEscapeOrCodePoint + \"|[\" + baseASCIIidentifierChars + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"])+\");\n                var nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/; // jshint ignore:line\n                // Whether a single character denotes a newline.\n                exports1.newline = /[\\n\\r\\u2028\\u2029]/;\n                // Matches a whole line break (where CRLF is considered a single\n                // line break). Used to count lines.\n                // in javascript, these two differ\n                // in python they are the same, different methods are called on them\n                exports1.lineBreak = new RegExp(\"\\r\\n|\" + exports1.newline.source);\n                exports1.allLineBreaks = new RegExp(exports1.lineBreak.source, \"g\");\n            /***/ },\n            /* 5 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_122906__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var BaseOptions = __nested_webpack_require_122906__(6).Options;\n                var validPositionValues = [\n                    \"before-newline\",\n                    \"after-newline\",\n                    \"preserve-newline\"\n                ];\n                function Options(options) {\n                    BaseOptions.call(this, options, \"js\");\n                    // compatibility, re\n                    var raw_brace_style = this.raw_options.brace_style || null;\n                    if (raw_brace_style === \"expand-strict\") {\n                        this.raw_options.brace_style = \"expand\";\n                    } else if (raw_brace_style === \"collapse-preserve-inline\") {\n                        this.raw_options.brace_style = \"collapse,preserve-inline\";\n                    } else if (this.raw_options.braces_on_own_line !== undefined) {\n                        this.raw_options.brace_style = this.raw_options.braces_on_own_line ? \"expand\" : \"collapse\";\n                    // } else if (!raw_brace_style) { //Nothing exists to set it\n                    //   raw_brace_style = \"collapse\";\n                    }\n                    //preserve-inline in delimited string will trigger brace_preserve_inline, everything\n                    //else is considered a brace_style and the last one only will have an effect\n                    var brace_style_split = this._get_selection_list(\"brace_style\", [\n                        \"collapse\",\n                        \"expand\",\n                        \"end-expand\",\n                        \"none\",\n                        \"preserve-inline\"\n                    ]);\n                    this.brace_preserve_inline = false; //Defaults in case one or other was not specified in meta-option\n                    this.brace_style = \"collapse\";\n                    for(var bs = 0; bs < brace_style_split.length; bs++){\n                        if (brace_style_split[bs] === \"preserve-inline\") {\n                            this.brace_preserve_inline = true;\n                        } else {\n                            this.brace_style = brace_style_split[bs];\n                        }\n                    }\n                    this.unindent_chained_methods = this._get_boolean(\"unindent_chained_methods\");\n                    this.break_chained_methods = this._get_boolean(\"break_chained_methods\");\n                    this.space_in_paren = this._get_boolean(\"space_in_paren\");\n                    this.space_in_empty_paren = this._get_boolean(\"space_in_empty_paren\");\n                    this.jslint_happy = this._get_boolean(\"jslint_happy\");\n                    this.space_after_anon_function = this._get_boolean(\"space_after_anon_function\");\n                    this.space_after_named_function = this._get_boolean(\"space_after_named_function\");\n                    this.keep_array_indentation = this._get_boolean(\"keep_array_indentation\");\n                    this.space_before_conditional = this._get_boolean(\"space_before_conditional\", true);\n                    this.unescape_strings = this._get_boolean(\"unescape_strings\");\n                    this.e4x = this._get_boolean(\"e4x\");\n                    this.comma_first = this._get_boolean(\"comma_first\");\n                    this.operator_position = this._get_selection(\"operator_position\", validPositionValues);\n                    // For testing of beautify preserve:start directive\n                    this.test_output_raw = this._get_boolean(\"test_output_raw\");\n                    // force this._options.space_after_anon_function to true if this._options.jslint_happy\n                    if (this.jslint_happy) {\n                        this.space_after_anon_function = true;\n                    }\n                }\n                Options.prototype = new BaseOptions();\n                module.exports.Options = Options;\n            /***/ },\n            /* 6 */ /***/ function(module) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ function Options(options, merge_child_field) {\n                    this.raw_options = _mergeOpts(options, merge_child_field);\n                    // Support passing the source text back with no change\n                    this.disabled = this._get_boolean(\"disabled\");\n                    this.eol = this._get_characters(\"eol\", \"auto\");\n                    this.end_with_newline = this._get_boolean(\"end_with_newline\");\n                    this.indent_size = this._get_number(\"indent_size\", 4);\n                    this.indent_char = this._get_characters(\"indent_char\", \" \");\n                    this.indent_level = this._get_number(\"indent_level\");\n                    this.preserve_newlines = this._get_boolean(\"preserve_newlines\", true);\n                    this.max_preserve_newlines = this._get_number(\"max_preserve_newlines\", 32786);\n                    if (!this.preserve_newlines) {\n                        this.max_preserve_newlines = 0;\n                    }\n                    this.indent_with_tabs = this._get_boolean(\"indent_with_tabs\", this.indent_char === \"\t\");\n                    if (this.indent_with_tabs) {\n                        this.indent_char = \"\t\";\n                        // indent_size behavior changed after 1.8.6\n                        // It used to be that indent_size would be\n                        // set to 1 for indent_with_tabs. That is no longer needed and\n                        // actually doesn't make sense - why not use spaces? Further,\n                        // that might produce unexpected behavior - tabs being used\n                        // for single-column alignment. So, when indent_with_tabs is true\n                        // and indent_size is 1, reset indent_size to 4.\n                        if (this.indent_size === 1) {\n                            this.indent_size = 4;\n                        }\n                    }\n                    // Backwards compat with 1.3.x\n                    this.wrap_line_length = this._get_number(\"wrap_line_length\", this._get_number(\"max_char\"));\n                    this.indent_empty_lines = this._get_boolean(\"indent_empty_lines\");\n                    // valid templating languages ['django', 'erb', 'handlebars', 'php', 'smarty', 'angular']\n                    // For now, 'auto' = all off for javascript, all except angular on for html (and inline javascript/css).\n                    // other values ignored\n                    this.templating = this._get_selection_list(\"templating\", [\n                        \"auto\",\n                        \"none\",\n                        \"angular\",\n                        \"django\",\n                        \"erb\",\n                        \"handlebars\",\n                        \"php\",\n                        \"smarty\"\n                    ], [\n                        \"auto\"\n                    ]);\n                }\n                Options.prototype._get_array = function(name, default_value) {\n                    var option_value = this.raw_options[name];\n                    var result = default_value || [];\n                    if (typeof option_value === \"object\") {\n                        if (option_value !== null && typeof option_value.concat === \"function\") {\n                            result = option_value.concat();\n                        }\n                    } else if (typeof option_value === \"string\") {\n                        result = option_value.split(/[^a-zA-Z0-9_\\/\\-]+/);\n                    }\n                    return result;\n                };\n                Options.prototype._get_boolean = function(name, default_value) {\n                    var option_value = this.raw_options[name];\n                    var result = option_value === undefined ? !!default_value : !!option_value;\n                    return result;\n                };\n                Options.prototype._get_characters = function(name, default_value) {\n                    var option_value = this.raw_options[name];\n                    var result = default_value || \"\";\n                    if (typeof option_value === \"string\") {\n                        result = option_value.replace(/\\\\r/, \"\\r\").replace(/\\\\n/, \"\\n\").replace(/\\\\t/, \"\t\");\n                    }\n                    return result;\n                };\n                Options.prototype._get_number = function(name, default_value) {\n                    var option_value = this.raw_options[name];\n                    default_value = parseInt(default_value, 10);\n                    if (isNaN(default_value)) {\n                        default_value = 0;\n                    }\n                    var result = parseInt(option_value, 10);\n                    if (isNaN(result)) {\n                        result = default_value;\n                    }\n                    return result;\n                };\n                Options.prototype._get_selection = function(name, selection_list, default_value) {\n                    var result = this._get_selection_list(name, selection_list, default_value);\n                    if (result.length !== 1) {\n                        throw new Error(\"Invalid Option Value: The option '\" + name + \"' can only be one of the following values:\\n\" + selection_list + \"\\nYou passed in: '\" + this.raw_options[name] + \"'\");\n                    }\n                    return result[0];\n                };\n                Options.prototype._get_selection_list = function(name, selection_list, default_value) {\n                    if (!selection_list || selection_list.length === 0) {\n                        throw new Error(\"Selection list cannot be empty.\");\n                    }\n                    default_value = default_value || [\n                        selection_list[0]\n                    ];\n                    if (!this._is_valid_selection(default_value, selection_list)) {\n                        throw new Error(\"Invalid Default Value!\");\n                    }\n                    var result = this._get_array(name, default_value);\n                    if (!this._is_valid_selection(result, selection_list)) {\n                        throw new Error(\"Invalid Option Value: The option '\" + name + \"' can contain only the following values:\\n\" + selection_list + \"\\nYou passed in: '\" + this.raw_options[name] + \"'\");\n                    }\n                    return result;\n                };\n                Options.prototype._is_valid_selection = function(result, selection_list) {\n                    return result.length && selection_list.length && !result.some(function(item) {\n                        return selection_list.indexOf(item) === -1;\n                    });\n                };\n                // merges child options up with the parent options object\n                // Example: obj = {a: 1, b: {a: 2}}\n                //          mergeOpts(obj, 'b')\n                //\n                //          Returns: {a: 2}\n                function _mergeOpts(allOptions, childFieldName) {\n                    var finalOpts = {};\n                    allOptions = _normalizeOpts(allOptions);\n                    var name;\n                    for(name in allOptions){\n                        if (name !== childFieldName) {\n                            finalOpts[name] = allOptions[name];\n                        }\n                    }\n                    //merge in the per type settings for the childFieldName\n                    if (childFieldName && allOptions[childFieldName]) {\n                        for(name in allOptions[childFieldName]){\n                            finalOpts[name] = allOptions[childFieldName][name];\n                        }\n                    }\n                    return finalOpts;\n                }\n                function _normalizeOpts(options) {\n                    var convertedOpts = {};\n                    var key;\n                    for(key in options){\n                        var newKey = key.replace(/-/g, \"_\");\n                        convertedOpts[newKey] = options[key];\n                    }\n                    return convertedOpts;\n                }\n                module.exports.Options = Options;\n                module.exports.normalizeOpts = _normalizeOpts;\n                module.exports.mergeOpts = _mergeOpts;\n            /***/ },\n            /* 7 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_137498__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var InputScanner = __nested_webpack_require_137498__(8).InputScanner;\n                var BaseTokenizer = __nested_webpack_require_137498__(9).Tokenizer;\n                var BASETOKEN = __nested_webpack_require_137498__(9).TOKEN;\n                var Directives = __nested_webpack_require_137498__(13).Directives;\n                var acorn = __nested_webpack_require_137498__(4);\n                var Pattern = __nested_webpack_require_137498__(12).Pattern;\n                var TemplatablePattern = __nested_webpack_require_137498__(14).TemplatablePattern;\n                function in_array(what, arr) {\n                    return arr.indexOf(what) !== -1;\n                }\n                var TOKEN = {\n                    START_EXPR: \"TK_START_EXPR\",\n                    END_EXPR: \"TK_END_EXPR\",\n                    START_BLOCK: \"TK_START_BLOCK\",\n                    END_BLOCK: \"TK_END_BLOCK\",\n                    WORD: \"TK_WORD\",\n                    RESERVED: \"TK_RESERVED\",\n                    SEMICOLON: \"TK_SEMICOLON\",\n                    STRING: \"TK_STRING\",\n                    EQUALS: \"TK_EQUALS\",\n                    OPERATOR: \"TK_OPERATOR\",\n                    COMMA: \"TK_COMMA\",\n                    BLOCK_COMMENT: \"TK_BLOCK_COMMENT\",\n                    COMMENT: \"TK_COMMENT\",\n                    DOT: \"TK_DOT\",\n                    UNKNOWN: \"TK_UNKNOWN\",\n                    START: BASETOKEN.START,\n                    RAW: BASETOKEN.RAW,\n                    EOF: BASETOKEN.EOF\n                };\n                var directives_core = new Directives(/\\/\\*/, /\\*\\//);\n                var number_pattern = /0[xX][0123456789abcdefABCDEF_]*n?|0[oO][01234567_]*n?|0[bB][01_]*n?|\\d[\\d_]*n|(?:\\.\\d[\\d_]*|\\d[\\d_]*\\.?[\\d_]*)(?:[eE][+-]?[\\d_]+)?/;\n                var digit = /[0-9]/;\n                // Dot \".\" must be distinguished from \"...\" and decimal\n                var dot_pattern = /[^\\d\\.]/;\n                var positionable_operators = (\">>> === !== &&= ??= ||= \" + \"<< && >= ** != == <= >> || ?? |> \" + \"< / - + > : & % ? ^ | *\").split(\" \");\n                // IMPORTANT: this must be sorted longest to shortest or tokenizing many not work.\n                // Also, you must update possitionable operators separately from punct\n                var punct = \">>>= \" + \"... >>= <<= === >>> !== **= &&= ??= ||= \" + \"=> ^= :: /= << <= == && -= >= >> != -- += ** || ?? ++ %= &= *= |= |> \" + \"= ! ? > < : / ^ - + * & % ~ |\";\n                punct = punct.replace(/[-[\\]{}()*+?.,\\\\^$|#]/g, \"\\\\$&\");\n                // ?. but not if followed by a number \n                punct = \"\\\\?\\\\.(?!\\\\d) \" + punct;\n                punct = punct.replace(/ /g, \"|\");\n                var punct_pattern = new RegExp(punct);\n                // words which should always start on new line.\n                var line_starters = \"continue,try,throw,return,var,let,const,if,switch,case,default,for,while,break,function,import,export\".split(\",\");\n                var reserved_words = line_starters.concat([\n                    \"do\",\n                    \"in\",\n                    \"of\",\n                    \"else\",\n                    \"get\",\n                    \"set\",\n                    \"new\",\n                    \"catch\",\n                    \"finally\",\n                    \"typeof\",\n                    \"yield\",\n                    \"async\",\n                    \"await\",\n                    \"from\",\n                    \"as\",\n                    \"class\",\n                    \"extends\"\n                ]);\n                var reserved_word_pattern = new RegExp(\"^(?:\" + reserved_words.join(\"|\") + \")$\");\n                // var template_pattern = /(?:(?:<\\?php|<\\?=)[\\s\\S]*?\\?>)|(?:<%[\\s\\S]*?%>)/g;\n                var in_html_comment;\n                var Tokenizer = function(input_string, options) {\n                    BaseTokenizer.call(this, input_string, options);\n                    this._patterns.whitespace = this._patterns.whitespace.matching(/\\u00A0\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff/.source, /\\u2028\\u2029/.source);\n                    var pattern_reader = new Pattern(this._input);\n                    var templatable = new TemplatablePattern(this._input).read_options(this._options);\n                    this.__patterns = {\n                        template: templatable,\n                        identifier: templatable.starting_with(acorn.identifier).matching(acorn.identifierMatch),\n                        number: pattern_reader.matching(number_pattern),\n                        punct: pattern_reader.matching(punct_pattern),\n                        // comment ends just before nearest linefeed or end of file\n                        comment: pattern_reader.starting_with(/\\/\\//).until(/[\\n\\r\\u2028\\u2029]/),\n                        //  /* ... */ comment ends with nearest */ or end of file\n                        block_comment: pattern_reader.starting_with(/\\/\\*/).until_after(/\\*\\//),\n                        html_comment_start: pattern_reader.matching(/<!--/),\n                        html_comment_end: pattern_reader.matching(/-->/),\n                        include: pattern_reader.starting_with(/#include/).until_after(acorn.lineBreak),\n                        shebang: pattern_reader.starting_with(/#!/).until_after(acorn.lineBreak),\n                        xml: pattern_reader.matching(/[\\s\\S]*?<(\\/?)([-a-zA-Z:0-9_.]+|{[^}]+?}|!\\[CDATA\\[[^\\]]*?\\]\\]|)(\\s*{[^}]+?}|\\s+[-a-zA-Z:0-9_.]+|\\s+[-a-zA-Z:0-9_.]+\\s*=\\s*('[^']*'|\"[^\"]*\"|{([^{}]|{[^}]+?})+?}))*\\s*(\\/?)\\s*>/),\n                        single_quote: templatable.until(/['\\\\\\n\\r\\u2028\\u2029]/),\n                        double_quote: templatable.until(/[\"\\\\\\n\\r\\u2028\\u2029]/),\n                        template_text: templatable.until(/[`\\\\$]/),\n                        template_expression: templatable.until(/[`}\\\\]/)\n                    };\n                };\n                Tokenizer.prototype = new BaseTokenizer();\n                Tokenizer.prototype._is_comment = function(current_token) {\n                    return current_token.type === TOKEN.COMMENT || current_token.type === TOKEN.BLOCK_COMMENT || current_token.type === TOKEN.UNKNOWN;\n                };\n                Tokenizer.prototype._is_opening = function(current_token) {\n                    return current_token.type === TOKEN.START_BLOCK || current_token.type === TOKEN.START_EXPR;\n                };\n                Tokenizer.prototype._is_closing = function(current_token, open_token) {\n                    return (current_token.type === TOKEN.END_BLOCK || current_token.type === TOKEN.END_EXPR) && open_token && (current_token.text === \"]\" && open_token.text === \"[\" || current_token.text === \")\" && open_token.text === \"(\" || current_token.text === \"}\" && open_token.text === \"{\");\n                };\n                Tokenizer.prototype._reset = function() {\n                    in_html_comment = false;\n                };\n                Tokenizer.prototype._get_next_token = function(previous_token, open_token) {\n                    var token = null;\n                    this._readWhitespace();\n                    var c = this._input.peek();\n                    if (c === null) {\n                        return this._create_token(TOKEN.EOF, \"\");\n                    }\n                    token = token || this._read_non_javascript(c);\n                    token = token || this._read_string(c);\n                    token = token || this._read_pair(c, this._input.peek(1)); // Issue #2062 hack for record type '#{'\n                    token = token || this._read_word(previous_token);\n                    token = token || this._read_singles(c);\n                    token = token || this._read_comment(c);\n                    token = token || this._read_regexp(c, previous_token);\n                    token = token || this._read_xml(c, previous_token);\n                    token = token || this._read_punctuation();\n                    token = token || this._create_token(TOKEN.UNKNOWN, this._input.next());\n                    return token;\n                };\n                Tokenizer.prototype._read_word = function(previous_token) {\n                    var resulting_string;\n                    resulting_string = this.__patterns.identifier.read();\n                    if (resulting_string !== \"\") {\n                        resulting_string = resulting_string.replace(acorn.allLineBreaks, \"\\n\");\n                        if (!(previous_token.type === TOKEN.DOT || previous_token.type === TOKEN.RESERVED && (previous_token.text === \"set\" || previous_token.text === \"get\")) && reserved_word_pattern.test(resulting_string)) {\n                            if ((resulting_string === \"in\" || resulting_string === \"of\") && (previous_token.type === TOKEN.WORD || previous_token.type === TOKEN.STRING)) {\n                                return this._create_token(TOKEN.OPERATOR, resulting_string);\n                            }\n                            return this._create_token(TOKEN.RESERVED, resulting_string);\n                        }\n                        return this._create_token(TOKEN.WORD, resulting_string);\n                    }\n                    resulting_string = this.__patterns.number.read();\n                    if (resulting_string !== \"\") {\n                        return this._create_token(TOKEN.WORD, resulting_string);\n                    }\n                };\n                Tokenizer.prototype._read_singles = function(c) {\n                    var token = null;\n                    if (c === \"(\" || c === \"[\") {\n                        token = this._create_token(TOKEN.START_EXPR, c);\n                    } else if (c === \")\" || c === \"]\") {\n                        token = this._create_token(TOKEN.END_EXPR, c);\n                    } else if (c === \"{\") {\n                        token = this._create_token(TOKEN.START_BLOCK, c);\n                    } else if (c === \"}\") {\n                        token = this._create_token(TOKEN.END_BLOCK, c);\n                    } else if (c === \";\") {\n                        token = this._create_token(TOKEN.SEMICOLON, c);\n                    } else if (c === \".\" && dot_pattern.test(this._input.peek(1))) {\n                        token = this._create_token(TOKEN.DOT, c);\n                    } else if (c === \",\") {\n                        token = this._create_token(TOKEN.COMMA, c);\n                    }\n                    if (token) {\n                        this._input.next();\n                    }\n                    return token;\n                };\n                Tokenizer.prototype._read_pair = function(c, d) {\n                    var token = null;\n                    if (c === \"#\" && d === \"{\") {\n                        token = this._create_token(TOKEN.START_BLOCK, c + d);\n                    }\n                    if (token) {\n                        this._input.next();\n                        this._input.next();\n                    }\n                    return token;\n                };\n                Tokenizer.prototype._read_punctuation = function() {\n                    var resulting_string = this.__patterns.punct.read();\n                    if (resulting_string !== \"\") {\n                        if (resulting_string === \"=\") {\n                            return this._create_token(TOKEN.EQUALS, resulting_string);\n                        } else if (resulting_string === \"?.\") {\n                            return this._create_token(TOKEN.DOT, resulting_string);\n                        } else {\n                            return this._create_token(TOKEN.OPERATOR, resulting_string);\n                        }\n                    }\n                };\n                Tokenizer.prototype._read_non_javascript = function(c) {\n                    var resulting_string = \"\";\n                    if (c === \"#\") {\n                        if (this._is_first_token()) {\n                            resulting_string = this.__patterns.shebang.read();\n                            if (resulting_string) {\n                                return this._create_token(TOKEN.UNKNOWN, resulting_string.trim() + \"\\n\");\n                            }\n                        }\n                        // handles extendscript #includes\n                        resulting_string = this.__patterns.include.read();\n                        if (resulting_string) {\n                            return this._create_token(TOKEN.UNKNOWN, resulting_string.trim() + \"\\n\");\n                        }\n                        c = this._input.next();\n                        // Spidermonkey-specific sharp variables for circular references. Considered obsolete.\n                        var sharp = \"#\";\n                        if (this._input.hasNext() && this._input.testChar(digit)) {\n                            do {\n                                c = this._input.next();\n                                sharp += c;\n                            }while (this._input.hasNext() && c !== \"#\" && c !== \"=\");\n                            if (c === \"#\") {\n                            //\n                            } else if (this._input.peek() === \"[\" && this._input.peek(1) === \"]\") {\n                                sharp += \"[]\";\n                                this._input.next();\n                                this._input.next();\n                            } else if (this._input.peek() === \"{\" && this._input.peek(1) === \"}\") {\n                                sharp += \"{}\";\n                                this._input.next();\n                                this._input.next();\n                            }\n                            return this._create_token(TOKEN.WORD, sharp);\n                        }\n                        this._input.back();\n                    } else if (c === \"<\" && this._is_first_token()) {\n                        resulting_string = this.__patterns.html_comment_start.read();\n                        if (resulting_string) {\n                            while(this._input.hasNext() && !this._input.testChar(acorn.newline)){\n                                resulting_string += this._input.next();\n                            }\n                            in_html_comment = true;\n                            return this._create_token(TOKEN.COMMENT, resulting_string);\n                        }\n                    } else if (in_html_comment && c === \"-\") {\n                        resulting_string = this.__patterns.html_comment_end.read();\n                        if (resulting_string) {\n                            in_html_comment = false;\n                            return this._create_token(TOKEN.COMMENT, resulting_string);\n                        }\n                    }\n                    return null;\n                };\n                Tokenizer.prototype._read_comment = function(c) {\n                    var token = null;\n                    if (c === \"/\") {\n                        var comment = \"\";\n                        if (this._input.peek(1) === \"*\") {\n                            // peek for comment /* ... */\n                            comment = this.__patterns.block_comment.read();\n                            var directives = directives_core.get_directives(comment);\n                            if (directives && directives.ignore === \"start\") {\n                                comment += directives_core.readIgnored(this._input);\n                            }\n                            comment = comment.replace(acorn.allLineBreaks, \"\\n\");\n                            token = this._create_token(TOKEN.BLOCK_COMMENT, comment);\n                            token.directives = directives;\n                        } else if (this._input.peek(1) === \"/\") {\n                            // peek for comment // ...\n                            comment = this.__patterns.comment.read();\n                            token = this._create_token(TOKEN.COMMENT, comment);\n                        }\n                    }\n                    return token;\n                };\n                Tokenizer.prototype._read_string = function(c) {\n                    if (c === \"`\" || c === \"'\" || c === '\"') {\n                        var resulting_string = this._input.next();\n                        this.has_char_escapes = false;\n                        if (c === \"`\") {\n                            resulting_string += this._read_string_recursive(\"`\", true, \"${\");\n                        } else {\n                            resulting_string += this._read_string_recursive(c);\n                        }\n                        if (this.has_char_escapes && this._options.unescape_strings) {\n                            resulting_string = unescape_string(resulting_string);\n                        }\n                        if (this._input.peek() === c) {\n                            resulting_string += this._input.next();\n                        }\n                        resulting_string = resulting_string.replace(acorn.allLineBreaks, \"\\n\");\n                        return this._create_token(TOKEN.STRING, resulting_string);\n                    }\n                    return null;\n                };\n                Tokenizer.prototype._allow_regexp_or_xml = function(previous_token) {\n                    // regex and xml can only appear in specific locations during parsing\n                    return previous_token.type === TOKEN.RESERVED && in_array(previous_token.text, [\n                        \"return\",\n                        \"case\",\n                        \"throw\",\n                        \"else\",\n                        \"do\",\n                        \"typeof\",\n                        \"yield\"\n                    ]) || previous_token.type === TOKEN.END_EXPR && previous_token.text === \")\" && previous_token.opened.previous.type === TOKEN.RESERVED && in_array(previous_token.opened.previous.text, [\n                        \"if\",\n                        \"while\",\n                        \"for\"\n                    ]) || in_array(previous_token.type, [\n                        TOKEN.COMMENT,\n                        TOKEN.START_EXPR,\n                        TOKEN.START_BLOCK,\n                        TOKEN.START,\n                        TOKEN.END_BLOCK,\n                        TOKEN.OPERATOR,\n                        TOKEN.EQUALS,\n                        TOKEN.EOF,\n                        TOKEN.SEMICOLON,\n                        TOKEN.COMMA\n                    ]);\n                };\n                Tokenizer.prototype._read_regexp = function(c, previous_token) {\n                    if (c === \"/\" && this._allow_regexp_or_xml(previous_token)) {\n                        // handle regexp\n                        //\n                        var resulting_string = this._input.next();\n                        var esc = false;\n                        var in_char_class = false;\n                        while(this._input.hasNext() && (esc || in_char_class || this._input.peek() !== c) && !this._input.testChar(acorn.newline)){\n                            resulting_string += this._input.peek();\n                            if (!esc) {\n                                esc = this._input.peek() === \"\\\\\";\n                                if (this._input.peek() === \"[\") {\n                                    in_char_class = true;\n                                } else if (this._input.peek() === \"]\") {\n                                    in_char_class = false;\n                                }\n                            } else {\n                                esc = false;\n                            }\n                            this._input.next();\n                        }\n                        if (this._input.peek() === c) {\n                            resulting_string += this._input.next();\n                            // regexps may have modifiers /regexp/MOD , so fetch those, too\n                            // Only [gim] are valid, but if the user puts in garbage, do what we can to take it.\n                            resulting_string += this._input.read(acorn.identifier);\n                        }\n                        return this._create_token(TOKEN.STRING, resulting_string);\n                    }\n                    return null;\n                };\n                Tokenizer.prototype._read_xml = function(c, previous_token) {\n                    if (this._options.e4x && c === \"<\" && this._allow_regexp_or_xml(previous_token)) {\n                        var xmlStr = \"\";\n                        var match = this.__patterns.xml.read_match();\n                        // handle e4x xml literals\n                        //\n                        if (match) {\n                            // Trim root tag to attempt to\n                            var rootTag = match[2].replace(/^{\\s+/, \"{\").replace(/\\s+}$/, \"}\");\n                            var isCurlyRoot = rootTag.indexOf(\"{\") === 0;\n                            var depth = 0;\n                            while(match){\n                                var isEndTag = !!match[1];\n                                var tagName = match[2];\n                                var isSingletonTag = !!match[match.length - 1] || tagName.slice(0, 8) === \"![CDATA[\";\n                                if (!isSingletonTag && (tagName === rootTag || isCurlyRoot && tagName.replace(/^{\\s+/, \"{\").replace(/\\s+}$/, \"}\"))) {\n                                    if (isEndTag) {\n                                        --depth;\n                                    } else {\n                                        ++depth;\n                                    }\n                                }\n                                xmlStr += match[0];\n                                if (depth <= 0) {\n                                    break;\n                                }\n                                match = this.__patterns.xml.read_match();\n                            }\n                            // if we didn't close correctly, keep unformatted.\n                            if (!match) {\n                                xmlStr += this._input.match(/[\\s\\S]*/g)[0];\n                            }\n                            xmlStr = xmlStr.replace(acorn.allLineBreaks, \"\\n\");\n                            return this._create_token(TOKEN.STRING, xmlStr);\n                        }\n                    }\n                    return null;\n                };\n                function unescape_string(s) {\n                    // You think that a regex would work for this\n                    // return s.replace(/\\\\x([0-9a-f]{2})/gi, function(match, val) {\n                    //         return String.fromCharCode(parseInt(val, 16));\n                    //     })\n                    // However, dealing with '\\xff', '\\\\xff', '\\\\\\xff' makes this more fun.\n                    var out = \"\", escaped = 0;\n                    var input_scan = new InputScanner(s);\n                    var matched = null;\n                    while(input_scan.hasNext()){\n                        // Keep any whitespace, non-slash characters\n                        // also keep slash pairs.\n                        matched = input_scan.match(/([\\s]|[^\\\\]|\\\\\\\\)+/g);\n                        if (matched) {\n                            out += matched[0];\n                        }\n                        if (input_scan.peek() === \"\\\\\") {\n                            input_scan.next();\n                            if (input_scan.peek() === \"x\") {\n                                matched = input_scan.match(/x([0-9A-Fa-f]{2})/g);\n                            } else if (input_scan.peek() === \"u\") {\n                                matched = input_scan.match(/u([0-9A-Fa-f]{4})/g);\n                                if (!matched) {\n                                    matched = input_scan.match(/u\\{([0-9A-Fa-f]+)\\}/g);\n                                }\n                            } else {\n                                out += \"\\\\\";\n                                if (input_scan.hasNext()) {\n                                    out += input_scan.next();\n                                }\n                                continue;\n                            }\n                            // If there's some error decoding, return the original string\n                            if (!matched) {\n                                return s;\n                            }\n                            escaped = parseInt(matched[1], 16);\n                            if (escaped > 0x7e && escaped <= 0xff && matched[0].indexOf(\"x\") === 0) {\n                                // we bail out on \\x7f..\\xff,\n                                // leaving whole string escaped,\n                                // as it's probably completely binary\n                                return s;\n                            } else if (escaped >= 0x00 && escaped < 0x20) {\n                                // leave 0x00...0x1f escaped\n                                out += \"\\\\\" + matched[0];\n                            } else if (escaped > 0x10FFFF) {\n                                // If the escape sequence is out of bounds, keep the original sequence and continue conversion\n                                out += \"\\\\\" + matched[0];\n                            } else if (escaped === 0x22 || escaped === 0x27 || escaped === 0x5c) {\n                                // single-quote, apostrophe, backslash - escape these\n                                out += \"\\\\\" + String.fromCharCode(escaped);\n                            } else {\n                                out += String.fromCharCode(escaped);\n                            }\n                        }\n                    }\n                    return out;\n                }\n                // handle string\n                //\n                Tokenizer.prototype._read_string_recursive = function(delimiter, allow_unescaped_newlines, start_sub) {\n                    var current_char;\n                    var pattern;\n                    if (delimiter === \"'\") {\n                        pattern = this.__patterns.single_quote;\n                    } else if (delimiter === '\"') {\n                        pattern = this.__patterns.double_quote;\n                    } else if (delimiter === \"`\") {\n                        pattern = this.__patterns.template_text;\n                    } else if (delimiter === \"}\") {\n                        pattern = this.__patterns.template_expression;\n                    }\n                    var resulting_string = pattern.read();\n                    var next = \"\";\n                    while(this._input.hasNext()){\n                        next = this._input.next();\n                        if (next === delimiter || !allow_unescaped_newlines && acorn.newline.test(next)) {\n                            this._input.back();\n                            break;\n                        } else if (next === \"\\\\\" && this._input.hasNext()) {\n                            current_char = this._input.peek();\n                            if (current_char === \"x\" || current_char === \"u\") {\n                                this.has_char_escapes = true;\n                            } else if (current_char === \"\\r\" && this._input.peek(1) === \"\\n\") {\n                                this._input.next();\n                            }\n                            next += this._input.next();\n                        } else if (start_sub) {\n                            if (start_sub === \"${\" && next === \"$\" && this._input.peek() === \"{\") {\n                                next += this._input.next();\n                            }\n                            if (start_sub === next) {\n                                if (delimiter === \"`\") {\n                                    next += this._read_string_recursive(\"}\", allow_unescaped_newlines, \"`\");\n                                } else {\n                                    next += this._read_string_recursive(\"`\", allow_unescaped_newlines, \"${\");\n                                }\n                                if (this._input.hasNext()) {\n                                    next += this._input.next();\n                                }\n                            }\n                        }\n                        next += pattern.read();\n                        resulting_string += next;\n                    }\n                    return resulting_string;\n                };\n                module.exports.Tokenizer = Tokenizer;\n                module.exports.TOKEN = TOKEN;\n                module.exports.positionable_operators = positionable_operators.slice();\n                module.exports.line_starters = line_starters.slice();\n            /***/ },\n            /* 8 */ /***/ function(module) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var regexp_has_sticky = RegExp.prototype.hasOwnProperty(\"sticky\");\n                function InputScanner(input_string) {\n                    this.__input = input_string || \"\";\n                    this.__input_length = this.__input.length;\n                    this.__position = 0;\n                }\n                InputScanner.prototype.restart = function() {\n                    this.__position = 0;\n                };\n                InputScanner.prototype.back = function() {\n                    if (this.__position > 0) {\n                        this.__position -= 1;\n                    }\n                };\n                InputScanner.prototype.hasNext = function() {\n                    return this.__position < this.__input_length;\n                };\n                InputScanner.prototype.next = function() {\n                    var val = null;\n                    if (this.hasNext()) {\n                        val = this.__input.charAt(this.__position);\n                        this.__position += 1;\n                    }\n                    return val;\n                };\n                InputScanner.prototype.peek = function(index) {\n                    var val = null;\n                    index = index || 0;\n                    index += this.__position;\n                    if (index >= 0 && index < this.__input_length) {\n                        val = this.__input.charAt(index);\n                    }\n                    return val;\n                };\n                // This is a JavaScript only helper function (not in python)\n                // Javascript doesn't have a match method\n                // and not all implementation support \"sticky\" flag.\n                // If they do not support sticky then both this.match() and this.test() method\n                // must get the match and check the index of the match.\n                // If sticky is supported and set, this method will use it.\n                // Otherwise it will check that global is set, and fall back to the slower method.\n                InputScanner.prototype.__match = function(pattern, index) {\n                    pattern.lastIndex = index;\n                    var pattern_match = pattern.exec(this.__input);\n                    if (pattern_match && !(regexp_has_sticky && pattern.sticky)) {\n                        if (pattern_match.index !== index) {\n                            pattern_match = null;\n                        }\n                    }\n                    return pattern_match;\n                };\n                InputScanner.prototype.test = function(pattern, index) {\n                    index = index || 0;\n                    index += this.__position;\n                    if (index >= 0 && index < this.__input_length) {\n                        return !!this.__match(pattern, index);\n                    } else {\n                        return false;\n                    }\n                };\n                InputScanner.prototype.testChar = function(pattern, index) {\n                    // test one character regex match\n                    var val = this.peek(index);\n                    pattern.lastIndex = 0;\n                    return val !== null && pattern.test(val);\n                };\n                InputScanner.prototype.match = function(pattern) {\n                    var pattern_match = this.__match(pattern, this.__position);\n                    if (pattern_match) {\n                        this.__position += pattern_match[0].length;\n                    } else {\n                        pattern_match = null;\n                    }\n                    return pattern_match;\n                };\n                InputScanner.prototype.read = function(starting_pattern, until_pattern, until_after) {\n                    var val = \"\";\n                    var match;\n                    if (starting_pattern) {\n                        match = this.match(starting_pattern);\n                        if (match) {\n                            val += match[0];\n                        }\n                    }\n                    if (until_pattern && (match || !starting_pattern)) {\n                        val += this.readUntil(until_pattern, until_after);\n                    }\n                    return val;\n                };\n                InputScanner.prototype.readUntil = function(pattern, until_after) {\n                    var val = \"\";\n                    var match_index = this.__position;\n                    pattern.lastIndex = this.__position;\n                    var pattern_match = pattern.exec(this.__input);\n                    if (pattern_match) {\n                        match_index = pattern_match.index;\n                        if (until_after) {\n                            match_index += pattern_match[0].length;\n                        }\n                    } else {\n                        match_index = this.__input_length;\n                    }\n                    val = this.__input.substring(this.__position, match_index);\n                    this.__position = match_index;\n                    return val;\n                };\n                InputScanner.prototype.readUntilAfter = function(pattern) {\n                    return this.readUntil(pattern, true);\n                };\n                InputScanner.prototype.get_regexp = function(pattern, match_from) {\n                    var result = null;\n                    var flags = \"g\";\n                    if (match_from && regexp_has_sticky) {\n                        flags = \"y\";\n                    }\n                    // strings are converted to regexp\n                    if (typeof pattern === \"string\" && pattern !== \"\") {\n                        // result = new RegExp(pattern.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&'), flags);\n                        result = new RegExp(pattern, flags);\n                    } else if (pattern) {\n                        result = new RegExp(pattern.source, flags);\n                    }\n                    return result;\n                };\n                InputScanner.prototype.get_literal_regexp = function(literal_string) {\n                    return RegExp(literal_string.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\"));\n                };\n                /* css beautifier legacy helpers */ InputScanner.prototype.peekUntilAfter = function(pattern) {\n                    var start = this.__position;\n                    var val = this.readUntilAfter(pattern);\n                    this.__position = start;\n                    return val;\n                };\n                InputScanner.prototype.lookBack = function(testVal) {\n                    var start = this.__position - 1;\n                    return start >= testVal.length && this.__input.substring(start - testVal.length, start).toLowerCase() === testVal;\n                };\n                module.exports.InputScanner = InputScanner;\n            /***/ },\n            /* 9 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_175344__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var InputScanner = __nested_webpack_require_175344__(8).InputScanner;\n                var Token = __nested_webpack_require_175344__(3).Token;\n                var TokenStream = __nested_webpack_require_175344__(10).TokenStream;\n                var WhitespacePattern = __nested_webpack_require_175344__(11).WhitespacePattern;\n                var TOKEN = {\n                    START: \"TK_START\",\n                    RAW: \"TK_RAW\",\n                    EOF: \"TK_EOF\"\n                };\n                var Tokenizer = function(input_string, options) {\n                    this._input = new InputScanner(input_string);\n                    this._options = options || {};\n                    this.__tokens = null;\n                    this._patterns = {};\n                    this._patterns.whitespace = new WhitespacePattern(this._input);\n                };\n                Tokenizer.prototype.tokenize = function() {\n                    this._input.restart();\n                    this.__tokens = new TokenStream();\n                    this._reset();\n                    var current;\n                    var previous = new Token(TOKEN.START, \"\");\n                    var open_token = null;\n                    var open_stack = [];\n                    var comments = new TokenStream();\n                    while(previous.type !== TOKEN.EOF){\n                        current = this._get_next_token(previous, open_token);\n                        while(this._is_comment(current)){\n                            comments.add(current);\n                            current = this._get_next_token(previous, open_token);\n                        }\n                        if (!comments.isEmpty()) {\n                            current.comments_before = comments;\n                            comments = new TokenStream();\n                        }\n                        current.parent = open_token;\n                        if (this._is_opening(current)) {\n                            open_stack.push(open_token);\n                            open_token = current;\n                        } else if (open_token && this._is_closing(current, open_token)) {\n                            current.opened = open_token;\n                            open_token.closed = current;\n                            open_token = open_stack.pop();\n                            current.parent = open_token;\n                        }\n                        current.previous = previous;\n                        previous.next = current;\n                        this.__tokens.add(current);\n                        previous = current;\n                    }\n                    return this.__tokens;\n                };\n                Tokenizer.prototype._is_first_token = function() {\n                    return this.__tokens.isEmpty();\n                };\n                Tokenizer.prototype._reset = function() {};\n                Tokenizer.prototype._get_next_token = function(previous_token, open_token) {\n                    this._readWhitespace();\n                    var resulting_string = this._input.read(/.+/g);\n                    if (resulting_string) {\n                        return this._create_token(TOKEN.RAW, resulting_string);\n                    } else {\n                        return this._create_token(TOKEN.EOF, \"\");\n                    }\n                };\n                Tokenizer.prototype._is_comment = function(current_token) {\n                    return false;\n                };\n                Tokenizer.prototype._is_opening = function(current_token) {\n                    return false;\n                };\n                Tokenizer.prototype._is_closing = function(current_token, open_token) {\n                    return false;\n                };\n                Tokenizer.prototype._create_token = function(type, text) {\n                    var token = new Token(type, text, this._patterns.whitespace.newline_count, this._patterns.whitespace.whitespace_before_token);\n                    return token;\n                };\n                Tokenizer.prototype._readWhitespace = function() {\n                    return this._patterns.whitespace.read();\n                };\n                module.exports.Tokenizer = Tokenizer;\n                module.exports.TOKEN = TOKEN;\n            /***/ },\n            /* 10 */ /***/ function(module) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ function TokenStream(parent_token) {\n                    // private\n                    this.__tokens = [];\n                    this.__tokens_length = this.__tokens.length;\n                    this.__position = 0;\n                    this.__parent_token = parent_token;\n                }\n                TokenStream.prototype.restart = function() {\n                    this.__position = 0;\n                };\n                TokenStream.prototype.isEmpty = function() {\n                    return this.__tokens_length === 0;\n                };\n                TokenStream.prototype.hasNext = function() {\n                    return this.__position < this.__tokens_length;\n                };\n                TokenStream.prototype.next = function() {\n                    var val = null;\n                    if (this.hasNext()) {\n                        val = this.__tokens[this.__position];\n                        this.__position += 1;\n                    }\n                    return val;\n                };\n                TokenStream.prototype.peek = function(index) {\n                    var val = null;\n                    index = index || 0;\n                    index += this.__position;\n                    if (index >= 0 && index < this.__tokens_length) {\n                        val = this.__tokens[index];\n                    }\n                    return val;\n                };\n                TokenStream.prototype.add = function(token) {\n                    if (this.__parent_token) {\n                        token.parent = this.__parent_token;\n                    }\n                    this.__tokens.push(token);\n                    this.__tokens_length += 1;\n                };\n                module.exports.TokenStream = TokenStream;\n            /***/ },\n            /* 11 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_183878__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var Pattern = __nested_webpack_require_183878__(12).Pattern;\n                function WhitespacePattern(input_scanner, parent) {\n                    Pattern.call(this, input_scanner, parent);\n                    if (parent) {\n                        this._line_regexp = this._input.get_regexp(parent._line_regexp);\n                    } else {\n                        this.__set_whitespace_patterns(\"\", \"\");\n                    }\n                    this.newline_count = 0;\n                    this.whitespace_before_token = \"\";\n                }\n                WhitespacePattern.prototype = new Pattern();\n                WhitespacePattern.prototype.__set_whitespace_patterns = function(whitespace_chars, newline_chars) {\n                    whitespace_chars += \"\\\\t \";\n                    newline_chars += \"\\\\n\\\\r\";\n                    this._match_pattern = this._input.get_regexp(\"[\" + whitespace_chars + newline_chars + \"]+\", true);\n                    this._newline_regexp = this._input.get_regexp(\"\\\\r\\\\n|[\" + newline_chars + \"]\");\n                };\n                WhitespacePattern.prototype.read = function() {\n                    this.newline_count = 0;\n                    this.whitespace_before_token = \"\";\n                    var resulting_string = this._input.read(this._match_pattern);\n                    if (resulting_string === \" \") {\n                        this.whitespace_before_token = \" \";\n                    } else if (resulting_string) {\n                        var matches = this.__split(this._newline_regexp, resulting_string);\n                        this.newline_count = matches.length - 1;\n                        this.whitespace_before_token = matches[this.newline_count];\n                    }\n                    return resulting_string;\n                };\n                WhitespacePattern.prototype.matching = function(whitespace_chars, newline_chars) {\n                    var result = this._create();\n                    result.__set_whitespace_patterns(whitespace_chars, newline_chars);\n                    result._update();\n                    return result;\n                };\n                WhitespacePattern.prototype._create = function() {\n                    return new WhitespacePattern(this._input, this);\n                };\n                WhitespacePattern.prototype.__split = function(regexp, input_string) {\n                    regexp.lastIndex = 0;\n                    var start_index = 0;\n                    var result = [];\n                    var next_match = regexp.exec(input_string);\n                    while(next_match){\n                        result.push(input_string.substring(start_index, next_match.index));\n                        start_index = next_match.index + next_match[0].length;\n                        next_match = regexp.exec(input_string);\n                    }\n                    if (start_index < input_string.length) {\n                        result.push(input_string.substring(start_index, input_string.length));\n                    } else {\n                        result.push(\"\");\n                    }\n                    return result;\n                };\n                module.exports.WhitespacePattern = WhitespacePattern;\n            /***/ },\n            /* 12 */ /***/ function(module) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ function Pattern(input_scanner, parent) {\n                    this._input = input_scanner;\n                    this._starting_pattern = null;\n                    this._match_pattern = null;\n                    this._until_pattern = null;\n                    this._until_after = false;\n                    if (parent) {\n                        this._starting_pattern = this._input.get_regexp(parent._starting_pattern, true);\n                        this._match_pattern = this._input.get_regexp(parent._match_pattern, true);\n                        this._until_pattern = this._input.get_regexp(parent._until_pattern);\n                        this._until_after = parent._until_after;\n                    }\n                }\n                Pattern.prototype.read = function() {\n                    var result = this._input.read(this._starting_pattern);\n                    if (!this._starting_pattern || result) {\n                        result += this._input.read(this._match_pattern, this._until_pattern, this._until_after);\n                    }\n                    return result;\n                };\n                Pattern.prototype.read_match = function() {\n                    return this._input.match(this._match_pattern);\n                };\n                Pattern.prototype.until_after = function(pattern) {\n                    var result = this._create();\n                    result._until_after = true;\n                    result._until_pattern = this._input.get_regexp(pattern);\n                    result._update();\n                    return result;\n                };\n                Pattern.prototype.until = function(pattern) {\n                    var result = this._create();\n                    result._until_after = false;\n                    result._until_pattern = this._input.get_regexp(pattern);\n                    result._update();\n                    return result;\n                };\n                Pattern.prototype.starting_with = function(pattern) {\n                    var result = this._create();\n                    result._starting_pattern = this._input.get_regexp(pattern, true);\n                    result._update();\n                    return result;\n                };\n                Pattern.prototype.matching = function(pattern) {\n                    var result = this._create();\n                    result._match_pattern = this._input.get_regexp(pattern, true);\n                    result._update();\n                    return result;\n                };\n                Pattern.prototype._create = function() {\n                    return new Pattern(this._input, this);\n                };\n                Pattern.prototype._update = function() {};\n                module.exports.Pattern = Pattern;\n            /***/ },\n            /* 13 */ /***/ function(module) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ function Directives(start_block_pattern, end_block_pattern) {\n                    start_block_pattern = typeof start_block_pattern === \"string\" ? start_block_pattern : start_block_pattern.source;\n                    end_block_pattern = typeof end_block_pattern === \"string\" ? end_block_pattern : end_block_pattern.source;\n                    this.__directives_block_pattern = new RegExp(start_block_pattern + / beautify( \\w+[:]\\w+)+ /.source + end_block_pattern, \"g\");\n                    this.__directive_pattern = / (\\w+)[:](\\w+)/g;\n                    this.__directives_end_ignore_pattern = new RegExp(start_block_pattern + /\\sbeautify\\signore:end\\s/.source + end_block_pattern, \"g\");\n                }\n                Directives.prototype.get_directives = function(text) {\n                    if (!text.match(this.__directives_block_pattern)) {\n                        return null;\n                    }\n                    var directives = {};\n                    this.__directive_pattern.lastIndex = 0;\n                    var directive_match = this.__directive_pattern.exec(text);\n                    while(directive_match){\n                        directives[directive_match[1]] = directive_match[2];\n                        directive_match = this.__directive_pattern.exec(text);\n                    }\n                    return directives;\n                };\n                Directives.prototype.readIgnored = function(input) {\n                    return input.readUntilAfter(this.__directives_end_ignore_pattern);\n                };\n                module.exports.Directives = Directives;\n            /***/ },\n            /* 14 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_195270__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var Pattern = __nested_webpack_require_195270__(12).Pattern;\n                var template_names = {\n                    django: false,\n                    erb: false,\n                    handlebars: false,\n                    php: false,\n                    smarty: false,\n                    angular: false\n                };\n                // This lets templates appear anywhere we would do a readUntil\n                // The cost is higher but it is pay to play.\n                function TemplatablePattern(input_scanner, parent) {\n                    Pattern.call(this, input_scanner, parent);\n                    this.__template_pattern = null;\n                    this._disabled = Object.assign({}, template_names);\n                    this._excluded = Object.assign({}, template_names);\n                    if (parent) {\n                        this.__template_pattern = this._input.get_regexp(parent.__template_pattern);\n                        this._excluded = Object.assign(this._excluded, parent._excluded);\n                        this._disabled = Object.assign(this._disabled, parent._disabled);\n                    }\n                    var pattern = new Pattern(input_scanner);\n                    this.__patterns = {\n                        handlebars_comment: pattern.starting_with(/{{!--/).until_after(/--}}/),\n                        handlebars_unescaped: pattern.starting_with(/{{{/).until_after(/}}}/),\n                        handlebars: pattern.starting_with(/{{/).until_after(/}}/),\n                        php: pattern.starting_with(/<\\?(?:[= ]|php)/).until_after(/\\?>/),\n                        erb: pattern.starting_with(/<%[^%]/).until_after(/[^%]%>/),\n                        // django coflicts with handlebars a bit.\n                        django: pattern.starting_with(/{%/).until_after(/%}/),\n                        django_value: pattern.starting_with(/{{/).until_after(/}}/),\n                        django_comment: pattern.starting_with(/{#/).until_after(/#}/),\n                        smarty: pattern.starting_with(/{(?=[^}{\\s\\n])/).until_after(/[^\\s\\n]}/),\n                        smarty_comment: pattern.starting_with(/{\\*/).until_after(/\\*}/),\n                        smarty_literal: pattern.starting_with(/{literal}/).until_after(/{\\/literal}/)\n                    };\n                }\n                TemplatablePattern.prototype = new Pattern();\n                TemplatablePattern.prototype._create = function() {\n                    return new TemplatablePattern(this._input, this);\n                };\n                TemplatablePattern.prototype._update = function() {\n                    this.__set_templated_pattern();\n                };\n                TemplatablePattern.prototype.disable = function(language) {\n                    var result = this._create();\n                    result._disabled[language] = true;\n                    result._update();\n                    return result;\n                };\n                TemplatablePattern.prototype.read_options = function(options) {\n                    var result = this._create();\n                    for(var language in template_names){\n                        result._disabled[language] = options.templating.indexOf(language) === -1;\n                    }\n                    result._update();\n                    return result;\n                };\n                TemplatablePattern.prototype.exclude = function(language) {\n                    var result = this._create();\n                    result._excluded[language] = true;\n                    result._update();\n                    return result;\n                };\n                TemplatablePattern.prototype.read = function() {\n                    var result = \"\";\n                    if (this._match_pattern) {\n                        result = this._input.read(this._starting_pattern);\n                    } else {\n                        result = this._input.read(this._starting_pattern, this.__template_pattern);\n                    }\n                    var next = this._read_template();\n                    while(next){\n                        if (this._match_pattern) {\n                            next += this._input.read(this._match_pattern);\n                        } else {\n                            next += this._input.readUntil(this.__template_pattern);\n                        }\n                        result += next;\n                        next = this._read_template();\n                    }\n                    if (this._until_after) {\n                        result += this._input.readUntilAfter(this._until_pattern);\n                    }\n                    return result;\n                };\n                TemplatablePattern.prototype.__set_templated_pattern = function() {\n                    var items = [];\n                    if (!this._disabled.php) {\n                        items.push(this.__patterns.php._starting_pattern.source);\n                    }\n                    if (!this._disabled.handlebars) {\n                        items.push(this.__patterns.handlebars._starting_pattern.source);\n                    }\n                    if (!this._disabled.erb) {\n                        items.push(this.__patterns.erb._starting_pattern.source);\n                    }\n                    if (!this._disabled.django) {\n                        items.push(this.__patterns.django._starting_pattern.source);\n                        // The starting pattern for django is more complex because it has different\n                        // patterns for value, comment, and other sections\n                        items.push(this.__patterns.django_value._starting_pattern.source);\n                        items.push(this.__patterns.django_comment._starting_pattern.source);\n                    }\n                    if (!this._disabled.smarty) {\n                        items.push(this.__patterns.smarty._starting_pattern.source);\n                    }\n                    if (this._until_pattern) {\n                        items.push(this._until_pattern.source);\n                    }\n                    this.__template_pattern = this._input.get_regexp(\"(?:\" + items.join(\"|\") + \")\");\n                };\n                TemplatablePattern.prototype._read_template = function() {\n                    var resulting_string = \"\";\n                    var c = this._input.peek();\n                    if (c === \"<\") {\n                        var peek1 = this._input.peek(1);\n                        //if we're in a comment, do something special\n                        // We treat all comments as literals, even more than preformatted tags\n                        // we just look for the appropriate close tag\n                        if (!this._disabled.php && !this._excluded.php && peek1 === \"?\") {\n                            resulting_string = resulting_string || this.__patterns.php.read();\n                        }\n                        if (!this._disabled.erb && !this._excluded.erb && peek1 === \"%\") {\n                            resulting_string = resulting_string || this.__patterns.erb.read();\n                        }\n                    } else if (c === \"{\") {\n                        if (!this._disabled.handlebars && !this._excluded.handlebars) {\n                            resulting_string = resulting_string || this.__patterns.handlebars_comment.read();\n                            resulting_string = resulting_string || this.__patterns.handlebars_unescaped.read();\n                            resulting_string = resulting_string || this.__patterns.handlebars.read();\n                        }\n                        if (!this._disabled.django) {\n                            // django coflicts with handlebars a bit.\n                            if (!this._excluded.django && !this._excluded.handlebars) {\n                                resulting_string = resulting_string || this.__patterns.django_value.read();\n                            }\n                            if (!this._excluded.django) {\n                                resulting_string = resulting_string || this.__patterns.django_comment.read();\n                                resulting_string = resulting_string || this.__patterns.django.read();\n                            }\n                        }\n                        if (!this._disabled.smarty) {\n                            // smarty cannot be enabled with django or handlebars enabled\n                            if (this._disabled.django && this._disabled.handlebars) {\n                                resulting_string = resulting_string || this.__patterns.smarty_comment.read();\n                                resulting_string = resulting_string || this.__patterns.smarty_literal.read();\n                                resulting_string = resulting_string || this.__patterns.smarty.read();\n                            }\n                        }\n                    }\n                    return resulting_string;\n                };\n                module.exports.TemplatablePattern = TemplatablePattern;\n            /***/ }\n        ];\n        /************************************************************************/ /******/ // The module cache\n        /******/ var __webpack_module_cache__ = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_205782__(moduleId) {\n            /******/ // Check if module is in cache\n            /******/ var cachedModule = __webpack_module_cache__[moduleId];\n            /******/ if (cachedModule !== undefined) {\n                /******/ return cachedModule.exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module = __webpack_module_cache__[moduleId] = {\n                /******/ // no module.id needed\n                /******/ // no module.loaded needed\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ __webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_205782__);\n            /******/ /******/ // Return the exports of the module\n            /******/ return module.exports;\n        /******/ }\n        /******/ /************************************************************************/ /******/ /******/ // startup\n        /******/ // Load entry module and return exports\n        /******/ // This entry module is referenced by other modules so it can't be inlined\n        /******/ var __nested_webpack_exports__ = __nested_webpack_require_205782__(0);\n        /******/ legacy_beautify_js = __nested_webpack_exports__;\n    /******/ /******/ })();\n    var js_beautify = legacy_beautify_js;\n    /* Footer */ if (true) {\n        // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n            return {\n                js_beautify: js_beautify\n            };\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanMtYmVhdXRpZnkvanMvbGliL2JlYXV0aWZ5LmpzIiwibWFwcGluZ3MiOiJBQUFBLGtHQUFrQyxHQUNsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0ZBLEdBRUM7SUFFRCwwQkFBMEIsR0FDMUIsSUFBSUE7SUFDSixNQUFNLEdBQUk7UUFDVixNQUFNLEdBQUk7UUFDVixNQUFNLEdBQUksSUFBSUMsc0JBQXVCO1lBQ3JDLEtBQUssR0FDTCxHQUFHLEdBQUksU0FBU0MsTUFBTSxFQUFFQyx3QkFBd0IsRUFBRUMsK0JBQW1CO2dCQUVyRSxtQkFBbUIsR0FDbkI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5QkEsR0FJQSxJQUFJQyxhQUFjRCwrQkFBbUJBLENBQUMsR0FBR0MsVUFBVSxFQUNqREMsVUFBV0YsK0JBQW1CQSxDQUFDLEdBQUdFLE9BQU87Z0JBRTNDLFNBQVNDLFlBQVlDLGNBQWMsRUFBRUMsT0FBTztvQkFDMUMsSUFBSUMsYUFBYSxJQUFJTCxXQUFXRyxnQkFBZ0JDO29CQUNoRCxPQUFPQyxXQUFXQyxRQUFRO2dCQUM1QjtnQkFFQVQsT0FBT1UsT0FBTyxHQUFHTDtnQkFDakJMLE9BQU9VLE9BQU8sQ0FBQ0MsY0FBYyxHQUFHO29CQUM5QixPQUFPLElBQUlQO2dCQUNiO1lBR0EsR0FBRyxHQUFHO1lBQ04sS0FBSyxHQUNMLEdBQUcsR0FBSSxTQUFTSixNQUFNLEVBQUVDLHdCQUF3QixFQUFFQywrQkFBbUI7Z0JBRXJFLG1CQUFtQixHQUNuQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQSxHQUlBLElBQUlVLFNBQVVWLCtCQUFtQkEsQ0FBQyxHQUFHVSxNQUFNO2dCQUMzQyxJQUFJQyxRQUFTWCwrQkFBbUJBLENBQUMsR0FBR1csS0FBSztnQkFDekMsSUFBSUMsUUFBUVosK0JBQW1CQSxDQUFD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TSxHQUFNLDBCQUEwQjtnQkFDdEMsTUFBTSxHQUFNcGhCLFNBQVMsQ0FBQztZQUNYO1lBQ1gsTUFBTSxHQUNOLE1BQU0sR0FBSyw4QkFBOEI7WUFDekMsTUFBTSxHQUFLWCxtQkFBbUIsQ0FBQytoQixTQUFTLENBQUM5aEIsUUFBUUEsT0FBT1UsT0FBTyxFQUFFUixpQ0FBbUJBO1lBQ3BGLE1BQU0sR0FDTixNQUFNLEdBQUssbUNBQW1DO1lBQzlDLE1BQU0sR0FBSyxPQUFPRixPQUFPVSxPQUFPO1FBQ2hDLE1BQU0sR0FBSTtRQUNWLE1BQU0sR0FDTix3RUFBd0UsR0FDeEUsTUFBTSxHQUNOLE1BQU0sR0FBSSxVQUFVO1FBQ3BCLE1BQU0sR0FBSSx1Q0FBdUM7UUFDakQsTUFBTSxHQUFJLDBFQUEwRTtRQUNwRixNQUFNLEdBQUksSUFBSXNoQiwwQkFBbUJBLEdBQUc5aEIsaUNBQW1CQSxDQUFDO1FBQ3hELE1BQU0sR0FBSUoscUJBQXFCa2lCLDBCQUFtQkE7SUFDbEQsTUFBTSxHQUNOLE1BQU0sR0FBRztJQUVULElBQUkzaEIsY0FBY1A7SUFDbEIsVUFBVSxHQUNWLElBQUksSUFBMEMsRUFBRTtRQUM1QywwRkFBMEY7UUFDMUZtaUIsaUNBQU8sRUFBRSxtQ0FBRTtZQUNQLE9BQU87Z0JBQUU1aEIsYUFBYUE7WUFBWTtRQUN0QyxDQUFDO0FBQUEsa0dBQUM7SUFDTixPQUFPLEVBVU47QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL21iY2xlYW5zLy4vbm9kZV9tb2R1bGVzL2pzLWJlYXV0aWZ5L2pzL2xpYi9iZWF1dGlmeS5qcz9jN2MwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIEFVVE8tR0VORVJBVEVELiBETyBOT1QgTU9ESUZZLiAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG5cbiBKUyBCZWF1dGlmaWVyXG4tLS0tLS0tLS0tLS0tLS1cblxuXG4gIFdyaXR0ZW4gYnkgRWluYXIgTGllbG1hbmlzLCA8ZWluYXJAYmVhdXRpZmllci5pbz5cbiAgICAgIGh0dHBzOi8vYmVhdXRpZmllci5pby9cblxuICBPcmlnaW5hbGx5IGNvbnZlcnRlZCB0byBqYXZhc2NyaXB0IGJ5IFZpdGFsLCA8dml0YWw3NkBnbWFpbC5jb20+XG4gIFwiRW5kIGJyYWNlcyBvbiBvd24gbGluZVwiIGFkZGVkIGJ5IENocmlzIEouIFNodWxsLCA8Y2hyaXNqc2h1bGxAZ21haWwuY29tPlxuICBQYXJzaW5nIGltcHJvdmVtZW50cyBmb3IgYnJhY2UtbGVzcyBzdGF0ZW1lbnRzIGJ5IExpYW0gTmV3bWFuIDxiaXR3aXNlbWFuQGJlYXV0aWZpZXIuaW8+XG5cblxuICBVc2FnZTpcbiAgICBqc19iZWF1dGlmeShqc19zb3VyY2VfdGV4dCk7XG4gICAganNfYmVhdXRpZnkoanNfc291cmNlX3RleHQsIG9wdGlvbnMpO1xuXG4gIFRoZSBvcHRpb25zIGFyZTpcbiAgICBpbmRlbnRfc2l6ZSAoZGVmYXVsdCA0KSAgICAgICAgICAtIGluZGVudGF0aW9uIHNpemUsXG4gICAgaW5kZW50X2NoYXIgKGRlZmF1bHQgc3BhY2UpICAgICAgLSBjaGFyYWN0ZXIgdG8gaW5kZW50IHdpdGgsXG4gICAgcHJlc2VydmVfbmV3bGluZXMgKGRlZmF1bHQgdHJ1ZSkgLSB3aGV0aGVyIGV4aXN0aW5nIGxpbmUgYnJlYWtzIHNob3VsZCBiZSBwcmVzZXJ2ZWQsXG4gICAgbWF4X3ByZXNlcnZlX25ld2xpbmVzIChkZWZhdWx0IHVubGltaXRlZCkgLSBtYXhpbXVtIG51bWJlciBvZiBsaW5lIGJyZWFrcyB0byBiZSBwcmVzZXJ2ZWQgaW4gb25lIGNodW5rLFxuXG4gICAganNsaW50X2hhcHB5IChkZWZhdWx0IGZhbHNlKSAtIGlmIHRydWUsIHRoZW4ganNsaW50LXN0cmljdGVyIG1vZGUgaXMgZW5mb3JjZWQuXG5cbiAgICAgICAgICAgIGpzbGludF9oYXBweSAgICAgICAgIWpzbGludF9oYXBweVxuICAgICAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSAgICAgICAgIGZ1bmN0aW9uKClcblxuICAgICAgICAgICAgc3dpdGNoICgpIHsgICAgICAgICBzd2l0Y2goKSB7XG4gICAgICAgICAgICBjYXNlIDE6ICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBicmVhazsgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgIH1cblxuICAgIHNwYWNlX2FmdGVyX2Fub25fZnVuY3Rpb24gKGRlZmF1bHQgZmFsc2UpIC0gc2hvdWxkIHRoZSBzcGFjZSBiZWZvcmUgYW4gYW5vbnltb3VzIGZ1bmN0aW9uJ3MgcGFyZW5zIGJlIGFkZGVkLCBcImZ1bmN0aW9uKClcIiB2cyBcImZ1bmN0aW9uICgpXCIsXG4gICAgICAgICAgTk9URTogVGhpcyBvcHRpb24gaXMgb3ZlcnJpZGRlbiBieSBqc2xpbnRfaGFwcHkgKGkuZS4gaWYganNsaW50X2hhcHB5IGlzIHRydWUsIHNwYWNlX2FmdGVyX2Fub25fZnVuY3Rpb24gaXMgdHJ1ZSBieSBkZXNpZ24pXG5cbiAgICBicmFjZV9zdHlsZSAoZGVmYXVsdCBcImNvbGxhcHNlXCIpIC0gXCJjb2xsYXBzZVwiIHwgXCJleHBhbmRcIiB8IFwiZW5kLWV4cGFuZFwiIHwgXCJub25lXCIgfCBhbnkgb2YgdGhlIGZvcm1lciArIFwiLHByZXNlcnZlLWlubGluZVwiXG4gICAgICAgICAgICBwdXQgYnJhY2VzIG9uIHRoZSBzYW1lIGxpbmUgYXMgY29udHJvbCBzdGF0ZW1lbnRzIChkZWZhdWx0KSwgb3IgcHV0IGJyYWNlcyBvbiBvd24gbGluZSAoQWxsbWFuIC8gQU5TSSBzdHlsZSksIG9yIGp1c3QgcHV0IGVuZCBicmFjZXMgb24gb3duIGxpbmUsIG9yIGF0dGVtcHQgdG8ga2VlcCB0aGVtIHdoZXJlIHRoZXkgYXJlLlxuICAgICAgICAgICAgcHJlc2VydmUtaW5saW5lIHdpbGwgdHJ5IHRvIHByZXNlcnZlIGlubGluZSBibG9ja3Mgb2YgY3VybHkgYnJhY2VzXG5cbiAgICBzcGFjZV9iZWZvcmVfY29uZGl0aW9uYWwgKGRlZmF1bHQgdHJ1ZSkgLSBzaG91bGQgdGhlIHNwYWNlIGJlZm9yZSBjb25kaXRpb25hbCBzdGF0ZW1lbnQgYmUgYWRkZWQsIFwiaWYodHJ1ZSlcIiB2cyBcImlmICh0cnVlKVwiLFxuXG4gICAgdW5lc2NhcGVfc3RyaW5ncyAoZGVmYXVsdCBmYWxzZSkgLSBzaG91bGQgcHJpbnRhYmxlIGNoYXJhY3RlcnMgaW4gc3RyaW5ncyBlbmNvZGVkIGluIFxceE5OIG5vdGF0aW9uIGJlIHVuZXNjYXBlZCwgXCJleGFtcGxlXCIgdnMgXCJcXHg2NVxceDc4XFx4NjFcXHg2ZFxceDcwXFx4NmNcXHg2NVwiXG5cbiAgICB3cmFwX2xpbmVfbGVuZ3RoIChkZWZhdWx0IHVubGltaXRlZCkgLSBsaW5lcyBzaG91bGQgd3JhcCBhdCBuZXh0IG9wcG9ydHVuaXR5IGFmdGVyIHRoaXMgbnVtYmVyIG9mIGNoYXJhY3RlcnMuXG4gICAgICAgICAgTk9URTogVGhpcyBpcyBub3QgYSBoYXJkIGxpbWl0LiBMaW5lcyB3aWxsIGNvbnRpbnVlIHVudGlsIGEgcG9pbnQgd2hlcmUgYSBuZXdsaW5lIHdvdWxkXG4gICAgICAgICAgICAgICAgYmUgcHJlc2VydmVkIGlmIGl0IHdlcmUgcHJlc2VudC5cblxuICAgIGVuZF93aXRoX25ld2xpbmUgKGRlZmF1bHQgZmFsc2UpICAtIGVuZCBvdXRwdXQgd2l0aCBhIG5ld2xpbmVcblxuXG4gICAgZS5nXG5cbiAgICBqc19iZWF1dGlmeShqc19zb3VyY2VfdGV4dCwge1xuICAgICAgJ2luZGVudF9zaXplJzogMSxcbiAgICAgICdpbmRlbnRfY2hhcic6ICdcXHQnXG4gICAgfSk7XG5cbiovXG5cbihmdW5jdGlvbigpIHtcblxuLyogR0VORVJBVEVEX0JVSUxEX09VVFBVVCAqL1xudmFyIGxlZ2FjeV9iZWF1dGlmeV9qcztcbi8qKioqKiovIChmdW5jdGlvbigpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHRcInVzZSBzdHJpY3RcIjtcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxudmFyIEJlYXV0aWZpZXIgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygxKS5CZWF1dGlmaWVyKSxcbiAgT3B0aW9ucyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDUpLk9wdGlvbnMpO1xuXG5mdW5jdGlvbiBqc19iZWF1dGlmeShqc19zb3VyY2VfdGV4dCwgb3B0aW9ucykge1xuICB2YXIgYmVhdXRpZmllciA9IG5ldyBCZWF1dGlmaWVyKGpzX3NvdXJjZV90ZXh0LCBvcHRpb25zKTtcbiAgcmV0dXJuIGJlYXV0aWZpZXIuYmVhdXRpZnkoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBqc19iZWF1dGlmeTtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgT3B0aW9ucygpO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbnZhciBPdXRwdXQgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygyKS5PdXRwdXQpO1xudmFyIFRva2VuID0gKF9fd2VicGFja19yZXF1aXJlX18oMykuVG9rZW4pO1xudmFyIGFjb3JuID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbnZhciBPcHRpb25zID0gKF9fd2VicGFja19yZXF1aXJlX18oNSkuT3B0aW9ucyk7XG52YXIgVG9rZW5pemVyID0gKF9fd2VicGFja19yZXF1aXJlX18oNykuVG9rZW5pemVyKTtcbnZhciBsaW5lX3N0YXJ0ZXJzID0gKF9fd2VicGFja19yZXF1aXJlX18oNykubGluZV9zdGFydGVycyk7XG52YXIgcG9zaXRpb25hYmxlX29wZXJhdG9ycyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDcpLnBvc2l0aW9uYWJsZV9vcGVyYXRvcnMpO1xudmFyIFRPS0VOID0gKF9fd2VicGFja19yZXF1aXJlX18oNykuVE9LRU4pO1xuXG5cbmZ1bmN0aW9uIGluX2FycmF5KHdoYXQsIGFycikge1xuICByZXR1cm4gYXJyLmluZGV4T2Yod2hhdCkgIT09IC0xO1xufVxuXG5mdW5jdGlvbiBsdHJpbShzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoL15cXHMrL2csICcnKTtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVNYXBGcm9tU3RyaW5ncyhsaXN0KSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBsaXN0Lmxlbmd0aDsgeCsrKSB7XG4gICAgLy8gbWFrZSB0aGUgbWFwcGVkIG5hbWVzIHVuZGVyc2NvcmVkIGluc3RlYWQgb2YgZGFzaFxuICAgIHJlc3VsdFtsaXN0W3hdLnJlcGxhY2UoLy0vZywgJ18nKV0gPSBsaXN0W3hdO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHJlc2VydmVkX3dvcmQodG9rZW4sIHdvcmQpIHtcbiAgcmV0dXJuIHRva2VuICYmIHRva2VuLnR5cGUgPT09IFRPS0VOLlJFU0VSVkVEICYmIHRva2VuLnRleHQgPT09IHdvcmQ7XG59XG5cbmZ1bmN0aW9uIHJlc2VydmVkX2FycmF5KHRva2VuLCB3b3Jkcykge1xuICByZXR1cm4gdG9rZW4gJiYgdG9rZW4udHlwZSA9PT0gVE9LRU4uUkVTRVJWRUQgJiYgaW5fYXJyYXkodG9rZW4udGV4dCwgd29yZHMpO1xufVxuLy8gVW5zdXJlIG9mIHdoYXQgdGhleSBtZWFuLCBidXQgdGhleSB3b3JrLiBXb3J0aCBjbGVhbmluZyB1cCBpbiBmdXR1cmUuXG52YXIgc3BlY2lhbF93b3JkcyA9IFsnY2FzZScsICdyZXR1cm4nLCAnZG8nLCAnaWYnLCAndGhyb3cnLCAnZWxzZScsICdhd2FpdCcsICdicmVhaycsICdjb250aW51ZScsICdhc3luYyddO1xuXG52YXIgdmFsaWRQb3NpdGlvblZhbHVlcyA9IFsnYmVmb3JlLW5ld2xpbmUnLCAnYWZ0ZXItbmV3bGluZScsICdwcmVzZXJ2ZS1uZXdsaW5lJ107XG5cbi8vIEdlbmVyYXRlIG1hcCBmcm9tIGFycmF5XG52YXIgT1BFUkFUT1JfUE9TSVRJT04gPSBnZW5lcmF0ZU1hcEZyb21TdHJpbmdzKHZhbGlkUG9zaXRpb25WYWx1ZXMpO1xuXG52YXIgT1BFUkFUT1JfUE9TSVRJT05fQkVGT1JFX09SX1BSRVNFUlZFID0gW09QRVJBVE9SX1BPU0lUSU9OLmJlZm9yZV9uZXdsaW5lLCBPUEVSQVRPUl9QT1NJVElPTi5wcmVzZXJ2ZV9uZXdsaW5lXTtcblxudmFyIE1PREUgPSB7XG4gIEJsb2NrU3RhdGVtZW50OiAnQmxvY2tTdGF0ZW1lbnQnLCAvLyAnQkxPQ0snXG4gIFN0YXRlbWVudDogJ1N0YXRlbWVudCcsIC8vICdTVEFURU1FTlQnXG4gIE9iamVjdExpdGVyYWw6ICdPYmplY3RMaXRlcmFsJywgLy8gJ09CSkVDVCcsXG4gIEFycmF5TGl0ZXJhbDogJ0FycmF5TGl0ZXJhbCcsIC8vJ1tFWFBSRVNTSU9OXScsXG4gIEZvckluaXRpYWxpemVyOiAnRm9ySW5pdGlhbGl6ZXInLCAvLycoRk9SLUVYUFJFU1NJT04pJyxcbiAgQ29uZGl0aW9uYWw6ICdDb25kaXRpb25hbCcsIC8vJyhDT05ELUVYUFJFU1NJT04pJyxcbiAgRXhwcmVzc2lvbjogJ0V4cHJlc3Npb24nIC8vJyhFWFBSRVNTSU9OKSdcbn07XG5cbmZ1bmN0aW9uIHJlbW92ZV9yZWR1bmRhbnRfaW5kZW50YXRpb24ob3V0cHV0LCBmcmFtZSkge1xuICAvLyBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGVmZmVjdGl2ZSBidXQgaGFzIHNvbWUgaXNzdWVzOlxuICAvLyAgICAgLSBjYW4gY2F1c2UgbGluZSB3cmFwIHRvIGhhcHBlbiB0b28gc29vbiBkdWUgdG8gaW5kZW50IHJlbW92YWxcbiAgLy8gICAgICAgICAgIGFmdGVyIHdyYXAgcG9pbnRzIGFyZSBjYWxjdWxhdGVkXG4gIC8vIFRoZXNlIGlzc3VlcyBhcmUgbWlub3IgY29tcGFyZWQgdG8gdWdseSBpbmRlbnRhdGlvbi5cblxuICBpZiAoZnJhbWUubXVsdGlsaW5lX2ZyYW1lIHx8XG4gICAgZnJhbWUubW9kZSA9PT0gTU9ERS5Gb3JJbml0aWFsaXplciB8fFxuICAgIGZyYW1lLm1vZGUgPT09IE1PREUuQ29uZGl0aW9uYWwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyByZW1vdmUgb25lIGluZGVudCBmcm9tIGVhY2ggbGluZSBpbnNpZGUgdGhpcyBzZWN0aW9uXG4gIG91dHB1dC5yZW1vdmVfaW5kZW50KGZyYW1lLnN0YXJ0X2xpbmVfaW5kZXgpO1xufVxuXG4vLyB3ZSBjb3VsZCB1c2UganVzdCBzdHJpbmcuc3BsaXQsIGJ1dFxuLy8gSUUgZG9lc24ndCBsaWtlIHJldHVybmluZyBlbXB0eSBzdHJpbmdzXG5mdW5jdGlvbiBzcGxpdF9saW5lYnJlYWtzKHMpIHtcbiAgLy9yZXR1cm4gcy5zcGxpdCgvXFx4MGRcXHgwYXxcXHgwYS8pO1xuXG4gIHMgPSBzLnJlcGxhY2UoYWNvcm4uYWxsTGluZUJyZWFrcywgJ1xcbicpO1xuICB2YXIgb3V0ID0gW10sXG4gICAgaWR4ID0gcy5pbmRleE9mKFwiXFxuXCIpO1xuICB3aGlsZSAoaWR4ICE9PSAtMSkge1xuICAgIG91dC5wdXNoKHMuc3Vic3RyaW5nKDAsIGlkeCkpO1xuICAgIHMgPSBzLnN1YnN0cmluZyhpZHggKyAxKTtcbiAgICBpZHggPSBzLmluZGV4T2YoXCJcXG5cIik7XG4gIH1cbiAgaWYgKHMubGVuZ3RoKSB7XG4gICAgb3V0LnB1c2gocyk7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gaXNfYXJyYXkobW9kZSkge1xuICByZXR1cm4gbW9kZSA9PT0gTU9ERS5BcnJheUxpdGVyYWw7XG59XG5cbmZ1bmN0aW9uIGlzX2V4cHJlc3Npb24obW9kZSkge1xuICByZXR1cm4gaW5fYXJyYXkobW9kZSwgW01PREUuRXhwcmVzc2lvbiwgTU9ERS5Gb3JJbml0aWFsaXplciwgTU9ERS5Db25kaXRpb25hbF0pO1xufVxuXG5mdW5jdGlvbiBhbGxfbGluZXNfc3RhcnRfd2l0aChsaW5lcywgYykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxpbmUgPSBsaW5lc1tpXS50cmltKCk7XG4gICAgaWYgKGxpbmUuY2hhckF0KDApICE9PSBjKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBlYWNoX2xpbmVfbWF0Y2hlc19pbmRlbnQobGluZXMsIGluZGVudCkge1xuICB2YXIgaSA9IDAsXG4gICAgbGVuID0gbGluZXMubGVuZ3RoLFxuICAgIGxpbmU7XG4gIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBsaW5lID0gbGluZXNbaV07XG4gICAgLy8gYWxsb3cgZW1wdHkgbGluZXMgdG8gcGFzcyB0aHJvdWdoXG4gICAgaWYgKGxpbmUgJiYgbGluZS5pbmRleE9mKGluZGVudCkgIT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cblxuZnVuY3Rpb24gQmVhdXRpZmllcihzb3VyY2VfdGV4dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5fc291cmNlX3RleHQgPSBzb3VyY2VfdGV4dCB8fCAnJztcblxuICB0aGlzLl9vdXRwdXQgPSBudWxsO1xuICB0aGlzLl90b2tlbnMgPSBudWxsO1xuICB0aGlzLl9sYXN0X2xhc3RfdGV4dCA9IG51bGw7XG4gIHRoaXMuX2ZsYWdzID0gbnVsbDtcbiAgdGhpcy5fcHJldmlvdXNfZmxhZ3MgPSBudWxsO1xuXG4gIHRoaXMuX2ZsYWdfc3RvcmUgPSBudWxsO1xuICB0aGlzLl9vcHRpb25zID0gbmV3IE9wdGlvbnMob3B0aW9ucyk7XG59XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmNyZWF0ZV9mbGFncyA9IGZ1bmN0aW9uKGZsYWdzX2Jhc2UsIG1vZGUpIHtcbiAgdmFyIG5leHRfaW5kZW50X2xldmVsID0gMDtcbiAgaWYgKGZsYWdzX2Jhc2UpIHtcbiAgICBuZXh0X2luZGVudF9sZXZlbCA9IGZsYWdzX2Jhc2UuaW5kZW50YXRpb25fbGV2ZWw7XG4gICAgaWYgKCF0aGlzLl9vdXRwdXQuanVzdF9hZGRlZF9uZXdsaW5lKCkgJiZcbiAgICAgIGZsYWdzX2Jhc2UubGluZV9pbmRlbnRfbGV2ZWwgPiBuZXh0X2luZGVudF9sZXZlbCkge1xuICAgICAgbmV4dF9pbmRlbnRfbGV2ZWwgPSBmbGFnc19iYXNlLmxpbmVfaW5kZW50X2xldmVsO1xuICAgIH1cbiAgfVxuXG4gIHZhciBuZXh0X2ZsYWdzID0ge1xuICAgIG1vZGU6IG1vZGUsXG4gICAgcGFyZW50OiBmbGFnc19iYXNlLFxuICAgIGxhc3RfdG9rZW46IGZsYWdzX2Jhc2UgPyBmbGFnc19iYXNlLmxhc3RfdG9rZW4gOiBuZXcgVG9rZW4oVE9LRU4uU1RBUlRfQkxPQ0ssICcnKSwgLy8gbGFzdCB0b2tlbiB0ZXh0XG4gICAgbGFzdF93b3JkOiBmbGFnc19iYXNlID8gZmxhZ3NfYmFzZS5sYXN0X3dvcmQgOiAnJywgLy8gbGFzdCBUT0tFTi5XT1JEIHBhc3NlZFxuICAgIGRlY2xhcmF0aW9uX3N0YXRlbWVudDogZmFsc2UsXG4gICAgZGVjbGFyYXRpb25fYXNzaWdubWVudDogZmFsc2UsXG4gICAgbXVsdGlsaW5lX2ZyYW1lOiBmYWxzZSxcbiAgICBpbmxpbmVfZnJhbWU6IGZhbHNlLFxuICAgIGlmX2Jsb2NrOiBmYWxzZSxcbiAgICBlbHNlX2Jsb2NrOiBmYWxzZSxcbiAgICBjbGFzc19zdGFydF9ibG9jazogZmFsc2UsIC8vIGNsYXNzIEEgeyBJTlNJREUgSEVSRSB9IG9yIGNsYXNzIEIgZXh0ZW5kcyBDIHsgSU5TSURFIEhFUkUgfVxuICAgIGRvX2Jsb2NrOiBmYWxzZSxcbiAgICBkb193aGlsZTogZmFsc2UsXG4gICAgaW1wb3J0X2Jsb2NrOiBmYWxzZSxcbiAgICBpbl9jYXNlX3N0YXRlbWVudDogZmFsc2UsIC8vIHN3aXRjaCguLil7IElOU0lERSBIRVJFIH1cbiAgICBpbl9jYXNlOiBmYWxzZSwgLy8gd2UncmUgb24gdGhlIGV4YWN0IGxpbmUgd2l0aCBcImNhc2UgMDpcIlxuICAgIGNhc2VfYm9keTogZmFsc2UsIC8vIHRoZSBpbmRlbnRlZCBjYXNlLWFjdGlvbiBibG9ja1xuICAgIGNhc2VfYmxvY2s6IGZhbHNlLCAvLyB0aGUgaW5kZW50ZWQgY2FzZS1hY3Rpb24gYmxvY2sgaXMgd3JhcHBlZCB3aXRoIHt9XG4gICAgaW5kZW50YXRpb25fbGV2ZWw6IG5leHRfaW5kZW50X2xldmVsLFxuICAgIGFsaWdubWVudDogMCxcbiAgICBsaW5lX2luZGVudF9sZXZlbDogZmxhZ3NfYmFzZSA/IGZsYWdzX2Jhc2UubGluZV9pbmRlbnRfbGV2ZWwgOiBuZXh0X2luZGVudF9sZXZlbCxcbiAgICBzdGFydF9saW5lX2luZGV4OiB0aGlzLl9vdXRwdXQuZ2V0X2xpbmVfbnVtYmVyKCksXG4gICAgdGVybmFyeV9kZXB0aDogMFxuICB9O1xuICByZXR1cm4gbmV4dF9mbGFncztcbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLl9yZXNldCA9IGZ1bmN0aW9uKHNvdXJjZV90ZXh0KSB7XG4gIHZhciBiYXNlSW5kZW50U3RyaW5nID0gc291cmNlX3RleHQubWF0Y2goL15bXFx0IF0qLylbMF07XG5cbiAgdGhpcy5fbGFzdF9sYXN0X3RleHQgPSAnJzsgLy8gcHJlLWxhc3QgdG9rZW4gdGV4dFxuICB0aGlzLl9vdXRwdXQgPSBuZXcgT3V0cHV0KHRoaXMuX29wdGlvbnMsIGJhc2VJbmRlbnRTdHJpbmcpO1xuXG4gIC8vIElmIHRlc3RpbmcgdGhlIGlnbm9yZSBkaXJlY3RpdmUsIHN0YXJ0IHdpdGggb3V0cHV0IGRpc2FibGUgc2V0IHRvIHRydWVcbiAgdGhpcy5fb3V0cHV0LnJhdyA9IHRoaXMuX29wdGlvbnMudGVzdF9vdXRwdXRfcmF3O1xuXG5cbiAgLy8gU3RhY2sgb2YgcGFyc2luZy9mb3JtYXR0aW5nIHN0YXRlcywgaW5jbHVkaW5nIE1PREUuXG4gIC8vIFdlIHRva2VuaXplLCBwYXJzZSwgYW5kIG91dHB1dCBpbiBhbiBhbG1vc3QgcHVyZWx5IGEgZm9yd2FyZC1vbmx5IHN0cmVhbSBvZiB0b2tlbiBpbnB1dFxuICAvLyBhbmQgZm9ybWF0dGVkIG91dHB1dC4gIFRoaXMgbWFrZXMgdGhlIGJlYXV0aWZpZXIgbGVzcyBhY2N1cmF0ZSB0aGFuIGZ1bGwgcGFyc2Vyc1xuICAvLyBidXQgYWxzbyBmYXIgbW9yZSB0b2xlcmFudCBvZiBzeW50YXggZXJyb3JzLlxuICAvL1xuICAvLyBGb3IgZXhhbXBsZSwgdGhlIGRlZmF1bHQgbW9kZSBpcyBNT0RFLkJsb2NrU3RhdGVtZW50LiBJZiB3ZSBzZWUgYSAneycgd2UgcHVzaCBhIG5ldyBmcmFtZSBvZiB0eXBlXG4gIC8vIE1PREUuQmxvY2tTdGF0ZW1lbnQgb24gdGhlIHRoZSBzdGFjaywgZXZlbiB0aG91Z2ggaXQgY291bGQgYmUgb2JqZWN0IGxpdGVyYWwuICBJZiB3ZSBsYXRlclxuICAvLyBlbmNvdW50ZXIgYSBcIjpcIiwgd2UnbGwgc3dpdGNoIHRvIHRvIE1PREUuT2JqZWN0TGl0ZXJhbC4gIElmIHdlIHRoZW4gc2VlIGEgXCI7XCIsXG4gIC8vIG1vc3QgZnVsbCBwYXJzZXJzIHdvdWxkIGRpZSwgYnV0IHRoZSBiZWF1dGlmaWVyIGdyYWNlZnVsbHkgZmFsbHMgYmFjayB0b1xuICAvLyBNT0RFLkJsb2NrU3RhdGVtZW50IGFuZCBjb250aW51ZXMgb24uXG4gIHRoaXMuX2ZsYWdfc3RvcmUgPSBbXTtcbiAgdGhpcy5zZXRfbW9kZShNT0RFLkJsb2NrU3RhdGVtZW50KTtcbiAgdmFyIHRva2VuaXplciA9IG5ldyBUb2tlbml6ZXIoc291cmNlX3RleHQsIHRoaXMuX29wdGlvbnMpO1xuICB0aGlzLl90b2tlbnMgPSB0b2tlbml6ZXIudG9rZW5pemUoKTtcbiAgcmV0dXJuIHNvdXJjZV90ZXh0O1xufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuYmVhdXRpZnkgPSBmdW5jdGlvbigpIHtcbiAgLy8gaWYgZGlzYWJsZWQsIHJldHVybiB0aGUgaW5wdXQgdW5jaGFuZ2VkLlxuICBpZiAodGhpcy5fb3B0aW9ucy5kaXNhYmxlZCkge1xuICAgIHJldHVybiB0aGlzLl9zb3VyY2VfdGV4dDtcbiAgfVxuXG4gIHZhciBzd2VldF9jb2RlO1xuICB2YXIgc291cmNlX3RleHQgPSB0aGlzLl9yZXNldCh0aGlzLl9zb3VyY2VfdGV4dCk7XG5cbiAgdmFyIGVvbCA9IHRoaXMuX29wdGlvbnMuZW9sO1xuICBpZiAodGhpcy5fb3B0aW9ucy5lb2wgPT09ICdhdXRvJykge1xuICAgIGVvbCA9ICdcXG4nO1xuICAgIGlmIChzb3VyY2VfdGV4dCAmJiBhY29ybi5saW5lQnJlYWsudGVzdChzb3VyY2VfdGV4dCB8fCAnJykpIHtcbiAgICAgIGVvbCA9IHNvdXJjZV90ZXh0Lm1hdGNoKGFjb3JuLmxpbmVCcmVhaylbMF07XG4gICAgfVxuICB9XG5cbiAgdmFyIGN1cnJlbnRfdG9rZW4gPSB0aGlzLl90b2tlbnMubmV4dCgpO1xuICB3aGlsZSAoY3VycmVudF90b2tlbikge1xuICAgIHRoaXMuaGFuZGxlX3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuXG4gICAgdGhpcy5fbGFzdF9sYXN0X3RleHQgPSB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQ7XG4gICAgdGhpcy5fZmxhZ3MubGFzdF90b2tlbiA9IGN1cnJlbnRfdG9rZW47XG5cbiAgICBjdXJyZW50X3Rva2VuID0gdGhpcy5fdG9rZW5zLm5leHQoKTtcbiAgfVxuXG4gIHN3ZWV0X2NvZGUgPSB0aGlzLl9vdXRwdXQuZ2V0X2NvZGUoZW9sKTtcblxuICByZXR1cm4gc3dlZXRfY29kZTtcbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmhhbmRsZV90b2tlbiA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4sIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncykge1xuICBpZiAoY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5TVEFSVF9FWFBSKSB7XG4gICAgdGhpcy5oYW5kbGVfc3RhcnRfZXhwcihjdXJyZW50X3Rva2VuKTtcbiAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLkVORF9FWFBSKSB7XG4gICAgdGhpcy5oYW5kbGVfZW5kX2V4cHIoY3VycmVudF90b2tlbik7XG4gIH0gZWxzZSBpZiAoY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5TVEFSVF9CTE9DSykge1xuICAgIHRoaXMuaGFuZGxlX3N0YXJ0X2Jsb2NrKGN1cnJlbnRfdG9rZW4pO1xuICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uRU5EX0JMT0NLKSB7XG4gICAgdGhpcy5oYW5kbGVfZW5kX2Jsb2NrKGN1cnJlbnRfdG9rZW4pO1xuICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uV09SRCkge1xuICAgIHRoaXMuaGFuZGxlX3dvcmQoY3VycmVudF90b2tlbik7XG4gIH0gZWxzZSBpZiAoY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5SRVNFUlZFRCkge1xuICAgIHRoaXMuaGFuZGxlX3dvcmQoY3VycmVudF90b2tlbik7XG4gIH0gZWxzZSBpZiAoY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5TRU1JQ09MT04pIHtcbiAgICB0aGlzLmhhbmRsZV9zZW1pY29sb24oY3VycmVudF90b2tlbik7XG4gIH0gZWxzZSBpZiAoY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5TVFJJTkcpIHtcbiAgICB0aGlzLmhhbmRsZV9zdHJpbmcoY3VycmVudF90b2tlbik7XG4gIH0gZWxzZSBpZiAoY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5FUVVBTFMpIHtcbiAgICB0aGlzLmhhbmRsZV9lcXVhbHMoY3VycmVudF90b2tlbik7XG4gIH0gZWxzZSBpZiAoY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5PUEVSQVRPUikge1xuICAgIHRoaXMuaGFuZGxlX29wZXJhdG9yKGN1cnJlbnRfdG9rZW4pO1xuICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uQ09NTUEpIHtcbiAgICB0aGlzLmhhbmRsZV9jb21tYShjdXJyZW50X3Rva2VuKTtcbiAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLkJMT0NLX0NPTU1FTlQpIHtcbiAgICB0aGlzLmhhbmRsZV9ibG9ja19jb21tZW50KGN1cnJlbnRfdG9rZW4sIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyk7XG4gIH0gZWxzZSBpZiAoY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5DT01NRU5UKSB7XG4gICAgdGhpcy5oYW5kbGVfY29tbWVudChjdXJyZW50X3Rva2VuLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uRE9UKSB7XG4gICAgdGhpcy5oYW5kbGVfZG90KGN1cnJlbnRfdG9rZW4pO1xuICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uRU9GKSB7XG4gICAgdGhpcy5oYW5kbGVfZW9mKGN1cnJlbnRfdG9rZW4pO1xuICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uVU5LTk9XTikge1xuICAgIHRoaXMuaGFuZGxlX3Vua25vd24oY3VycmVudF90b2tlbiwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmhhbmRsZV91bmtub3duKGN1cnJlbnRfdG9rZW4sIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyk7XG4gIH1cbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4sIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncykge1xuICB2YXIgbmV3bGluZXMgPSBjdXJyZW50X3Rva2VuLm5ld2xpbmVzO1xuICB2YXIga2VlcF93aGl0ZXNwYWNlID0gdGhpcy5fb3B0aW9ucy5rZWVwX2FycmF5X2luZGVudGF0aW9uICYmIGlzX2FycmF5KHRoaXMuX2ZsYWdzLm1vZGUpO1xuXG4gIGlmIChjdXJyZW50X3Rva2VuLmNvbW1lbnRzX2JlZm9yZSkge1xuICAgIHZhciBjb21tZW50X3Rva2VuID0gY3VycmVudF90b2tlbi5jb21tZW50c19iZWZvcmUubmV4dCgpO1xuICAgIHdoaWxlIChjb21tZW50X3Rva2VuKSB7XG4gICAgICAvLyBUaGUgY2xlYW5lc3QgaGFuZGxpbmcgb2YgaW5saW5lIGNvbW1lbnRzIGlzIHRvIHRyZWF0IHRoZW0gYXMgdGhvdWdoIHRoZXkgYXJlbid0IHRoZXJlLlxuICAgICAgLy8gSnVzdCBjb250aW51ZSBmb3JtYXR0aW5nIGFuZCB0aGUgYmVoYXZpb3Igc2hvdWxkIGJlIGxvZ2ljYWwuXG4gICAgICAvLyBBbHNvIGlnbm9yZSB1bmtub3duIHRva2Vucy4gIEFnYWluLCB0aGlzIHNob3VsZCByZXN1bHQgaW4gYmV0dGVyIGJlaGF2aW9yLlxuICAgICAgdGhpcy5oYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY29tbWVudF90b2tlbiwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbiAgICAgIHRoaXMuaGFuZGxlX3Rva2VuKGNvbW1lbnRfdG9rZW4sIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyk7XG4gICAgICBjb21tZW50X3Rva2VuID0gY3VycmVudF90b2tlbi5jb21tZW50c19iZWZvcmUubmV4dCgpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChrZWVwX3doaXRlc3BhY2UpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld2xpbmVzOyBpICs9IDEpIHtcbiAgICAgIHRoaXMucHJpbnRfbmV3bGluZShpID4gMCwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoaXMuX29wdGlvbnMubWF4X3ByZXNlcnZlX25ld2xpbmVzICYmIG5ld2xpbmVzID4gdGhpcy5fb3B0aW9ucy5tYXhfcHJlc2VydmVfbmV3bGluZXMpIHtcbiAgICAgIG5ld2xpbmVzID0gdGhpcy5fb3B0aW9ucy5tYXhfcHJlc2VydmVfbmV3bGluZXM7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX29wdGlvbnMucHJlc2VydmVfbmV3bGluZXMpIHtcbiAgICAgIGlmIChuZXdsaW5lcyA+IDEpIHtcbiAgICAgICAgdGhpcy5wcmludF9uZXdsaW5lKGZhbHNlLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IG5ld2xpbmVzOyBqICs9IDEpIHtcbiAgICAgICAgICB0aGlzLnByaW50X25ld2xpbmUodHJ1ZSwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG52YXIgbmV3bGluZV9yZXN0cmljdGVkX3Rva2VucyA9IFsnYXN5bmMnLCAnYnJlYWsnLCAnY29udGludWUnLCAncmV0dXJuJywgJ3Rocm93JywgJ3lpZWxkJ107XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuLCBmb3JjZV9saW5ld3JhcCkge1xuICBmb3JjZV9saW5ld3JhcCA9IChmb3JjZV9saW5ld3JhcCA9PT0gdW5kZWZpbmVkKSA/IGZhbHNlIDogZm9yY2VfbGluZXdyYXA7XG5cbiAgLy8gTmV2ZXIgd3JhcCB0aGUgZmlyc3QgdG9rZW4gb24gYSBsaW5lXG4gIGlmICh0aGlzLl9vdXRwdXQuanVzdF9hZGRlZF9uZXdsaW5lKCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc2hvdWxkUHJlc2VydmVPckZvcmNlID0gKHRoaXMuX29wdGlvbnMucHJlc2VydmVfbmV3bGluZXMgJiYgY3VycmVudF90b2tlbi5uZXdsaW5lcykgfHwgZm9yY2VfbGluZXdyYXA7XG4gIHZhciBvcGVyYXRvckxvZ2ljQXBwbGllcyA9IGluX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCwgcG9zaXRpb25hYmxlX29wZXJhdG9ycykgfHxcbiAgICBpbl9hcnJheShjdXJyZW50X3Rva2VuLnRleHQsIHBvc2l0aW9uYWJsZV9vcGVyYXRvcnMpO1xuXG4gIGlmIChvcGVyYXRvckxvZ2ljQXBwbGllcykge1xuICAgIHZhciBzaG91bGRQcmludE9wZXJhdG9yTmV3bGluZSA9IChcbiAgICAgICAgaW5fYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0LCBwb3NpdGlvbmFibGVfb3BlcmF0b3JzKSAmJlxuICAgICAgICBpbl9hcnJheSh0aGlzLl9vcHRpb25zLm9wZXJhdG9yX3Bvc2l0aW9uLCBPUEVSQVRPUl9QT1NJVElPTl9CRUZPUkVfT1JfUFJFU0VSVkUpXG4gICAgICApIHx8XG4gICAgICBpbl9hcnJheShjdXJyZW50X3Rva2VuLnRleHQsIHBvc2l0aW9uYWJsZV9vcGVyYXRvcnMpO1xuICAgIHNob3VsZFByZXNlcnZlT3JGb3JjZSA9IHNob3VsZFByZXNlcnZlT3JGb3JjZSAmJiBzaG91bGRQcmludE9wZXJhdG9yTmV3bGluZTtcbiAgfVxuXG4gIGlmIChzaG91bGRQcmVzZXJ2ZU9yRm9yY2UpIHtcbiAgICB0aGlzLnByaW50X25ld2xpbmUoZmFsc2UsIHRydWUpO1xuICB9IGVsc2UgaWYgKHRoaXMuX29wdGlvbnMud3JhcF9saW5lX2xlbmd0aCkge1xuICAgIGlmIChyZXNlcnZlZF9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLCBuZXdsaW5lX3Jlc3RyaWN0ZWRfdG9rZW5zKSkge1xuICAgICAgLy8gVGhlc2UgdG9rZW5zIHNob3VsZCBuZXZlciBoYXZlIGEgbmV3bGluZSBpbnNlcnRlZFxuICAgICAgLy8gYmV0d2VlbiB0aGVtIGFuZCB0aGUgZm9sbG93aW5nIGV4cHJlc3Npb24uXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX291dHB1dC5zZXRfd3JhcF9wb2ludCgpO1xuICB9XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5wcmludF9uZXdsaW5lID0gZnVuY3Rpb24oZm9yY2VfbmV3bGluZSwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKSB7XG4gIGlmICghcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKSB7XG4gICAgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCAhPT0gJzsnICYmIHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCAhPT0gJywnICYmIHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCAhPT0gJz0nICYmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgIT09IFRPS0VOLk9QRVJBVE9SIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJy0tJyB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICcrKycpKSB7XG4gICAgICB2YXIgbmV4dF90b2tlbiA9IHRoaXMuX3Rva2Vucy5wZWVrKCk7XG4gICAgICB3aGlsZSAodGhpcy5fZmxhZ3MubW9kZSA9PT0gTU9ERS5TdGF0ZW1lbnQgJiZcbiAgICAgICAgISh0aGlzLl9mbGFncy5pZl9ibG9jayAmJiByZXNlcnZlZF93b3JkKG5leHRfdG9rZW4sICdlbHNlJykpICYmXG4gICAgICAgICF0aGlzLl9mbGFncy5kb19ibG9jaykge1xuICAgICAgICB0aGlzLnJlc3RvcmVfbW9kZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLl9vdXRwdXQuYWRkX25ld19saW5lKGZvcmNlX25ld2xpbmUpKSB7XG4gICAgdGhpcy5fZmxhZ3MubXVsdGlsaW5lX2ZyYW1lID0gdHJ1ZTtcbiAgfVxufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUucHJpbnRfdG9rZW5fbGluZV9pbmRlbnRhdGlvbiA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4pIHtcbiAgaWYgKHRoaXMuX291dHB1dC5qdXN0X2FkZGVkX25ld2xpbmUoKSkge1xuICAgIGlmICh0aGlzLl9vcHRpb25zLmtlZXBfYXJyYXlfaW5kZW50YXRpb24gJiZcbiAgICAgIGN1cnJlbnRfdG9rZW4ubmV3bGluZXMgJiZcbiAgICAgIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICdbJyB8fCBpc19hcnJheSh0aGlzLl9mbGFncy5tb2RlKSkpIHtcbiAgICAgIHRoaXMuX291dHB1dC5jdXJyZW50X2xpbmUuc2V0X2luZGVudCgtMSk7XG4gICAgICB0aGlzLl9vdXRwdXQuY3VycmVudF9saW5lLnB1c2goY3VycmVudF90b2tlbi53aGl0ZXNwYWNlX2JlZm9yZSk7XG4gICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9vdXRwdXQuc2V0X2luZGVudCh0aGlzLl9mbGFncy5pbmRlbnRhdGlvbl9sZXZlbCwgdGhpcy5fZmxhZ3MuYWxpZ25tZW50KSkge1xuICAgICAgdGhpcy5fZmxhZ3MubGluZV9pbmRlbnRfbGV2ZWwgPSB0aGlzLl9mbGFncy5pbmRlbnRhdGlvbl9sZXZlbDtcbiAgICB9XG4gIH1cbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLnByaW50X3Rva2VuID0gZnVuY3Rpb24oY3VycmVudF90b2tlbikge1xuICBpZiAodGhpcy5fb3V0cHV0LnJhdykge1xuICAgIHRoaXMuX291dHB1dC5hZGRfcmF3X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0aGlzLl9vcHRpb25zLmNvbW1hX2ZpcnN0ICYmIGN1cnJlbnRfdG9rZW4ucHJldmlvdXMgJiYgY3VycmVudF90b2tlbi5wcmV2aW91cy50eXBlID09PSBUT0tFTi5DT01NQSAmJlxuICAgIHRoaXMuX291dHB1dC5qdXN0X2FkZGVkX25ld2xpbmUoKSkge1xuICAgIGlmICh0aGlzLl9vdXRwdXQucHJldmlvdXNfbGluZS5sYXN0KCkgPT09ICcsJykge1xuICAgICAgdmFyIHBvcHBlZCA9IHRoaXMuX291dHB1dC5wcmV2aW91c19saW5lLnBvcCgpO1xuICAgICAgLy8gaWYgdGhlIGNvbW1hIHdhcyBhbHJlYWR5IGF0IHRoZSBzdGFydCBvZiB0aGUgbGluZSxcbiAgICAgIC8vIHB1bGwgYmFjayBvbnRvIHRoYXQgbGluZSBhbmQgcmVwcmludCB0aGUgaW5kZW50YXRpb25cbiAgICAgIGlmICh0aGlzLl9vdXRwdXQucHJldmlvdXNfbGluZS5pc19lbXB0eSgpKSB7XG4gICAgICAgIHRoaXMuX291dHB1dC5wcmV2aW91c19saW5lLnB1c2gocG9wcGVkKTtcbiAgICAgICAgdGhpcy5fb3V0cHV0LnRyaW0odHJ1ZSk7XG4gICAgICAgIHRoaXMuX291dHB1dC5jdXJyZW50X2xpbmUucG9wKCk7XG4gICAgICAgIHRoaXMuX291dHB1dC50cmltKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFkZCB0aGUgY29tbWEgaW4gZnJvbnQgb2YgdGhlIG5leHQgdG9rZW5cbiAgICAgIHRoaXMucHJpbnRfdG9rZW5fbGluZV9pbmRlbnRhdGlvbihjdXJyZW50X3Rva2VuKTtcbiAgICAgIHRoaXMuX291dHB1dC5hZGRfdG9rZW4oJywnKTtcbiAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMucHJpbnRfdG9rZW5fbGluZV9pbmRlbnRhdGlvbihjdXJyZW50X3Rva2VuKTtcbiAgdGhpcy5fb3V0cHV0Lm5vbl9icmVha2luZ19zcGFjZSA9IHRydWU7XG4gIHRoaXMuX291dHB1dC5hZGRfdG9rZW4oY3VycmVudF90b2tlbi50ZXh0KTtcbiAgaWYgKHRoaXMuX291dHB1dC5wcmV2aW91c190b2tlbl93cmFwcGVkKSB7XG4gICAgdGhpcy5fZmxhZ3MubXVsdGlsaW5lX2ZyYW1lID0gdHJ1ZTtcbiAgfVxufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuaW5kZW50ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2ZsYWdzLmluZGVudGF0aW9uX2xldmVsICs9IDE7XG4gIHRoaXMuX291dHB1dC5zZXRfaW5kZW50KHRoaXMuX2ZsYWdzLmluZGVudGF0aW9uX2xldmVsLCB0aGlzLl9mbGFncy5hbGlnbm1lbnQpO1xufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuZGVpbmRlbnQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX2ZsYWdzLmluZGVudGF0aW9uX2xldmVsID4gMCAmJlxuICAgICgoIXRoaXMuX2ZsYWdzLnBhcmVudCkgfHwgdGhpcy5fZmxhZ3MuaW5kZW50YXRpb25fbGV2ZWwgPiB0aGlzLl9mbGFncy5wYXJlbnQuaW5kZW50YXRpb25fbGV2ZWwpKSB7XG4gICAgdGhpcy5fZmxhZ3MuaW5kZW50YXRpb25fbGV2ZWwgLT0gMTtcbiAgICB0aGlzLl9vdXRwdXQuc2V0X2luZGVudCh0aGlzLl9mbGFncy5pbmRlbnRhdGlvbl9sZXZlbCwgdGhpcy5fZmxhZ3MuYWxpZ25tZW50KTtcbiAgfVxufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuc2V0X21vZGUgPSBmdW5jdGlvbihtb2RlKSB7XG4gIGlmICh0aGlzLl9mbGFncykge1xuICAgIHRoaXMuX2ZsYWdfc3RvcmUucHVzaCh0aGlzLl9mbGFncyk7XG4gICAgdGhpcy5fcHJldmlvdXNfZmxhZ3MgPSB0aGlzLl9mbGFncztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9wcmV2aW91c19mbGFncyA9IHRoaXMuY3JlYXRlX2ZsYWdzKG51bGwsIG1vZGUpO1xuICB9XG5cbiAgdGhpcy5fZmxhZ3MgPSB0aGlzLmNyZWF0ZV9mbGFncyh0aGlzLl9wcmV2aW91c19mbGFncywgbW9kZSk7XG4gIHRoaXMuX291dHB1dC5zZXRfaW5kZW50KHRoaXMuX2ZsYWdzLmluZGVudGF0aW9uX2xldmVsLCB0aGlzLl9mbGFncy5hbGlnbm1lbnQpO1xufTtcblxuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5yZXN0b3JlX21vZGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX2ZsYWdfc3RvcmUubGVuZ3RoID4gMCkge1xuICAgIHRoaXMuX3ByZXZpb3VzX2ZsYWdzID0gdGhpcy5fZmxhZ3M7XG4gICAgdGhpcy5fZmxhZ3MgPSB0aGlzLl9mbGFnX3N0b3JlLnBvcCgpO1xuICAgIGlmICh0aGlzLl9wcmV2aW91c19mbGFncy5tb2RlID09PSBNT0RFLlN0YXRlbWVudCkge1xuICAgICAgcmVtb3ZlX3JlZHVuZGFudF9pbmRlbnRhdGlvbih0aGlzLl9vdXRwdXQsIHRoaXMuX3ByZXZpb3VzX2ZsYWdzKTtcbiAgICB9XG4gICAgdGhpcy5fb3V0cHV0LnNldF9pbmRlbnQodGhpcy5fZmxhZ3MuaW5kZW50YXRpb25fbGV2ZWwsIHRoaXMuX2ZsYWdzLmFsaWdubWVudCk7XG4gIH1cbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLnN0YXJ0X29mX29iamVjdF9wcm9wZXJ0eSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fZmxhZ3MucGFyZW50Lm1vZGUgPT09IE1PREUuT2JqZWN0TGl0ZXJhbCAmJiB0aGlzLl9mbGFncy5tb2RlID09PSBNT0RFLlN0YXRlbWVudCAmJiAoXG4gICAgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJzonICYmIHRoaXMuX2ZsYWdzLnRlcm5hcnlfZGVwdGggPT09IDApIHx8IChyZXNlcnZlZF9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLCBbJ2dldCcsICdzZXQnXSkpKTtcbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLnN0YXJ0X29mX3N0YXRlbWVudCA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4pIHtcbiAgdmFyIHN0YXJ0ID0gZmFsc2U7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgcmVzZXJ2ZWRfYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbiwgWyd2YXInLCAnbGV0JywgJ2NvbnN0J10pICYmIGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uV09SRDtcbiAgc3RhcnQgPSBzdGFydCB8fCByZXNlcnZlZF93b3JkKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4sICdkbycpO1xuICBzdGFydCA9IHN0YXJ0IHx8ICghKHRoaXMuX2ZsYWdzLnBhcmVudC5tb2RlID09PSBNT0RFLk9iamVjdExpdGVyYWwgJiYgdGhpcy5fZmxhZ3MubW9kZSA9PT0gTU9ERS5TdGF0ZW1lbnQpKSAmJiByZXNlcnZlZF9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLCBuZXdsaW5lX3Jlc3RyaWN0ZWRfdG9rZW5zKSAmJiAhY3VycmVudF90b2tlbi5uZXdsaW5lcztcbiAgc3RhcnQgPSBzdGFydCB8fCByZXNlcnZlZF93b3JkKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4sICdlbHNlJykgJiZcbiAgICAhKHJlc2VydmVkX3dvcmQoY3VycmVudF90b2tlbiwgJ2lmJykgJiYgIWN1cnJlbnRfdG9rZW4uY29tbWVudHNfYmVmb3JlKTtcbiAgc3RhcnQgPSBzdGFydCB8fCAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5FTkRfRVhQUiAmJiAodGhpcy5fcHJldmlvdXNfZmxhZ3MubW9kZSA9PT0gTU9ERS5Gb3JJbml0aWFsaXplciB8fCB0aGlzLl9wcmV2aW91c19mbGFncy5tb2RlID09PSBNT0RFLkNvbmRpdGlvbmFsKSk7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uV09SRCAmJiB0aGlzLl9mbGFncy5tb2RlID09PSBNT0RFLkJsb2NrU3RhdGVtZW50ICYmXG4gICAgIXRoaXMuX2ZsYWdzLmluX2Nhc2UgJiZcbiAgICAhKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJy0tJyB8fCBjdXJyZW50X3Rva2VuLnRleHQgPT09ICcrKycpICYmXG4gICAgdGhpcy5fbGFzdF9sYXN0X3RleHQgIT09ICdmdW5jdGlvbicgJiZcbiAgICBjdXJyZW50X3Rva2VuLnR5cGUgIT09IFRPS0VOLldPUkQgJiYgY3VycmVudF90b2tlbi50eXBlICE9PSBUT0tFTi5SRVNFUlZFRCk7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgKHRoaXMuX2ZsYWdzLm1vZGUgPT09IE1PREUuT2JqZWN0TGl0ZXJhbCAmJiAoXG4gICAgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJzonICYmIHRoaXMuX2ZsYWdzLnRlcm5hcnlfZGVwdGggPT09IDApIHx8IHJlc2VydmVkX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4sIFsnZ2V0JywgJ3NldCddKSkpO1xuXG4gIGlmIChzdGFydCkge1xuICAgIHRoaXMuc2V0X21vZGUoTU9ERS5TdGF0ZW1lbnQpO1xuICAgIHRoaXMuaW5kZW50KCk7XG5cbiAgICB0aGlzLmhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhjdXJyZW50X3Rva2VuLCB0cnVlKTtcblxuICAgIC8vIElzc3VlICMyNzY6XG4gICAgLy8gSWYgc3RhcnRpbmcgYSBuZXcgc3RhdGVtZW50IHdpdGggW2lmLCBmb3IsIHdoaWxlLCBkb10sIHB1c2ggdG8gYSBuZXcgbGluZS5cbiAgICAvLyBpZiAoYSkgaWYgKGIpIGlmKGMpIGQoKTsgZWxzZSBlKCk7IGVsc2UgZigpO1xuICAgIGlmICghdGhpcy5zdGFydF9vZl9vYmplY3RfcHJvcGVydHkoKSkge1xuICAgICAgdGhpcy5hbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKGN1cnJlbnRfdG9rZW4sXG4gICAgICAgIHJlc2VydmVkX2FycmF5KGN1cnJlbnRfdG9rZW4sIFsnZG8nLCAnZm9yJywgJ2lmJywgJ3doaWxlJ10pKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuaGFuZGxlX3N0YXJ0X2V4cHIgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7XG4gIC8vIFRoZSBjb25kaXRpb25hbCBzdGFydHMgdGhlIHN0YXRlbWVudCBpZiBhcHByb3ByaWF0ZS5cbiAgaWYgKCF0aGlzLnN0YXJ0X29mX3N0YXRlbWVudChjdXJyZW50X3Rva2VuKSkge1xuICAgIHRoaXMuaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzKGN1cnJlbnRfdG9rZW4pO1xuICB9XG5cbiAgdmFyIG5leHRfbW9kZSA9IE1PREUuRXhwcmVzc2lvbjtcbiAgaWYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJ1snKSB7XG5cbiAgICBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5XT1JEIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJyknKSB7XG4gICAgICAvLyB0aGlzIGlzIGFycmF5IGluZGV4IHNwZWNpZmllciwgYnJlYWsgaW1tZWRpYXRlbHlcbiAgICAgIC8vIGFbeF0sIGZuKClbeF1cbiAgICAgIGlmIChyZXNlcnZlZF9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLCBsaW5lX3N0YXJ0ZXJzKSkge1xuICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG4gICAgICB0aGlzLnNldF9tb2RlKG5leHRfbW9kZSk7XG4gICAgICB0aGlzLmluZGVudCgpO1xuICAgICAgaWYgKHRoaXMuX29wdGlvbnMuc3BhY2VfaW5fcGFyZW4pIHtcbiAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbmV4dF9tb2RlID0gTU9ERS5BcnJheUxpdGVyYWw7XG4gICAgaWYgKGlzX2FycmF5KHRoaXMuX2ZsYWdzLm1vZGUpKSB7XG4gICAgICBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnWycgfHxcbiAgICAgICAgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJywnICYmICh0aGlzLl9sYXN0X2xhc3RfdGV4dCA9PT0gJ10nIHx8IHRoaXMuX2xhc3RfbGFzdF90ZXh0ID09PSAnfScpKSkge1xuICAgICAgICAvLyBdLCBbIGdvZXMgdG8gbmV3IGxpbmVcbiAgICAgICAgLy8gfSwgWyBnb2VzIHRvIG5ldyBsaW5lXG4gICAgICAgIGlmICghdGhpcy5fb3B0aW9ucy5rZWVwX2FycmF5X2luZGVudGF0aW9uKSB7XG4gICAgICAgICAgdGhpcy5wcmludF9uZXdsaW5lKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWluX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSwgW1RPS0VOLlNUQVJUX0VYUFIsIFRPS0VOLkVORF9FWFBSLCBUT0tFTi5XT1JELCBUT0tFTi5PUEVSQVRPUiwgVE9LRU4uRE9UXSkpIHtcbiAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5SRVNFUlZFRCkge1xuICAgICAgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJ2ZvcicpIHtcbiAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRoaXMuX29wdGlvbnMuc3BhY2VfYmVmb3JlX2NvbmRpdGlvbmFsO1xuICAgICAgICBuZXh0X21vZGUgPSBNT0RFLkZvckluaXRpYWxpemVyO1xuICAgICAgfSBlbHNlIGlmIChpbl9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQsIFsnaWYnLCAnd2hpbGUnLCAnc3dpdGNoJ10pKSB7XG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0aGlzLl9vcHRpb25zLnNwYWNlX2JlZm9yZV9jb25kaXRpb25hbDtcbiAgICAgICAgbmV4dF9tb2RlID0gTU9ERS5Db25kaXRpb25hbDtcbiAgICAgIH0gZWxzZSBpZiAoaW5fYXJyYXkodGhpcy5fZmxhZ3MubGFzdF93b3JkLCBbJ2F3YWl0JywgJ2FzeW5jJ10pKSB7XG4gICAgICAgIC8vIFNob3VsZCBiZSBhIHNwYWNlIGJldHdlZW4gYXdhaXQgYW5kIGFuIElJRkUsIG9yIGFzeW5jIGFuZCBhbiBhcnJvdyBmdW5jdGlvblxuICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnaW1wb3J0JyAmJiBjdXJyZW50X3Rva2VuLndoaXRlc3BhY2VfYmVmb3JlID09PSAnJykge1xuICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGluX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCwgbGluZV9zdGFydGVycykgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnY2F0Y2gnKSB7XG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5FUVVBTFMgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5PUEVSQVRPUikge1xuICAgICAgLy8gU3VwcG9ydCBvZiB0aGlzIGtpbmQgb2YgbmV3bGluZSBwcmVzZXJ2YXRpb24uXG4gICAgICAvLyBhID0gKGIgJiZcbiAgICAgIC8vICAgICAoYyB8fCBkKSk7XG4gICAgICBpZiAoIXRoaXMuc3RhcnRfb2Zfb2JqZWN0X3Byb3BlcnR5KCkpIHtcbiAgICAgICAgdGhpcy5hbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKGN1cnJlbnRfdG9rZW4pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5XT1JEKSB7XG4gICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gZmFsc2U7XG5cbiAgICAgIC8vIGZ1bmN0aW9uIG5hbWUoKSB2cyBmdW5jdGlvbiBuYW1lICgpXG4gICAgICAvLyBmdW5jdGlvbiogbmFtZSgpIHZzIGZ1bmN0aW9uKiBuYW1lICgpXG4gICAgICAvLyBhc3luYyBuYW1lKCkgdnMgYXN5bmMgbmFtZSAoKVxuICAgICAgLy8gSW4gRVM2LCB5b3UgY2FuIGFsc28gZGVmaW5lIHRoZSBtZXRob2QgcHJvcGVydGllcyBvZiBhbiBvYmplY3RcbiAgICAgIC8vIHZhciBvYmogPSB7YTogZnVuY3Rpb24oKSB7fX1cbiAgICAgIC8vIEl0IGNhbiBiZSBhYmJyZXZpYXRlZFxuICAgICAgLy8gdmFyIG9iaiA9IHthKCkge319XG4gICAgICAvLyB2YXIgb2JqID0geyBhKCkge319IHZzIHZhciBvYmogPSB7IGEgKCkge319XG4gICAgICAvLyB2YXIgb2JqID0geyAqIGEoKSB7fX0gdnMgdmFyIG9iaiA9IHsgKiBhICgpIHt9fVxuICAgICAgdmFyIHBlZWtfYmFja190d28gPSB0aGlzLl90b2tlbnMucGVlaygtMyk7XG4gICAgICBpZiAodGhpcy5fb3B0aW9ucy5zcGFjZV9hZnRlcl9uYW1lZF9mdW5jdGlvbiAmJiBwZWVrX2JhY2tfdHdvKSB7XG4gICAgICAgIC8vIHBlZWsgc3RhcnRzIGF0IG5leHQgY2hhcmFjdGVyIHNvIC0xIGlzIGN1cnJlbnQgdG9rZW5cbiAgICAgICAgdmFyIHBlZWtfYmFja190aHJlZSA9IHRoaXMuX3Rva2Vucy5wZWVrKC00KTtcbiAgICAgICAgaWYgKHJlc2VydmVkX2FycmF5KHBlZWtfYmFja190d28sIFsnYXN5bmMnLCAnZnVuY3Rpb24nXSkgfHxcbiAgICAgICAgICAocGVla19iYWNrX3R3by50ZXh0ID09PSAnKicgJiYgcmVzZXJ2ZWRfYXJyYXkocGVla19iYWNrX3RocmVlLCBbJ2FzeW5jJywgJ2Z1bmN0aW9uJ10pKSkge1xuICAgICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2ZsYWdzLm1vZGUgPT09IE1PREUuT2JqZWN0TGl0ZXJhbCkge1xuICAgICAgICAgIGlmICgocGVla19iYWNrX3R3by50ZXh0ID09PSAneycgfHwgcGVla19iYWNrX3R3by50ZXh0ID09PSAnLCcpIHx8XG4gICAgICAgICAgICAocGVla19iYWNrX3R3by50ZXh0ID09PSAnKicgJiYgKHBlZWtfYmFja190aHJlZS50ZXh0ID09PSAneycgfHwgcGVla19iYWNrX3RocmVlLnRleHQgPT09ICcsJykpKSB7XG4gICAgICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fZmxhZ3MucGFyZW50ICYmIHRoaXMuX2ZsYWdzLnBhcmVudC5jbGFzc19zdGFydF9ibG9jaykge1xuICAgICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN1cHBvcnQgcHJlc2VydmluZyB3cmFwcGVkIGFycm93IGZ1bmN0aW9uIGV4cHJlc3Npb25zXG4gICAgICAvLyBhLmIoJ2MnLFxuICAgICAgLy8gICAgICgpID0+IGQuZVxuICAgICAgLy8gKVxuICAgICAgdGhpcy5hbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKGN1cnJlbnRfdG9rZW4pO1xuICAgIH1cblxuICAgIC8vIGZ1bmN0aW9uKCkgdnMgZnVuY3Rpb24gKClcbiAgICAvLyB5aWVsZCooKSB2cyB5aWVsZCogKClcbiAgICAvLyBmdW5jdGlvbiooKSB2cyBmdW5jdGlvbiogKClcbiAgICBpZiAoKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uUkVTRVJWRUQgJiYgKHRoaXMuX2ZsYWdzLmxhc3Rfd29yZCA9PT0gJ2Z1bmN0aW9uJyB8fCB0aGlzLl9mbGFncy5sYXN0X3dvcmQgPT09ICd0eXBlb2YnKSkgfHxcbiAgICAgICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICcqJyAmJlxuICAgICAgICAoaW5fYXJyYXkodGhpcy5fbGFzdF9sYXN0X3RleHQsIFsnZnVuY3Rpb24nLCAneWllbGQnXSkgfHxcbiAgICAgICAgICAodGhpcy5fZmxhZ3MubW9kZSA9PT0gTU9ERS5PYmplY3RMaXRlcmFsICYmIGluX2FycmF5KHRoaXMuX2xhc3RfbGFzdF90ZXh0LCBbJ3snLCAnLCddKSkpKSkge1xuICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRoaXMuX29wdGlvbnMuc3BhY2VfYWZ0ZXJfYW5vbl9mdW5jdGlvbjtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnOycgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5TVEFSVF9CTE9DSykge1xuICAgIHRoaXMucHJpbnRfbmV3bGluZSgpO1xuICB9IGVsc2UgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uRU5EX0VYUFIgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5TVEFSVF9FWFBSIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uRU5EX0JMT0NLIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJy4nIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uQ09NTUEpIHtcbiAgICAvLyBkbyBub3RoaW5nIG9uICgoIGFuZCApKCBhbmQgXVsgYW5kIF0oIGFuZCAuKFxuICAgIC8vIFRPRE86IENvbnNpZGVyIHdoZXRoZXIgZm9yY2luZyB0aGlzIGlzIHJlcXVpcmVkLiAgUmV2aWV3IGZhaWxpbmcgdGVzdHMgd2hlbiByZW1vdmVkLlxuICAgIHRoaXMuYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShjdXJyZW50X3Rva2VuLCBjdXJyZW50X3Rva2VuLm5ld2xpbmVzKTtcbiAgfVxuXG4gIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG4gIHRoaXMuc2V0X21vZGUobmV4dF9tb2RlKTtcbiAgaWYgKHRoaXMuX29wdGlvbnMuc3BhY2VfaW5fcGFyZW4pIHtcbiAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIEluIGFsbCBjYXNlcywgaWYgd2UgbmV3bGluZSB3aGlsZSBpbnNpZGUgYW4gZXhwcmVzc2lvbiBpdCBzaG91bGQgYmUgaW5kZW50ZWQuXG4gIHRoaXMuaW5kZW50KCk7XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5oYW5kbGVfZW5kX2V4cHIgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7XG4gIC8vIHN0YXRlbWVudHMgaW5zaWRlIGV4cHJlc3Npb25zIGFyZSBub3QgdmFsaWQgc3ludGF4LCBidXQuLi5cbiAgLy8gc3RhdGVtZW50cyBtdXN0IGFsbCBiZSBjbG9zZWQgd2hlbiB0aGVpciBjb250YWluZXIgY2xvc2VzXG4gIHdoaWxlICh0aGlzLl9mbGFncy5tb2RlID09PSBNT0RFLlN0YXRlbWVudCkge1xuICAgIHRoaXMucmVzdG9yZV9tb2RlKCk7XG4gIH1cblxuICB0aGlzLmhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhjdXJyZW50X3Rva2VuKTtcblxuICBpZiAodGhpcy5fZmxhZ3MubXVsdGlsaW5lX2ZyYW1lKSB7XG4gICAgdGhpcy5hbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKGN1cnJlbnRfdG9rZW4sXG4gICAgICBjdXJyZW50X3Rva2VuLnRleHQgPT09ICddJyAmJiBpc19hcnJheSh0aGlzLl9mbGFncy5tb2RlKSAmJiAhdGhpcy5fb3B0aW9ucy5rZWVwX2FycmF5X2luZGVudGF0aW9uKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9vcHRpb25zLnNwYWNlX2luX3BhcmVuKSB7XG4gICAgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uU1RBUlRfRVhQUiAmJiAhdGhpcy5fb3B0aW9ucy5zcGFjZV9pbl9lbXB0eV9wYXJlbikge1xuICAgICAgLy8gKCkgW10gbm8gaW5uZXIgc3BhY2UgaW4gZW1wdHkgcGFyZW5zIGxpa2UgdGhlc2UsIGV2ZXIsIHJlZiAjMzIwXG4gICAgICB0aGlzLl9vdXRwdXQudHJpbSgpO1xuICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgdGhpcy5kZWluZGVudCgpO1xuICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuICB0aGlzLnJlc3RvcmVfbW9kZSgpO1xuXG4gIHJlbW92ZV9yZWR1bmRhbnRfaW5kZW50YXRpb24odGhpcy5fb3V0cHV0LCB0aGlzLl9wcmV2aW91c19mbGFncyk7XG5cbiAgLy8gZG8ge30gd2hpbGUgKCkgLy8gbm8gc3RhdGVtZW50IHJlcXVpcmVkIGFmdGVyXG4gIGlmICh0aGlzLl9mbGFncy5kb193aGlsZSAmJiB0aGlzLl9wcmV2aW91c19mbGFncy5tb2RlID09PSBNT0RFLkNvbmRpdGlvbmFsKSB7XG4gICAgdGhpcy5fcHJldmlvdXNfZmxhZ3MubW9kZSA9IE1PREUuRXhwcmVzc2lvbjtcbiAgICB0aGlzLl9mbGFncy5kb19ibG9jayA9IGZhbHNlO1xuICAgIHRoaXMuX2ZsYWdzLmRvX3doaWxlID0gZmFsc2U7XG5cbiAgfVxufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuaGFuZGxlX3N0YXJ0X2Jsb2NrID0gZnVuY3Rpb24oY3VycmVudF90b2tlbikge1xuICB0aGlzLmhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhjdXJyZW50X3Rva2VuKTtcblxuICAvLyBDaGVjayBpZiB0aGlzIGlzIHNob3VsZCBiZSB0cmVhdGVkIGFzIGEgT2JqZWN0TGl0ZXJhbFxuICB2YXIgbmV4dF90b2tlbiA9IHRoaXMuX3Rva2Vucy5wZWVrKCk7XG4gIHZhciBzZWNvbmRfdG9rZW4gPSB0aGlzLl90b2tlbnMucGVlaygxKTtcbiAgaWYgKHRoaXMuX2ZsYWdzLmxhc3Rfd29yZCA9PT0gJ3N3aXRjaCcgJiYgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5FTkRfRVhQUikge1xuICAgIHRoaXMuc2V0X21vZGUoTU9ERS5CbG9ja1N0YXRlbWVudCk7XG4gICAgdGhpcy5fZmxhZ3MuaW5fY2FzZV9zdGF0ZW1lbnQgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHRoaXMuX2ZsYWdzLmNhc2VfYm9keSkge1xuICAgIHRoaXMuc2V0X21vZGUoTU9ERS5CbG9ja1N0YXRlbWVudCk7XG4gIH0gZWxzZSBpZiAoc2Vjb25kX3Rva2VuICYmIChcbiAgICAgIChpbl9hcnJheShzZWNvbmRfdG9rZW4udGV4dCwgWyc6JywgJywnXSkgJiYgaW5fYXJyYXkobmV4dF90b2tlbi50eXBlLCBbVE9LRU4uU1RSSU5HLCBUT0tFTi5XT1JELCBUT0tFTi5SRVNFUlZFRF0pKSB8fFxuICAgICAgKGluX2FycmF5KG5leHRfdG9rZW4udGV4dCwgWydnZXQnLCAnc2V0JywgJy4uLiddKSAmJiBpbl9hcnJheShzZWNvbmRfdG9rZW4udHlwZSwgW1RPS0VOLldPUkQsIFRPS0VOLlJFU0VSVkVEXSkpXG4gICAgKSkge1xuICAgIC8vIFdlIGRvbid0IHN1cHBvcnQgVHlwZVNjcmlwdCxidXQgd2UgZGlkbid0IGJyZWFrIGl0IGZvciBhIHZlcnkgbG9uZyB0aW1lLlxuICAgIC8vIFdlJ2xsIHRyeSB0byBrZWVwIG5vdCBicmVha2luZyBpdC5cbiAgICBpZiAoaW5fYXJyYXkodGhpcy5fbGFzdF9sYXN0X3RleHQsIFsnY2xhc3MnLCAnaW50ZXJmYWNlJ10pICYmICFpbl9hcnJheShzZWNvbmRfdG9rZW4udGV4dCwgWyc6JywgJywnXSkpIHtcbiAgICAgIHRoaXMuc2V0X21vZGUoTU9ERS5CbG9ja1N0YXRlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0X21vZGUoTU9ERS5PYmplY3RMaXRlcmFsKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5PUEVSQVRPUiAmJiB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICc9PicpIHtcbiAgICAvLyBhcnJvdyBmdW5jdGlvbjogKHBhcmFtMSwgcGFyYW1OKSA9PiB7IHN0YXRlbWVudHMgfVxuICAgIHRoaXMuc2V0X21vZGUoTU9ERS5CbG9ja1N0YXRlbWVudCk7XG4gIH0gZWxzZSBpZiAoaW5fYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlLCBbVE9LRU4uRVFVQUxTLCBUT0tFTi5TVEFSVF9FWFBSLCBUT0tFTi5DT01NQSwgVE9LRU4uT1BFUkFUT1JdKSB8fFxuICAgIHJlc2VydmVkX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4sIFsncmV0dXJuJywgJ3Rocm93JywgJ2ltcG9ydCcsICdkZWZhdWx0J10pXG4gICkge1xuICAgIC8vIERldGVjdGluZyBzaG9ydGhhbmQgZnVuY3Rpb24gc3ludGF4IGlzIGRpZmZpY3VsdCBieSBzY2FubmluZyBmb3J3YXJkLFxuICAgIC8vICAgICBzbyBjaGVjayB0aGUgc3Vycm91bmRpbmcgY29udGV4dC5cbiAgICAvLyBJZiB0aGUgYmxvY2sgaXMgYmVpbmcgcmV0dXJuZWQsIGltcG9ydGVkLCBleHBvcnQgZGVmYXVsdCwgcGFzc2VkIGFzIGFyZyxcbiAgICAvLyAgICAgYXNzaWduZWQgd2l0aCA9IG9yIGFzc2lnbmVkIGluIGEgbmVzdGVkIG9iamVjdCwgdHJlYXQgYXMgYW4gT2JqZWN0TGl0ZXJhbC5cbiAgICB0aGlzLnNldF9tb2RlKE1PREUuT2JqZWN0TGl0ZXJhbCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zZXRfbW9kZShNT0RFLkJsb2NrU3RhdGVtZW50KTtcbiAgfVxuXG4gIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuKSB7XG4gICAgaWYgKHJlc2VydmVkX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4ucHJldmlvdXMsIFsnY2xhc3MnLCAnZXh0ZW5kcyddKSkge1xuICAgICAgdGhpcy5fZmxhZ3MuY2xhc3Nfc3RhcnRfYmxvY2sgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBlbXB0eV9icmFjZXMgPSAhbmV4dF90b2tlbi5jb21tZW50c19iZWZvcmUgJiYgbmV4dF90b2tlbi50ZXh0ID09PSAnfSc7XG4gIHZhciBlbXB0eV9hbm9ueW1vdXNfZnVuY3Rpb24gPSBlbXB0eV9icmFjZXMgJiYgdGhpcy5fZmxhZ3MubGFzdF93b3JkID09PSAnZnVuY3Rpb24nICYmXG4gICAgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5FTkRfRVhQUjtcblxuICBpZiAodGhpcy5fb3B0aW9ucy5icmFjZV9wcmVzZXJ2ZV9pbmxpbmUpIC8vIGNoZWNrIGZvciBpbmxpbmUsIHNldCBpbmxpbmVfZnJhbWUgaWYgc29cbiAge1xuICAgIC8vIHNlYXJjaCBmb3J3YXJkIGZvciBhIG5ld2xpbmUgd2FudGVkIGluc2lkZSB0aGlzIGJsb2NrXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgY2hlY2tfdG9rZW4gPSBudWxsO1xuICAgIHRoaXMuX2ZsYWdzLmlubGluZV9mcmFtZSA9IHRydWU7XG4gICAgZG8ge1xuICAgICAgaW5kZXggKz0gMTtcbiAgICAgIGNoZWNrX3Rva2VuID0gdGhpcy5fdG9rZW5zLnBlZWsoaW5kZXggLSAxKTtcbiAgICAgIGlmIChjaGVja190b2tlbi5uZXdsaW5lcykge1xuICAgICAgICB0aGlzLl9mbGFncy5pbmxpbmVfZnJhbWUgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoY2hlY2tfdG9rZW4udHlwZSAhPT0gVE9LRU4uRU9GICYmXG4gICAgICAhKGNoZWNrX3Rva2VuLnR5cGUgPT09IFRPS0VOLkVORF9CTE9DSyAmJiBjaGVja190b2tlbi5vcGVuZWQgPT09IGN1cnJlbnRfdG9rZW4pKTtcbiAgfVxuXG4gIGlmICgodGhpcy5fb3B0aW9ucy5icmFjZV9zdHlsZSA9PT0gXCJleHBhbmRcIiB8fFxuICAgICAgKHRoaXMuX29wdGlvbnMuYnJhY2Vfc3R5bGUgPT09IFwibm9uZVwiICYmIGN1cnJlbnRfdG9rZW4ubmV3bGluZXMpKSAmJlxuICAgICF0aGlzLl9mbGFncy5pbmxpbmVfZnJhbWUpIHtcbiAgICBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlICE9PSBUT0tFTi5PUEVSQVRPUiAmJlxuICAgICAgKGVtcHR5X2Fub255bW91c19mdW5jdGlvbiB8fFxuICAgICAgICB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkVRVUFMUyB8fFxuICAgICAgICAocmVzZXJ2ZWRfYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbiwgc3BlY2lhbF93b3JkcykgJiYgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ICE9PSAnZWxzZScpKSkge1xuICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHJpbnRfbmV3bGluZShmYWxzZSwgdHJ1ZSk7XG4gICAgfVxuICB9IGVsc2UgeyAvLyBjb2xsYXBzZSB8fCBpbmxpbmVfZnJhbWVcbiAgICBpZiAoaXNfYXJyYXkodGhpcy5fcHJldmlvdXNfZmxhZ3MubW9kZSkgJiYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uU1RBUlRfRVhQUiB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkNPTU1BKSkge1xuICAgICAgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uQ09NTUEgfHwgdGhpcy5fb3B0aW9ucy5zcGFjZV9pbl9wYXJlbikge1xuICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uQ09NTUEgfHwgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uU1RBUlRfRVhQUiAmJiB0aGlzLl9mbGFncy5pbmxpbmVfZnJhbWUpKSB7XG4gICAgICAgIHRoaXMuYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShjdXJyZW50X3Rva2VuKTtcbiAgICAgICAgdGhpcy5fcHJldmlvdXNfZmxhZ3MubXVsdGlsaW5lX2ZyYW1lID0gdGhpcy5fcHJldmlvdXNfZmxhZ3MubXVsdGlsaW5lX2ZyYW1lIHx8IHRoaXMuX2ZsYWdzLm11bHRpbGluZV9mcmFtZTtcbiAgICAgICAgdGhpcy5fZmxhZ3MubXVsdGlsaW5lX2ZyYW1lID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgIT09IFRPS0VOLk9QRVJBVE9SICYmIHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSAhPT0gVE9LRU4uU1RBUlRfRVhQUikge1xuICAgICAgaWYgKGluX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSwgW1RPS0VOLlNUQVJUX0JMT0NLLCBUT0tFTi5TRU1JQ09MT05dKSAmJiAhdGhpcy5fZmxhZ3MuaW5saW5lX2ZyYW1lKSB7XG4gICAgICAgIHRoaXMucHJpbnRfbmV3bGluZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG4gIHRoaXMuaW5kZW50KCk7XG5cbiAgLy8gRXhjZXB0IGZvciBzcGVjaWZpYyBjYXNlcywgb3BlbiBicmFjZXMgYXJlIGZvbGxvd2VkIGJ5IGEgbmV3IGxpbmUuXG4gIGlmICghZW1wdHlfYnJhY2VzICYmICEodGhpcy5fb3B0aW9ucy5icmFjZV9wcmVzZXJ2ZV9pbmxpbmUgJiYgdGhpcy5fZmxhZ3MuaW5saW5lX2ZyYW1lKSkge1xuICAgIHRoaXMucHJpbnRfbmV3bGluZSgpO1xuICB9XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5oYW5kbGVfZW5kX2Jsb2NrID0gZnVuY3Rpb24oY3VycmVudF90b2tlbikge1xuICAvLyBzdGF0ZW1lbnRzIG11c3QgYWxsIGJlIGNsb3NlZCB3aGVuIHRoZWlyIGNvbnRhaW5lciBjbG9zZXNcbiAgdGhpcy5oYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbik7XG5cbiAgd2hpbGUgKHRoaXMuX2ZsYWdzLm1vZGUgPT09IE1PREUuU3RhdGVtZW50KSB7XG4gICAgdGhpcy5yZXN0b3JlX21vZGUoKTtcbiAgfVxuXG4gIHZhciBlbXB0eV9icmFjZXMgPSB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLlNUQVJUX0JMT0NLO1xuXG4gIGlmICh0aGlzLl9mbGFncy5pbmxpbmVfZnJhbWUgJiYgIWVtcHR5X2JyYWNlcykgeyAvLyB0cnkgaW5saW5lX2ZyYW1lIChvbmx5IHNldCBpZiB0aGlzLl9vcHRpb25zLmJyYWNlcy1wcmVzZXJ2ZS1pbmxpbmUpIGZpcnN0XG4gICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gIH0gZWxzZSBpZiAodGhpcy5fb3B0aW9ucy5icmFjZV9zdHlsZSA9PT0gXCJleHBhbmRcIikge1xuICAgIGlmICghZW1wdHlfYnJhY2VzKSB7XG4gICAgICB0aGlzLnByaW50X25ld2xpbmUoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gc2tpcCB7fVxuICAgIGlmICghZW1wdHlfYnJhY2VzKSB7XG4gICAgICBpZiAoaXNfYXJyYXkodGhpcy5fZmxhZ3MubW9kZSkgJiYgdGhpcy5fb3B0aW9ucy5rZWVwX2FycmF5X2luZGVudGF0aW9uKSB7XG4gICAgICAgIC8vIHdlIFJFQUxMWSBuZWVkIGEgbmV3bGluZSBoZXJlLCBidXQgbmV3bGluZXIgd291bGQgc2tpcCB0aGF0XG4gICAgICAgIHRoaXMuX29wdGlvbnMua2VlcF9hcnJheV9pbmRlbnRhdGlvbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLnByaW50X25ld2xpbmUoKTtcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5rZWVwX2FycmF5X2luZGVudGF0aW9uID0gdHJ1ZTtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmludF9uZXdsaW5lKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRoaXMucmVzdG9yZV9tb2RlKCk7XG4gIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5oYW5kbGVfd29yZCA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4pIHtcbiAgaWYgKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uUkVTRVJWRUQpIHtcbiAgICBpZiAoaW5fYXJyYXkoY3VycmVudF90b2tlbi50ZXh0LCBbJ3NldCcsICdnZXQnXSkgJiYgdGhpcy5fZmxhZ3MubW9kZSAhPT0gTU9ERS5PYmplY3RMaXRlcmFsKSB7XG4gICAgICBjdXJyZW50X3Rva2VuLnR5cGUgPSBUT0tFTi5XT1JEO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnaW1wb3J0JyAmJiBpbl9hcnJheSh0aGlzLl90b2tlbnMucGVlaygpLnRleHQsIFsnKCcsICcuJ10pKSB7XG4gICAgICBjdXJyZW50X3Rva2VuLnR5cGUgPSBUT0tFTi5XT1JEO1xuICAgIH0gZWxzZSBpZiAoaW5fYXJyYXkoY3VycmVudF90b2tlbi50ZXh0LCBbJ2FzJywgJ2Zyb20nXSkgJiYgIXRoaXMuX2ZsYWdzLmltcG9ydF9ibG9jaykge1xuICAgICAgY3VycmVudF90b2tlbi50eXBlID0gVE9LRU4uV09SRDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2ZsYWdzLm1vZGUgPT09IE1PREUuT2JqZWN0TGl0ZXJhbCkge1xuICAgICAgdmFyIG5leHRfdG9rZW4gPSB0aGlzLl90b2tlbnMucGVlaygpO1xuICAgICAgaWYgKG5leHRfdG9rZW4udGV4dCA9PT0gJzonKSB7XG4gICAgICAgIGN1cnJlbnRfdG9rZW4udHlwZSA9IFRPS0VOLldPUkQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMuc3RhcnRfb2Zfc3RhdGVtZW50KGN1cnJlbnRfdG9rZW4pKSB7XG4gICAgLy8gVGhlIGNvbmRpdGlvbmFsIHN0YXJ0cyB0aGUgc3RhdGVtZW50IGlmIGFwcHJvcHJpYXRlLlxuICAgIGlmIChyZXNlcnZlZF9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLCBbJ3ZhcicsICdsZXQnLCAnY29uc3QnXSkgJiYgY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5XT1JEKSB7XG4gICAgICB0aGlzLl9mbGFncy5kZWNsYXJhdGlvbl9zdGF0ZW1lbnQgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLm5ld2xpbmVzICYmICFpc19leHByZXNzaW9uKHRoaXMuX2ZsYWdzLm1vZGUpICYmXG4gICAgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSAhPT0gVE9LRU4uT1BFUkFUT1IgfHwgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJy0tJyB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICcrKycpKSAmJlxuICAgIHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSAhPT0gVE9LRU4uRVFVQUxTICYmXG4gICAgKHRoaXMuX29wdGlvbnMucHJlc2VydmVfbmV3bGluZXMgfHwgIXJlc2VydmVkX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4sIFsndmFyJywgJ2xldCcsICdjb25zdCcsICdzZXQnLCAnZ2V0J10pKSkge1xuICAgIHRoaXMuaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzKGN1cnJlbnRfdG9rZW4pO1xuICAgIHRoaXMucHJpbnRfbmV3bGluZSgpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzKGN1cnJlbnRfdG9rZW4pO1xuICB9XG5cbiAgaWYgKHRoaXMuX2ZsYWdzLmRvX2Jsb2NrICYmICF0aGlzLl9mbGFncy5kb193aGlsZSkge1xuICAgIGlmIChyZXNlcnZlZF93b3JkKGN1cnJlbnRfdG9rZW4sICd3aGlsZScpKSB7XG4gICAgICAvLyBkbyB7fSAjIyB3aGlsZSAoKVxuICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICB0aGlzLl9mbGFncy5kb193aGlsZSA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGRvIHt9IHNob3VsZCBhbHdheXMgaGF2ZSB3aGlsZSBhcyB0aGUgbmV4dCB3b3JkLlxuICAgICAgLy8gaWYgd2UgZG9uJ3Qgc2VlIHRoZSBleHBlY3RlZCB3aGlsZSwgcmVjb3ZlclxuICAgICAgdGhpcy5wcmludF9uZXdsaW5lKCk7XG4gICAgICB0aGlzLl9mbGFncy5kb19ibG9jayA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIG1heSBiZSBmb2xsb3dlZCBieSBlbHNlLCBvciBub3RcbiAgLy8gQmFyZS9pbmxpbmUgaWZzIGFyZSB0cmlja3lcbiAgLy8gTmVlZCB0byB1bndpbmQgdGhlIG1vZGVzIGNvcnJlY3RseTogaWYgKGEpIGlmIChiKSBjKCk7IGVsc2UgZCgpOyBlbHNlIGUoKTtcbiAgaWYgKHRoaXMuX2ZsYWdzLmlmX2Jsb2NrKSB7XG4gICAgaWYgKCF0aGlzLl9mbGFncy5lbHNlX2Jsb2NrICYmIHJlc2VydmVkX3dvcmQoY3VycmVudF90b2tlbiwgJ2Vsc2UnKSkge1xuICAgICAgdGhpcy5fZmxhZ3MuZWxzZV9ibG9jayA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlICh0aGlzLl9mbGFncy5tb2RlID09PSBNT0RFLlN0YXRlbWVudCkge1xuICAgICAgICB0aGlzLnJlc3RvcmVfbW9kZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fZmxhZ3MuaWZfYmxvY2sgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2ZsYWdzLmVsc2VfYmxvY2sgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5fZmxhZ3MuaW5fY2FzZV9zdGF0ZW1lbnQgJiYgcmVzZXJ2ZWRfYXJyYXkoY3VycmVudF90b2tlbiwgWydjYXNlJywgJ2RlZmF1bHQnXSkpIHtcbiAgICB0aGlzLnByaW50X25ld2xpbmUoKTtcbiAgICBpZiAoIXRoaXMuX2ZsYWdzLmNhc2VfYmxvY2sgJiYgKHRoaXMuX2ZsYWdzLmNhc2VfYm9keSB8fCB0aGlzLl9vcHRpb25zLmpzbGludF9oYXBweSkpIHtcbiAgICAgIC8vIHN3aXRjaCBjYXNlcyBmb2xsb3dpbmcgb25lIGFub3RoZXJcbiAgICAgIHRoaXMuZGVpbmRlbnQoKTtcbiAgICB9XG4gICAgdGhpcy5fZmxhZ3MuY2FzZV9ib2R5ID0gZmFsc2U7XG5cbiAgICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuICAgIHRoaXMuX2ZsYWdzLmluX2Nhc2UgPSB0cnVlO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkNPTU1BIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uU1RBUlRfRVhQUiB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkVRVUFMUyB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLk9QRVJBVE9SKSB7XG4gICAgaWYgKCF0aGlzLnN0YXJ0X29mX29iamVjdF9wcm9wZXJ0eSgpICYmICEoXG4gICAgICAgIC8vIHN0YXJ0IG9mIG9iamVjdCBwcm9wZXJ0eSBpcyBkaWZmZXJlbnQgZm9yIG51bWVyaWMgdmFsdWVzIHdpdGggKy8tIHByZWZpeCBvcGVyYXRvcnNcbiAgICAgICAgaW5fYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0LCBbJysnLCAnLSddKSAmJiB0aGlzLl9sYXN0X2xhc3RfdGV4dCA9PT0gJzonICYmIHRoaXMuX2ZsYWdzLnBhcmVudC5tb2RlID09PSBNT0RFLk9iamVjdExpdGVyYWwpKSB7XG4gICAgICB0aGlzLmFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoY3VycmVudF90b2tlbik7XG4gICAgfVxuICB9XG5cbiAgaWYgKHJlc2VydmVkX3dvcmQoY3VycmVudF90b2tlbiwgJ2Z1bmN0aW9uJykpIHtcbiAgICBpZiAoaW5fYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0LCBbJ30nLCAnOyddKSB8fFxuICAgICAgKHRoaXMuX291dHB1dC5qdXN0X2FkZGVkX25ld2xpbmUoKSAmJiAhKGluX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCwgWycoJywgJ1snLCAneycsICc6JywgJz0nLCAnLCddKSB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLk9QRVJBVE9SKSkpIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSB0aGVyZSBpcyBhIG5pY2UgY2xlYW4gc3BhY2Ugb2YgYXQgbGVhc3Qgb25lIGJsYW5rIGxpbmVcbiAgICAgIC8vIGJlZm9yZSBhIG5ldyBmdW5jdGlvbiBkZWZpbml0aW9uXG4gICAgICBpZiAoIXRoaXMuX291dHB1dC5qdXN0X2FkZGVkX2JsYW5rbGluZSgpICYmICFjdXJyZW50X3Rva2VuLmNvbW1lbnRzX2JlZm9yZSkge1xuICAgICAgICB0aGlzLnByaW50X25ld2xpbmUoKTtcbiAgICAgICAgdGhpcy5wcmludF9uZXdsaW5lKHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5SRVNFUlZFRCB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLldPUkQpIHtcbiAgICAgIGlmIChyZXNlcnZlZF9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLCBbJ2dldCcsICdzZXQnLCAnbmV3JywgJ2V4cG9ydCddKSB8fFxuICAgICAgICByZXNlcnZlZF9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLCBuZXdsaW5lX3Jlc3RyaWN0ZWRfdG9rZW5zKSkge1xuICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAocmVzZXJ2ZWRfd29yZCh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLCAnZGVmYXVsdCcpICYmIHRoaXMuX2xhc3RfbGFzdF90ZXh0ID09PSAnZXhwb3J0Jykge1xuICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnZGVjbGFyZScpIHtcbiAgICAgICAgLy8gYWNjb21vZGF0ZXMgVHlwZXNjcmlwdCBkZWNsYXJlIGZ1bmN0aW9uIGZvcm1hdHRpbmdcbiAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByaW50X25ld2xpbmUoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uT1BFUkFUT1IgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnPScpIHtcbiAgICAgIC8vIGZvbyA9IGZ1bmN0aW9uXG4gICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLl9mbGFncy5tdWx0aWxpbmVfZnJhbWUgJiYgKGlzX2V4cHJlc3Npb24odGhpcy5fZmxhZ3MubW9kZSkgfHwgaXNfYXJyYXkodGhpcy5fZmxhZ3MubW9kZSkpKSB7XG4gICAgICAvLyAoZnVuY3Rpb25cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcmludF9uZXdsaW5lKCk7XG4gICAgfVxuXG4gICAgdGhpcy5wcmludF90b2tlbihjdXJyZW50X3Rva2VuKTtcbiAgICB0aGlzLl9mbGFncy5sYXN0X3dvcmQgPSBjdXJyZW50X3Rva2VuLnRleHQ7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHByZWZpeCA9ICdOT05FJztcblxuICBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5FTkRfQkxPQ0spIHtcblxuICAgIGlmICh0aGlzLl9wcmV2aW91c19mbGFncy5pbmxpbmVfZnJhbWUpIHtcbiAgICAgIHByZWZpeCA9ICdTUEFDRSc7XG4gICAgfSBlbHNlIGlmICghcmVzZXJ2ZWRfYXJyYXkoY3VycmVudF90b2tlbiwgWydlbHNlJywgJ2NhdGNoJywgJ2ZpbmFsbHknLCAnZnJvbSddKSkge1xuICAgICAgcHJlZml4ID0gJ05FV0xJTkUnO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5fb3B0aW9ucy5icmFjZV9zdHlsZSA9PT0gXCJleHBhbmRcIiB8fFxuICAgICAgICB0aGlzLl9vcHRpb25zLmJyYWNlX3N0eWxlID09PSBcImVuZC1leHBhbmRcIiB8fFxuICAgICAgICAodGhpcy5fb3B0aW9ucy5icmFjZV9zdHlsZSA9PT0gXCJub25lXCIgJiYgY3VycmVudF90b2tlbi5uZXdsaW5lcykpIHtcbiAgICAgICAgcHJlZml4ID0gJ05FV0xJTkUnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJlZml4ID0gJ1NQQUNFJztcbiAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uU0VNSUNPTE9OICYmIHRoaXMuX2ZsYWdzLm1vZGUgPT09IE1PREUuQmxvY2tTdGF0ZW1lbnQpIHtcbiAgICAvLyBUT0RPOiBTaG91bGQgdGhpcyBiZSBmb3IgU1RBVEVNRU5UIGFzIHdlbGw/XG4gICAgcHJlZml4ID0gJ05FV0xJTkUnO1xuICB9IGVsc2UgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uU0VNSUNPTE9OICYmIGlzX2V4cHJlc3Npb24odGhpcy5fZmxhZ3MubW9kZSkpIHtcbiAgICBwcmVmaXggPSAnU1BBQ0UnO1xuICB9IGVsc2UgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uU1RSSU5HKSB7XG4gICAgcHJlZml4ID0gJ05FV0xJTkUnO1xuICB9IGVsc2UgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uUkVTRVJWRUQgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5XT1JEIHx8XG4gICAgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJyonICYmXG4gICAgICAoaW5fYXJyYXkodGhpcy5fbGFzdF9sYXN0X3RleHQsIFsnZnVuY3Rpb24nLCAneWllbGQnXSkgfHxcbiAgICAgICAgKHRoaXMuX2ZsYWdzLm1vZGUgPT09IE1PREUuT2JqZWN0TGl0ZXJhbCAmJiBpbl9hcnJheSh0aGlzLl9sYXN0X2xhc3RfdGV4dCwgWyd7JywgJywnXSkpKSkpIHtcbiAgICBwcmVmaXggPSAnU1BBQ0UnO1xuICB9IGVsc2UgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uU1RBUlRfQkxPQ0spIHtcbiAgICBpZiAodGhpcy5fZmxhZ3MuaW5saW5lX2ZyYW1lKSB7XG4gICAgICBwcmVmaXggPSAnU1BBQ0UnO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmVmaXggPSAnTkVXTElORSc7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uRU5EX0VYUFIpIHtcbiAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICBwcmVmaXggPSAnTkVXTElORSc7XG4gIH1cblxuICBpZiAocmVzZXJ2ZWRfYXJyYXkoY3VycmVudF90b2tlbiwgbGluZV9zdGFydGVycykgJiYgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ICE9PSAnKScpIHtcbiAgICBpZiAodGhpcy5fZmxhZ3MuaW5saW5lX2ZyYW1lIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJ2Vsc2UnIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJ2V4cG9ydCcpIHtcbiAgICAgIHByZWZpeCA9ICdTUEFDRSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZWZpeCA9ICdORVdMSU5FJztcbiAgICB9XG5cbiAgfVxuXG4gIGlmIChyZXNlcnZlZF9hcnJheShjdXJyZW50X3Rva2VuLCBbJ2Vsc2UnLCAnY2F0Y2gnLCAnZmluYWxseSddKSkge1xuICAgIGlmICgoISh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkVORF9CTE9DSyAmJiB0aGlzLl9wcmV2aW91c19mbGFncy5tb2RlID09PSBNT0RFLkJsb2NrU3RhdGVtZW50KSB8fFxuICAgICAgICB0aGlzLl9vcHRpb25zLmJyYWNlX3N0eWxlID09PSBcImV4cGFuZFwiIHx8XG4gICAgICAgIHRoaXMuX29wdGlvbnMuYnJhY2Vfc3R5bGUgPT09IFwiZW5kLWV4cGFuZFwiIHx8XG4gICAgICAgICh0aGlzLl9vcHRpb25zLmJyYWNlX3N0eWxlID09PSBcIm5vbmVcIiAmJiBjdXJyZW50X3Rva2VuLm5ld2xpbmVzKSkgJiZcbiAgICAgICF0aGlzLl9mbGFncy5pbmxpbmVfZnJhbWUpIHtcbiAgICAgIHRoaXMucHJpbnRfbmV3bGluZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9vdXRwdXQudHJpbSh0cnVlKTtcbiAgICAgIHZhciBsaW5lID0gdGhpcy5fb3V0cHV0LmN1cnJlbnRfbGluZTtcbiAgICAgIC8vIElmIHdlIHRyaW1tZWQgYW5kIHRoZXJlJ3Mgc29tZXRoaW5nIG90aGVyIHRoYW4gYSBjbG9zZSBibG9jayBiZWZvcmUgdXNcbiAgICAgIC8vIHB1dCBhIG5ld2xpbmUgYmFjayBpbi4gIEhhbmRsZXMgJ30gLy8gY29tbWVudCcgc2NlbmFyaW8uXG4gICAgICBpZiAobGluZS5sYXN0KCkgIT09ICd9Jykge1xuICAgICAgICB0aGlzLnByaW50X25ld2xpbmUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChwcmVmaXggPT09ICdORVdMSU5FJykge1xuICAgIGlmIChyZXNlcnZlZF9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLCBzcGVjaWFsX3dvcmRzKSkge1xuICAgICAgLy8gbm8gbmV3bGluZSBiZXR3ZWVuICdyZXR1cm4gbm5uJ1xuICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICdkZWNsYXJlJyAmJiByZXNlcnZlZF9hcnJheShjdXJyZW50X3Rva2VuLCBbJ3ZhcicsICdsZXQnLCAnY29uc3QnXSkpIHtcbiAgICAgIC8vIGFjY29tb2RhdGVzIFR5cGVzY3JpcHQgZGVjbGFyZSBmb3JtYXR0aW5nXG4gICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSAhPT0gVE9LRU4uRU5EX0VYUFIpIHtcbiAgICAgIGlmICgodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlICE9PSBUT0tFTi5TVEFSVF9FWFBSIHx8ICFyZXNlcnZlZF9hcnJheShjdXJyZW50X3Rva2VuLCBbJ3ZhcicsICdsZXQnLCAnY29uc3QnXSkpICYmIHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCAhPT0gJzonKSB7XG4gICAgICAgIC8vIG5vIG5lZWQgdG8gZm9yY2UgbmV3bGluZSBvbiAndmFyJzogZm9yICh2YXIgeCA9IDAuLi4pXG4gICAgICAgIGlmIChyZXNlcnZlZF93b3JkKGN1cnJlbnRfdG9rZW4sICdpZicpICYmIHJlc2VydmVkX3dvcmQoY3VycmVudF90b2tlbi5wcmV2aW91cywgJ2Vsc2UnKSkge1xuICAgICAgICAgIC8vIG5vIG5ld2xpbmUgZm9yIH0gZWxzZSBpZiB7XG4gICAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5wcmludF9uZXdsaW5lKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJlc2VydmVkX2FycmF5KGN1cnJlbnRfdG9rZW4sIGxpbmVfc3RhcnRlcnMpICYmIHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCAhPT0gJyknKSB7XG4gICAgICB0aGlzLnByaW50X25ld2xpbmUoKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGhpcy5fZmxhZ3MubXVsdGlsaW5lX2ZyYW1lICYmIGlzX2FycmF5KHRoaXMuX2ZsYWdzLm1vZGUpICYmIHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJywnICYmIHRoaXMuX2xhc3RfbGFzdF90ZXh0ID09PSAnfScpIHtcbiAgICB0aGlzLnByaW50X25ld2xpbmUoKTsgLy8gfSwgaW4gbGlzdHMgZ2V0IGEgbmV3bGluZSB0cmVhdG1lbnRcbiAgfSBlbHNlIGlmIChwcmVmaXggPT09ICdTUEFDRScpIHtcbiAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgfVxuICBpZiAoY3VycmVudF90b2tlbi5wcmV2aW91cyAmJiAoY3VycmVudF90b2tlbi5wcmV2aW91cy50eXBlID09PSBUT0tFTi5XT1JEIHx8IGN1cnJlbnRfdG9rZW4ucHJldmlvdXMudHlwZSA9PT0gVE9LRU4uUkVTRVJWRUQpKSB7XG4gICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gIH1cbiAgdGhpcy5wcmludF90b2tlbihjdXJyZW50X3Rva2VuKTtcbiAgdGhpcy5fZmxhZ3MubGFzdF93b3JkID0gY3VycmVudF90b2tlbi50ZXh0O1xuXG4gIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLlJFU0VSVkVEKSB7XG4gICAgaWYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJ2RvJykge1xuICAgICAgdGhpcy5fZmxhZ3MuZG9fYmxvY2sgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnaWYnKSB7XG4gICAgICB0aGlzLl9mbGFncy5pZl9ibG9jayA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICdpbXBvcnQnKSB7XG4gICAgICB0aGlzLl9mbGFncy5pbXBvcnRfYmxvY2sgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fZmxhZ3MuaW1wb3J0X2Jsb2NrICYmIHJlc2VydmVkX3dvcmQoY3VycmVudF90b2tlbiwgJ2Zyb20nKSkge1xuICAgICAgdGhpcy5fZmxhZ3MuaW1wb3J0X2Jsb2NrID0gZmFsc2U7XG4gICAgfVxuICB9XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5oYW5kbGVfc2VtaWNvbG9uID0gZnVuY3Rpb24oY3VycmVudF90b2tlbikge1xuICBpZiAodGhpcy5zdGFydF9vZl9zdGF0ZW1lbnQoY3VycmVudF90b2tlbikpIHtcbiAgICAvLyBUaGUgY29uZGl0aW9uYWwgc3RhcnRzIHRoZSBzdGF0ZW1lbnQgaWYgYXBwcm9wcmlhdGUuXG4gICAgLy8gU2VtaWNvbG9uIGNhbiBiZSB0aGUgc3RhcnQgKGFuZCBlbmQpIG9mIGEgc3RhdGVtZW50XG4gICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzKGN1cnJlbnRfdG9rZW4pO1xuICB9XG5cbiAgdmFyIG5leHRfdG9rZW4gPSB0aGlzLl90b2tlbnMucGVlaygpO1xuICB3aGlsZSAodGhpcy5fZmxhZ3MubW9kZSA9PT0gTU9ERS5TdGF0ZW1lbnQgJiZcbiAgICAhKHRoaXMuX2ZsYWdzLmlmX2Jsb2NrICYmIHJlc2VydmVkX3dvcmQobmV4dF90b2tlbiwgJ2Vsc2UnKSkgJiZcbiAgICAhdGhpcy5fZmxhZ3MuZG9fYmxvY2spIHtcbiAgICB0aGlzLnJlc3RvcmVfbW9kZSgpO1xuICB9XG5cbiAgLy8gaGFja3kgYnV0IGVmZmVjdGl2ZSBmb3IgdGhlIG1vbWVudFxuICBpZiAodGhpcy5fZmxhZ3MuaW1wb3J0X2Jsb2NrKSB7XG4gICAgdGhpcy5fZmxhZ3MuaW1wb3J0X2Jsb2NrID0gZmFsc2U7XG4gIH1cbiAgdGhpcy5wcmludF90b2tlbihjdXJyZW50X3Rva2VuKTtcbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmhhbmRsZV9zdHJpbmcgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7XG4gIGlmIChjdXJyZW50X3Rva2VuLnRleHQuc3RhcnRzV2l0aChcImBcIikgJiYgY3VycmVudF90b2tlbi5uZXdsaW5lcyA9PT0gMCAmJiBjdXJyZW50X3Rva2VuLndoaXRlc3BhY2VfYmVmb3JlID09PSAnJyAmJiAoY3VycmVudF90b2tlbi5wcmV2aW91cy50ZXh0ID09PSAnKScgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5XT1JEKSkge1xuICAgIC8vQ29uZGl0aW9uYWwgZm9yIGRldGVjdGlnbiBiYWNrdGljayBzdHJpbmdzXG4gIH0gZWxzZSBpZiAodGhpcy5zdGFydF9vZl9zdGF0ZW1lbnQoY3VycmVudF90b2tlbikpIHtcbiAgICAvLyBUaGUgY29uZGl0aW9uYWwgc3RhcnRzIHRoZSBzdGF0ZW1lbnQgaWYgYXBwcm9wcmlhdGUuXG4gICAgLy8gT25lIGRpZmZlcmVuY2UgLSBzdHJpbmdzIHdhbnQgYXQgbGVhc3QgYSBzcGFjZSBiZWZvcmVcbiAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhjdXJyZW50X3Rva2VuKTtcbiAgICBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5SRVNFUlZFRCB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLldPUkQgfHwgdGhpcy5fZmxhZ3MuaW5saW5lX2ZyYW1lKSB7XG4gICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uQ09NTUEgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5TVEFSVF9FWFBSIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uRVFVQUxTIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uT1BFUkFUT1IpIHtcbiAgICAgIGlmICghdGhpcy5zdGFydF9vZl9vYmplY3RfcHJvcGVydHkoKSkge1xuICAgICAgICB0aGlzLmFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoY3VycmVudF90b2tlbik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgoY3VycmVudF90b2tlbi50ZXh0LnN0YXJ0c1dpdGgoXCJgXCIpICYmIHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uRU5EX0VYUFIgJiYgKGN1cnJlbnRfdG9rZW4ucHJldmlvdXMudGV4dCA9PT0gJ10nIHx8IGN1cnJlbnRfdG9rZW4ucHJldmlvdXMudGV4dCA9PT0gJyknKSAmJiBjdXJyZW50X3Rva2VuLm5ld2xpbmVzID09PSAwKSkge1xuICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHJpbnRfbmV3bGluZSgpO1xuICAgIH1cbiAgfVxuICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuaGFuZGxlX2VxdWFscyA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4pIHtcbiAgaWYgKHRoaXMuc3RhcnRfb2Zfc3RhdGVtZW50KGN1cnJlbnRfdG9rZW4pKSB7XG4gICAgLy8gVGhlIGNvbmRpdGlvbmFsIHN0YXJ0cyB0aGUgc3RhdGVtZW50IGlmIGFwcHJvcHJpYXRlLlxuICB9IGVsc2Uge1xuICAgIHRoaXMuaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzKGN1cnJlbnRfdG9rZW4pO1xuICB9XG5cbiAgaWYgKHRoaXMuX2ZsYWdzLmRlY2xhcmF0aW9uX3N0YXRlbWVudCkge1xuICAgIC8vIGp1c3QgZ290IGFuICc9JyBpbiBhIHZhci1saW5lLCBkaWZmZXJlbnQgZm9ybWF0dGluZy9saW5lLWJyZWFraW5nLCBldGMgd2lsbCBub3cgYmUgZG9uZVxuICAgIHRoaXMuX2ZsYWdzLmRlY2xhcmF0aW9uX2Fzc2lnbm1lbnQgPSB0cnVlO1xuICB9XG4gIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmhhbmRsZV9jb21tYSA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4pIHtcbiAgdGhpcy5oYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbiwgdHJ1ZSk7XG5cbiAgdGhpcy5wcmludF90b2tlbihjdXJyZW50X3Rva2VuKTtcbiAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gIGlmICh0aGlzLl9mbGFncy5kZWNsYXJhdGlvbl9zdGF0ZW1lbnQpIHtcbiAgICBpZiAoaXNfZXhwcmVzc2lvbih0aGlzLl9mbGFncy5wYXJlbnQubW9kZSkpIHtcbiAgICAgIC8vIGRvIG5vdCBicmVhayBvbiBjb21tYSwgZm9yKHZhciBhID0gMSwgYiA9IDIpXG4gICAgICB0aGlzLl9mbGFncy5kZWNsYXJhdGlvbl9hc3NpZ25tZW50ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2ZsYWdzLmRlY2xhcmF0aW9uX2Fzc2lnbm1lbnQpIHtcbiAgICAgIHRoaXMuX2ZsYWdzLmRlY2xhcmF0aW9uX2Fzc2lnbm1lbnQgPSBmYWxzZTtcbiAgICAgIHRoaXMucHJpbnRfbmV3bGluZShmYWxzZSwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9vcHRpb25zLmNvbW1hX2ZpcnN0KSB7XG4gICAgICAvLyBmb3IgY29tbWEtZmlyc3QsIHdlIHdhbnQgdG8gYWxsb3cgYSBuZXdsaW5lIGJlZm9yZSB0aGUgY29tbWFcbiAgICAgIC8vIHRvIHR1cm4gaW50byBhIG5ld2xpbmUgYWZ0ZXIgdGhlIGNvbW1hLCB3aGljaCB3ZSB3aWxsIGZpeHVwIGxhdGVyXG4gICAgICB0aGlzLmFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoY3VycmVudF90b2tlbik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRoaXMuX2ZsYWdzLm1vZGUgPT09IE1PREUuT2JqZWN0TGl0ZXJhbCB8fFxuICAgICh0aGlzLl9mbGFncy5tb2RlID09PSBNT0RFLlN0YXRlbWVudCAmJiB0aGlzLl9mbGFncy5wYXJlbnQubW9kZSA9PT0gTU9ERS5PYmplY3RMaXRlcmFsKSkge1xuICAgIGlmICh0aGlzLl9mbGFncy5tb2RlID09PSBNT0RFLlN0YXRlbWVudCkge1xuICAgICAgdGhpcy5yZXN0b3JlX21vZGUoKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2ZsYWdzLmlubGluZV9mcmFtZSkge1xuICAgICAgdGhpcy5wcmludF9uZXdsaW5lKCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRoaXMuX29wdGlvbnMuY29tbWFfZmlyc3QpIHtcbiAgICAvLyBFWFBSIG9yIERPX0JMT0NLXG4gICAgLy8gZm9yIGNvbW1hLWZpcnN0LCB3ZSB3YW50IHRvIGFsbG93IGEgbmV3bGluZSBiZWZvcmUgdGhlIGNvbW1hXG4gICAgLy8gdG8gdHVybiBpbnRvIGEgbmV3bGluZSBhZnRlciB0aGUgY29tbWEsIHdoaWNoIHdlIHdpbGwgZml4dXAgbGF0ZXJcbiAgICB0aGlzLmFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoY3VycmVudF90b2tlbik7XG4gIH1cbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmhhbmRsZV9vcGVyYXRvciA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4pIHtcbiAgdmFyIGlzR2VuZXJhdG9yQXN0ZXJpc2sgPSBjdXJyZW50X3Rva2VuLnRleHQgPT09ICcqJyAmJlxuICAgIChyZXNlcnZlZF9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLCBbJ2Z1bmN0aW9uJywgJ3lpZWxkJ10pIHx8XG4gICAgICAoaW5fYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlLCBbVE9LRU4uU1RBUlRfQkxPQ0ssIFRPS0VOLkNPTU1BLCBUT0tFTi5FTkRfQkxPQ0ssIFRPS0VOLlNFTUlDT0xPTl0pKVxuICAgICk7XG4gIHZhciBpc1VuYXJ5ID0gaW5fYXJyYXkoY3VycmVudF90b2tlbi50ZXh0LCBbJy0nLCAnKyddKSAmJiAoXG4gICAgaW5fYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlLCBbVE9LRU4uU1RBUlRfQkxPQ0ssIFRPS0VOLlNUQVJUX0VYUFIsIFRPS0VOLkVRVUFMUywgVE9LRU4uT1BFUkFUT1JdKSB8fFxuICAgIGluX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCwgbGluZV9zdGFydGVycykgfHxcbiAgICB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICcsJ1xuICApO1xuXG4gIGlmICh0aGlzLnN0YXJ0X29mX3N0YXRlbWVudChjdXJyZW50X3Rva2VuKSkge1xuICAgIC8vIFRoZSBjb25kaXRpb25hbCBzdGFydHMgdGhlIHN0YXRlbWVudCBpZiBhcHByb3ByaWF0ZS5cbiAgfSBlbHNlIHtcbiAgICB2YXIgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzID0gIWlzR2VuZXJhdG9yQXN0ZXJpc2s7XG4gICAgdGhpcy5oYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbiwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbiAgfVxuXG4gIC8vIGhhY2sgZm9yIGFjdGlvbnNjcmlwdCdzIGltcG9ydCAuKjtcbiAgaWYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJyonICYmIHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uRE9UKSB7XG4gICAgdGhpcy5wcmludF90b2tlbihjdXJyZW50X3Rva2VuKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnOjonKSB7XG4gICAgLy8gbm8gc3BhY2VzIGFyb3VuZCBleG90aWMgbmFtZXNwYWNpbmcgc3ludGF4IG9wZXJhdG9yXG4gICAgdGhpcy5wcmludF90b2tlbihjdXJyZW50X3Rva2VuKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaW5fYXJyYXkoY3VycmVudF90b2tlbi50ZXh0LCBbJy0nLCAnKyddKSAmJiB0aGlzLnN0YXJ0X29mX29iamVjdF9wcm9wZXJ0eSgpKSB7XG4gICAgLy8gbnVtZXJpYyB2YWx1ZSB3aXRoICsvLSBzeW1ib2wgaW4gZnJvbnQgYXMgYSBwcm9wZXJ0eVxuICAgIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gQWxsb3cgbGluZSB3cmFwcGluZyBiZXR3ZWVuIG9wZXJhdG9ycyB3aGVuIG9wZXJhdG9yX3Bvc2l0aW9uIGlzXG4gIC8vICAgc2V0IHRvIGJlZm9yZSBvciBwcmVzZXJ2ZVxuICBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5PUEVSQVRPUiAmJiBpbl9hcnJheSh0aGlzLl9vcHRpb25zLm9wZXJhdG9yX3Bvc2l0aW9uLCBPUEVSQVRPUl9QT1NJVElPTl9CRUZPUkVfT1JfUFJFU0VSVkUpKSB7XG4gICAgdGhpcy5hbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKGN1cnJlbnRfdG9rZW4pO1xuICB9XG5cbiAgaWYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJzonICYmIHRoaXMuX2ZsYWdzLmluX2Nhc2UpIHtcbiAgICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuXG4gICAgdGhpcy5fZmxhZ3MuaW5fY2FzZSA9IGZhbHNlO1xuICAgIHRoaXMuX2ZsYWdzLmNhc2VfYm9keSA9IHRydWU7XG4gICAgaWYgKHRoaXMuX3Rva2Vucy5wZWVrKCkudHlwZSAhPT0gVE9LRU4uU1RBUlRfQkxPQ0spIHtcbiAgICAgIHRoaXMuaW5kZW50KCk7XG4gICAgICB0aGlzLnByaW50X25ld2xpbmUoKTtcbiAgICAgIHRoaXMuX2ZsYWdzLmNhc2VfYmxvY2sgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZmxhZ3MuY2FzZV9ibG9jayA9IHRydWU7XG4gICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNwYWNlX2JlZm9yZSA9IHRydWU7XG4gIHZhciBzcGFjZV9hZnRlciA9IHRydWU7XG4gIHZhciBpbl90ZXJuYXJ5ID0gZmFsc2U7XG4gIGlmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICc6Jykge1xuICAgIGlmICh0aGlzLl9mbGFncy50ZXJuYXJ5X2RlcHRoID09PSAwKSB7XG4gICAgICAvLyBDb2xvbiBpcyBpbnZhbGlkIGphdmFzY3JpcHQgb3V0c2lkZSBvZiB0ZXJuYXJ5IGFuZCBvYmplY3QsIGJ1dCBkbyBvdXIgYmVzdCB0byBndWVzcyB3aGF0IHdhcyBtZWFudC5cbiAgICAgIHNwYWNlX2JlZm9yZSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9mbGFncy50ZXJuYXJ5X2RlcHRoIC09IDE7XG4gICAgICBpbl90ZXJuYXJ5ID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnPycpIHtcbiAgICB0aGlzLl9mbGFncy50ZXJuYXJ5X2RlcHRoICs9IDE7XG4gIH1cblxuICAvLyBsZXQncyBoYW5kbGUgdGhlIG9wZXJhdG9yX3Bvc2l0aW9uIG9wdGlvbiBwcmlvciB0byBhbnkgY29uZmxpY3RpbmcgbG9naWNcbiAgaWYgKCFpc1VuYXJ5ICYmICFpc0dlbmVyYXRvckFzdGVyaXNrICYmIHRoaXMuX29wdGlvbnMucHJlc2VydmVfbmV3bGluZXMgJiYgaW5fYXJyYXkoY3VycmVudF90b2tlbi50ZXh0LCBwb3NpdGlvbmFibGVfb3BlcmF0b3JzKSkge1xuICAgIHZhciBpc0NvbG9uID0gY3VycmVudF90b2tlbi50ZXh0ID09PSAnOic7XG4gICAgdmFyIGlzVGVybmFyeUNvbG9uID0gKGlzQ29sb24gJiYgaW5fdGVybmFyeSk7XG4gICAgdmFyIGlzT3RoZXJDb2xvbiA9IChpc0NvbG9uICYmICFpbl90ZXJuYXJ5KTtcblxuICAgIHN3aXRjaCAodGhpcy5fb3B0aW9ucy5vcGVyYXRvcl9wb3NpdGlvbikge1xuICAgICAgY2FzZSBPUEVSQVRPUl9QT1NJVElPTi5iZWZvcmVfbmV3bGluZTpcbiAgICAgICAgLy8gaWYgdGhlIGN1cnJlbnQgdG9rZW4gaXMgOiBhbmQgaXQncyBub3QgYSB0ZXJuYXJ5IHN0YXRlbWVudCB0aGVuIHdlIHNldCBzcGFjZV9iZWZvcmUgdG8gZmFsc2VcbiAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9ICFpc090aGVyQ29sb247XG5cbiAgICAgICAgdGhpcy5wcmludF90b2tlbihjdXJyZW50X3Rva2VuKTtcblxuICAgICAgICBpZiAoIWlzQ29sb24gfHwgaXNUZXJuYXJ5Q29sb24pIHtcbiAgICAgICAgICB0aGlzLmFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoY3VycmVudF90b2tlbik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIE9QRVJBVE9SX1BPU0lUSU9OLmFmdGVyX25ld2xpbmU6XG4gICAgICAgIC8vIGlmIHRoZSBjdXJyZW50IHRva2VuIGlzIGFueXRoaW5nIGJ1dCBjb2xvbiwgb3IgKHZpYSBkZWR1Y3Rpb24pIGl0J3MgYSBjb2xvbiBhbmQgaW4gYSB0ZXJuYXJ5IHN0YXRlbWVudCxcbiAgICAgICAgLy8gICB0aGVuIHByaW50IGEgbmV3bGluZS5cblxuICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIWlzQ29sb24gfHwgaXNUZXJuYXJ5Q29sb24pIHtcbiAgICAgICAgICBpZiAodGhpcy5fdG9rZW5zLnBlZWsoKS5uZXdsaW5lcykge1xuICAgICAgICAgICAgdGhpcy5wcmludF9uZXdsaW5lKGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKGN1cnJlbnRfdG9rZW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuXG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgT1BFUkFUT1JfUE9TSVRJT04ucHJlc2VydmVfbmV3bGluZTpcbiAgICAgICAgaWYgKCFpc090aGVyQ29sb24pIHtcbiAgICAgICAgICB0aGlzLmFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoY3VycmVudF90b2tlbik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB3ZSBqdXN0IGFkZGVkIGEgbmV3bGluZSwgb3IgdGhlIGN1cnJlbnQgdG9rZW4gaXMgOiBhbmQgaXQncyBub3QgYSB0ZXJuYXJ5IHN0YXRlbWVudCxcbiAgICAgICAgLy8gICB0aGVuIHdlIHNldCBzcGFjZV9iZWZvcmUgdG8gZmFsc2VcbiAgICAgICAgc3BhY2VfYmVmb3JlID0gISh0aGlzLl9vdXRwdXQuanVzdF9hZGRlZF9uZXdsaW5lKCkgfHwgaXNPdGhlckNvbG9uKTtcblxuICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gc3BhY2VfYmVmb3JlO1xuICAgICAgICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc0dlbmVyYXRvckFzdGVyaXNrKSB7XG4gICAgdGhpcy5hbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKGN1cnJlbnRfdG9rZW4pO1xuICAgIHNwYWNlX2JlZm9yZSA9IGZhbHNlO1xuICAgIHZhciBuZXh0X3Rva2VuID0gdGhpcy5fdG9rZW5zLnBlZWsoKTtcbiAgICBzcGFjZV9hZnRlciA9IG5leHRfdG9rZW4gJiYgaW5fYXJyYXkobmV4dF90b2tlbi50eXBlLCBbVE9LRU4uV09SRCwgVE9LRU4uUkVTRVJWRURdKTtcbiAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICcuLi4nKSB7XG4gICAgdGhpcy5hbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKGN1cnJlbnRfdG9rZW4pO1xuICAgIHNwYWNlX2JlZm9yZSA9IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uU1RBUlRfQkxPQ0s7XG4gICAgc3BhY2VfYWZ0ZXIgPSBmYWxzZTtcbiAgfSBlbHNlIGlmIChpbl9hcnJheShjdXJyZW50X3Rva2VuLnRleHQsIFsnLS0nLCAnKysnLCAnIScsICd+J10pIHx8IGlzVW5hcnkpIHtcbiAgICAvLyB1bmFyeSBvcGVyYXRvcnMgKGFuZCBiaW5hcnkgKy8tIHByZXRlbmRpbmcgdG8gYmUgdW5hcnkpIHNwZWNpYWwgY2FzZXNcbiAgICBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5DT01NQSB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLlNUQVJUX0VYUFIpIHtcbiAgICAgIHRoaXMuYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShjdXJyZW50X3Rva2VuKTtcbiAgICB9XG5cbiAgICBzcGFjZV9iZWZvcmUgPSBmYWxzZTtcbiAgICBzcGFjZV9hZnRlciA9IGZhbHNlO1xuXG4gICAgLy8gaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzUuMS8jc2VjLTcuOS4xXG4gICAgLy8gaWYgdGhlcmUgaXMgYSBuZXdsaW5lIGJldHdlZW4gLS0gb3IgKysgYW5kIGFueXRoaW5nIGVsc2Ugd2Ugc2hvdWxkIHByZXNlcnZlIGl0LlxuICAgIGlmIChjdXJyZW50X3Rva2VuLm5ld2xpbmVzICYmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICctLScgfHwgY3VycmVudF90b2tlbi50ZXh0ID09PSAnKysnIHx8IGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJ34nKSkge1xuICAgICAgdmFyIG5ld19saW5lX25lZWRlZCA9IHJlc2VydmVkX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4sIHNwZWNpYWxfd29yZHMpICYmIGN1cnJlbnRfdG9rZW4ubmV3bGluZXM7XG4gICAgICBpZiAobmV3X2xpbmVfbmVlZGVkICYmICh0aGlzLl9wcmV2aW91c19mbGFncy5pZl9ibG9jayB8fCB0aGlzLl9wcmV2aW91c19mbGFncy5lbHNlX2Jsb2NrKSkge1xuICAgICAgICB0aGlzLnJlc3RvcmVfbW9kZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5wcmludF9uZXdsaW5lKG5ld19saW5lX25lZWRlZCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJzsnICYmIGlzX2V4cHJlc3Npb24odGhpcy5fZmxhZ3MubW9kZSkpIHtcbiAgICAgIC8vIGZvciAoOzsgKytpKVxuICAgICAgLy8gICAgICAgIF5eXlxuICAgICAgc3BhY2VfYmVmb3JlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5SRVNFUlZFRCkge1xuICAgICAgc3BhY2VfYmVmb3JlID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uRU5EX0VYUFIpIHtcbiAgICAgIHNwYWNlX2JlZm9yZSA9ICEodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnXScgJiYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJy0tJyB8fCBjdXJyZW50X3Rva2VuLnRleHQgPT09ICcrKycpKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uT1BFUkFUT1IpIHtcbiAgICAgIC8vIGErKyArICsrYjtcbiAgICAgIC8vIGEgLSAtYlxuICAgICAgc3BhY2VfYmVmb3JlID0gaW5fYXJyYXkoY3VycmVudF90b2tlbi50ZXh0LCBbJy0tJywgJy0nLCAnKysnLCAnKyddKSAmJiBpbl9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQsIFsnLS0nLCAnLScsICcrKycsICcrJ10pO1xuICAgICAgLy8gKyBhbmQgLSBhcmUgbm90IHVuYXJ5IHdoZW4gcHJlY2VlZGVkIGJ5IC0tIG9yICsrIG9wZXJhdG9yXG4gICAgICAvLyBhLS0gKyBiXG4gICAgICAvLyBhICogK2JcbiAgICAgIC8vIGEgLSAtYlxuICAgICAgaWYgKGluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCwgWycrJywgJy0nXSkgJiYgaW5fYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0LCBbJy0tJywgJysrJ10pKSB7XG4gICAgICAgIHNwYWNlX2FmdGVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cblxuICAgIGlmICgoKHRoaXMuX2ZsYWdzLm1vZGUgPT09IE1PREUuQmxvY2tTdGF0ZW1lbnQgJiYgIXRoaXMuX2ZsYWdzLmlubGluZV9mcmFtZSkgfHwgdGhpcy5fZmxhZ3MubW9kZSA9PT0gTU9ERS5TdGF0ZW1lbnQpICYmXG4gICAgICAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAneycgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnOycpKSB7XG4gICAgICAvLyB7IGZvbzsgLS1pIH1cbiAgICAgIC8vIGZvbygpOyAtLWJhcjtcbiAgICAgIHRoaXMucHJpbnRfbmV3bGluZSgpO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuIHx8IHNwYWNlX2JlZm9yZTtcbiAgdGhpcy5wcmludF90b2tlbihjdXJyZW50X3Rva2VuKTtcbiAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHNwYWNlX2FmdGVyO1xufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuaGFuZGxlX2Jsb2NrX2NvbW1lbnQgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpIHtcbiAgaWYgKHRoaXMuX291dHB1dC5yYXcpIHtcbiAgICB0aGlzLl9vdXRwdXQuYWRkX3Jhd190b2tlbihjdXJyZW50X3Rva2VuKTtcbiAgICBpZiAoY3VycmVudF90b2tlbi5kaXJlY3RpdmVzICYmIGN1cnJlbnRfdG9rZW4uZGlyZWN0aXZlcy5wcmVzZXJ2ZSA9PT0gJ2VuZCcpIHtcbiAgICAgIC8vIElmIHdlJ3JlIHRlc3RpbmcgdGhlIHJhdyBvdXRwdXQgYmVoYXZpb3IsIGRvIG5vdCBhbGxvdyBhIGRpcmVjdGl2ZSB0byB0dXJuIGl0IG9mZi5cbiAgICAgIHRoaXMuX291dHB1dC5yYXcgPSB0aGlzLl9vcHRpb25zLnRlc3Rfb3V0cHV0X3JhdztcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGN1cnJlbnRfdG9rZW4uZGlyZWN0aXZlcykge1xuICAgIHRoaXMucHJpbnRfbmV3bGluZShmYWxzZSwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbiAgICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuICAgIGlmIChjdXJyZW50X3Rva2VuLmRpcmVjdGl2ZXMucHJlc2VydmUgPT09ICdzdGFydCcpIHtcbiAgICAgIHRoaXMuX291dHB1dC5yYXcgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLnByaW50X25ld2xpbmUoZmFsc2UsIHRydWUpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGlubGluZSBibG9ja1xuICBpZiAoIWFjb3JuLm5ld2xpbmUudGVzdChjdXJyZW50X3Rva2VuLnRleHQpICYmICFjdXJyZW50X3Rva2VuLm5ld2xpbmVzKSB7XG4gICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgdGhpcy5wcmludF90b2tlbihjdXJyZW50X3Rva2VuKTtcbiAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5wcmludF9ibG9ja19jb21tbWVudChjdXJyZW50X3Rva2VuLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICB9XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5wcmludF9ibG9ja19jb21tbWVudCA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4sIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncykge1xuICB2YXIgbGluZXMgPSBzcGxpdF9saW5lYnJlYWtzKGN1cnJlbnRfdG9rZW4udGV4dCk7XG4gIHZhciBqOyAvLyBpdGVyYXRvciBmb3IgdGhpcyBjYXNlXG4gIHZhciBqYXZhZG9jID0gZmFsc2U7XG4gIHZhciBzdGFybGVzcyA9IGZhbHNlO1xuICB2YXIgbGFzdEluZGVudCA9IGN1cnJlbnRfdG9rZW4ud2hpdGVzcGFjZV9iZWZvcmU7XG4gIHZhciBsYXN0SW5kZW50TGVuZ3RoID0gbGFzdEluZGVudC5sZW5ndGg7XG5cbiAgLy8gYmxvY2sgY29tbWVudCBzdGFydHMgd2l0aCBhIG5ldyBsaW5lXG4gIHRoaXMucHJpbnRfbmV3bGluZShmYWxzZSwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcblxuICAvLyBmaXJzdCBsaW5lIGFsd2F5cyBpbmRlbnRlZFxuICB0aGlzLnByaW50X3Rva2VuX2xpbmVfaW5kZW50YXRpb24oY3VycmVudF90b2tlbik7XG4gIHRoaXMuX291dHB1dC5hZGRfdG9rZW4obGluZXNbMF0pO1xuICB0aGlzLnByaW50X25ld2xpbmUoZmFsc2UsIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyk7XG5cblxuICBpZiAobGluZXMubGVuZ3RoID4gMSkge1xuICAgIGxpbmVzID0gbGluZXMuc2xpY2UoMSk7XG4gICAgamF2YWRvYyA9IGFsbF9saW5lc19zdGFydF93aXRoKGxpbmVzLCAnKicpO1xuICAgIHN0YXJsZXNzID0gZWFjaF9saW5lX21hdGNoZXNfaW5kZW50KGxpbmVzLCBsYXN0SW5kZW50KTtcblxuICAgIGlmIChqYXZhZG9jKSB7XG4gICAgICB0aGlzLl9mbGFncy5hbGlnbm1lbnQgPSAxO1xuICAgIH1cblxuICAgIGZvciAoaiA9IDA7IGogPCBsaW5lcy5sZW5ndGg7IGorKykge1xuICAgICAgaWYgKGphdmFkb2MpIHtcbiAgICAgICAgLy8gamF2YWRvYzogcmVmb3JtYXQgYW5kIHJlLWluZGVudFxuICAgICAgICB0aGlzLnByaW50X3Rva2VuX2xpbmVfaW5kZW50YXRpb24oY3VycmVudF90b2tlbik7XG4gICAgICAgIHRoaXMuX291dHB1dC5hZGRfdG9rZW4obHRyaW0obGluZXNbal0pKTtcbiAgICAgIH0gZWxzZSBpZiAoc3Rhcmxlc3MgJiYgbGluZXNbal0pIHtcbiAgICAgICAgLy8gc3Rhcmxlc3M6IHJlLWluZGVudCBub24tZW1wdHkgY29udGVudCwgYXZvaWRpbmcgdHJpbVxuICAgICAgICB0aGlzLnByaW50X3Rva2VuX2xpbmVfaW5kZW50YXRpb24oY3VycmVudF90b2tlbik7XG4gICAgICAgIHRoaXMuX291dHB1dC5hZGRfdG9rZW4obGluZXNbal0uc3Vic3RyaW5nKGxhc3RJbmRlbnRMZW5ndGgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vcm1hbCBjb21tZW50cyBvdXRwdXQgcmF3XG4gICAgICAgIHRoaXMuX291dHB1dC5jdXJyZW50X2xpbmUuc2V0X2luZGVudCgtMSk7XG4gICAgICAgIHRoaXMuX291dHB1dC5hZGRfdG9rZW4obGluZXNbal0pO1xuICAgICAgfVxuXG4gICAgICAvLyBmb3IgY29tbWVudHMgb24gdGhlaXIgb3duIGxpbmUgb3IgIG1vcmUgdGhhbiBvbmUgbGluZSwgbWFrZSBzdXJlIHRoZXJlJ3MgYSBuZXcgbGluZSBhZnRlclxuICAgICAgdGhpcy5wcmludF9uZXdsaW5lKGZhbHNlLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICAgIH1cblxuICAgIHRoaXMuX2ZsYWdzLmFsaWdubWVudCA9IDA7XG4gIH1cbn07XG5cblxuQmVhdXRpZmllci5wcm90b3R5cGUuaGFuZGxlX2NvbW1lbnQgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpIHtcbiAgaWYgKGN1cnJlbnRfdG9rZW4ubmV3bGluZXMpIHtcbiAgICB0aGlzLnByaW50X25ld2xpbmUoZmFsc2UsIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fb3V0cHV0LnRyaW0odHJ1ZSk7XG4gIH1cblxuICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgdGhpcy5wcmludF90b2tlbihjdXJyZW50X3Rva2VuKTtcbiAgdGhpcy5wcmludF9uZXdsaW5lKGZhbHNlLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuaGFuZGxlX2RvdCA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4pIHtcbiAgaWYgKHRoaXMuc3RhcnRfb2Zfc3RhdGVtZW50KGN1cnJlbnRfdG9rZW4pKSB7XG4gICAgLy8gVGhlIGNvbmRpdGlvbmFsIHN0YXJ0cyB0aGUgc3RhdGVtZW50IGlmIGFwcHJvcHJpYXRlLlxuICB9IGVsc2Uge1xuICAgIHRoaXMuaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzKGN1cnJlbnRfdG9rZW4sIHRydWUpO1xuICB9XG5cbiAgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dC5tYXRjaCgnXlswLTldKyQnKSkge1xuICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICB9XG5cbiAgaWYgKHJlc2VydmVkX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4sIHNwZWNpYWxfd29yZHMpKSB7XG4gICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIC8vIGFsbG93IHByZXNlcnZlZCBuZXdsaW5lcyBiZWZvcmUgZG90cyBpbiBnZW5lcmFsXG4gICAgLy8gZm9yY2UgbmV3bGluZXMgb24gZG90cyBhZnRlciBjbG9zZSBwYXJlbiB3aGVuIGJyZWFrX2NoYWluZWQgLSBmb3IgYmFyKCkuYmF6KClcbiAgICB0aGlzLmFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoY3VycmVudF90b2tlbixcbiAgICAgIHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJyknICYmIHRoaXMuX29wdGlvbnMuYnJlYWtfY2hhaW5lZF9tZXRob2RzKTtcbiAgfVxuXG4gIC8vIE9ubHkgdW5pbmRlbnQgY2hhaW5lZCBtZXRob2QgZG90IGlmIHRoaXMgZG90IHN0YXJ0cyBhIG5ldyBsaW5lLlxuICAvLyBPdGhlcndpc2UgdGhlIGF1dG9tYXRpYyBleHRyYSBpbmRlbnRhdGlvbiByZW1vdmFsIHdpbGwgaGFuZGxlIHRoZSBvdmVyIGluZGVudFxuICBpZiAodGhpcy5fb3B0aW9ucy51bmluZGVudF9jaGFpbmVkX21ldGhvZHMgJiYgdGhpcy5fb3V0cHV0Lmp1c3RfYWRkZWRfbmV3bGluZSgpKSB7XG4gICAgdGhpcy5kZWluZGVudCgpO1xuICB9XG5cbiAgdGhpcy5wcmludF90b2tlbihjdXJyZW50X3Rva2VuKTtcbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmhhbmRsZV91bmtub3duID0gZnVuY3Rpb24oY3VycmVudF90b2tlbiwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKSB7XG4gIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG5cbiAgaWYgKGN1cnJlbnRfdG9rZW4udGV4dFtjdXJyZW50X3Rva2VuLnRleHQubGVuZ3RoIC0gMV0gPT09ICdcXG4nKSB7XG4gICAgdGhpcy5wcmludF9uZXdsaW5lKGZhbHNlLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICB9XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5oYW5kbGVfZW9mID0gZnVuY3Rpb24oY3VycmVudF90b2tlbikge1xuICAvLyBVbndpbmQgYW55IG9wZW4gc3RhdGVtZW50c1xuICB3aGlsZSAodGhpcy5fZmxhZ3MubW9kZSA9PT0gTU9ERS5TdGF0ZW1lbnQpIHtcbiAgICB0aGlzLnJlc3RvcmVfbW9kZSgpO1xuICB9XG4gIHRoaXMuaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzKGN1cnJlbnRfdG9rZW4pO1xufTtcblxubW9kdWxlLmV4cG9ydHMuQmVhdXRpZmllciA9IEJlYXV0aWZpZXI7XG5cblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbmZ1bmN0aW9uIE91dHB1dExpbmUocGFyZW50KSB7XG4gIHRoaXMuX19wYXJlbnQgPSBwYXJlbnQ7XG4gIHRoaXMuX19jaGFyYWN0ZXJfY291bnQgPSAwO1xuICAvLyB1c2UgaW5kZW50X2NvdW50IGFzIGEgbWFya2VyIGZvciB0aGlzLl9fbGluZXMgdGhhdCBoYXZlIHByZXNlcnZlZCBpbmRlbnRhdGlvblxuICB0aGlzLl9faW5kZW50X2NvdW50ID0gLTE7XG4gIHRoaXMuX19hbGlnbm1lbnRfY291bnQgPSAwO1xuICB0aGlzLl9fd3JhcF9wb2ludF9pbmRleCA9IDA7XG4gIHRoaXMuX193cmFwX3BvaW50X2NoYXJhY3Rlcl9jb3VudCA9IDA7XG4gIHRoaXMuX193cmFwX3BvaW50X2luZGVudF9jb3VudCA9IC0xO1xuICB0aGlzLl9fd3JhcF9wb2ludF9hbGlnbm1lbnRfY291bnQgPSAwO1xuXG4gIHRoaXMuX19pdGVtcyA9IFtdO1xufVxuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5jbG9uZV9lbXB0eSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbGluZSA9IG5ldyBPdXRwdXRMaW5lKHRoaXMuX19wYXJlbnQpO1xuICBsaW5lLnNldF9pbmRlbnQodGhpcy5fX2luZGVudF9jb3VudCwgdGhpcy5fX2FsaWdubWVudF9jb3VudCk7XG4gIHJldHVybiBsaW5lO1xufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUuaXRlbSA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gdGhpcy5fX2l0ZW1zW3RoaXMuX19pdGVtcy5sZW5ndGggKyBpbmRleF07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMuX19pdGVtc1tpbmRleF07XG4gIH1cbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLmhhc19tYXRjaCA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgZm9yICh2YXIgbGFzdENoZWNrZWRPdXRwdXQgPSB0aGlzLl9faXRlbXMubGVuZ3RoIC0gMTsgbGFzdENoZWNrZWRPdXRwdXQgPj0gMDsgbGFzdENoZWNrZWRPdXRwdXQtLSkge1xuICAgIGlmICh0aGlzLl9faXRlbXNbbGFzdENoZWNrZWRPdXRwdXRdLm1hdGNoKHBhdHRlcm4pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUuc2V0X2luZGVudCA9IGZ1bmN0aW9uKGluZGVudCwgYWxpZ25tZW50KSB7XG4gIGlmICh0aGlzLmlzX2VtcHR5KCkpIHtcbiAgICB0aGlzLl9faW5kZW50X2NvdW50ID0gaW5kZW50IHx8IDA7XG4gICAgdGhpcy5fX2FsaWdubWVudF9jb3VudCA9IGFsaWdubWVudCB8fCAwO1xuICAgIHRoaXMuX19jaGFyYWN0ZXJfY291bnQgPSB0aGlzLl9fcGFyZW50LmdldF9pbmRlbnRfc2l6ZSh0aGlzLl9faW5kZW50X2NvdW50LCB0aGlzLl9fYWxpZ25tZW50X2NvdW50KTtcbiAgfVxufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUuX3NldF93cmFwX3BvaW50ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9fcGFyZW50LndyYXBfbGluZV9sZW5ndGgpIHtcbiAgICB0aGlzLl9fd3JhcF9wb2ludF9pbmRleCA9IHRoaXMuX19pdGVtcy5sZW5ndGg7XG4gICAgdGhpcy5fX3dyYXBfcG9pbnRfY2hhcmFjdGVyX2NvdW50ID0gdGhpcy5fX2NoYXJhY3Rlcl9jb3VudDtcbiAgICB0aGlzLl9fd3JhcF9wb2ludF9pbmRlbnRfY291bnQgPSB0aGlzLl9fcGFyZW50Lm5leHRfbGluZS5fX2luZGVudF9jb3VudDtcbiAgICB0aGlzLl9fd3JhcF9wb2ludF9hbGlnbm1lbnRfY291bnQgPSB0aGlzLl9fcGFyZW50Lm5leHRfbGluZS5fX2FsaWdubWVudF9jb3VudDtcbiAgfVxufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUuX3Nob3VsZF93cmFwID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9fd3JhcF9wb2ludF9pbmRleCAmJlxuICAgIHRoaXMuX19jaGFyYWN0ZXJfY291bnQgPiB0aGlzLl9fcGFyZW50LndyYXBfbGluZV9sZW5ndGggJiZcbiAgICB0aGlzLl9fd3JhcF9wb2ludF9jaGFyYWN0ZXJfY291bnQgPiB0aGlzLl9fcGFyZW50Lm5leHRfbGluZS5fX2NoYXJhY3Rlcl9jb3VudDtcbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLl9hbGxvd193cmFwID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9zaG91bGRfd3JhcCgpKSB7XG4gICAgdGhpcy5fX3BhcmVudC5hZGRfbmV3X2xpbmUoKTtcbiAgICB2YXIgbmV4dCA9IHRoaXMuX19wYXJlbnQuY3VycmVudF9saW5lO1xuICAgIG5leHQuc2V0X2luZGVudCh0aGlzLl9fd3JhcF9wb2ludF9pbmRlbnRfY291bnQsIHRoaXMuX193cmFwX3BvaW50X2FsaWdubWVudF9jb3VudCk7XG4gICAgbmV4dC5fX2l0ZW1zID0gdGhpcy5fX2l0ZW1zLnNsaWNlKHRoaXMuX193cmFwX3BvaW50X2luZGV4KTtcbiAgICB0aGlzLl9faXRlbXMgPSB0aGlzLl9faXRlbXMuc2xpY2UoMCwgdGhpcy5fX3dyYXBfcG9pbnRfaW5kZXgpO1xuXG4gICAgbmV4dC5fX2NoYXJhY3Rlcl9jb3VudCArPSB0aGlzLl9fY2hhcmFjdGVyX2NvdW50IC0gdGhpcy5fX3dyYXBfcG9pbnRfY2hhcmFjdGVyX2NvdW50O1xuICAgIHRoaXMuX19jaGFyYWN0ZXJfY291bnQgPSB0aGlzLl9fd3JhcF9wb2ludF9jaGFyYWN0ZXJfY291bnQ7XG5cbiAgICBpZiAobmV4dC5fX2l0ZW1zWzBdID09PSBcIiBcIikge1xuICAgICAgbmV4dC5fX2l0ZW1zLnNwbGljZSgwLCAxKTtcbiAgICAgIG5leHQuX19jaGFyYWN0ZXJfY291bnQgLT0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUuaXNfZW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX19pdGVtcy5sZW5ndGggPT09IDA7XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5sYXN0ID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5pc19lbXB0eSgpKSB7XG4gICAgcmV0dXJuIHRoaXMuX19pdGVtc1t0aGlzLl9faXRlbXMubGVuZ3RoIC0gMV07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihpdGVtKSB7XG4gIHRoaXMuX19pdGVtcy5wdXNoKGl0ZW0pO1xuICB2YXIgbGFzdF9uZXdsaW5lX2luZGV4ID0gaXRlbS5sYXN0SW5kZXhPZignXFxuJyk7XG4gIGlmIChsYXN0X25ld2xpbmVfaW5kZXggIT09IC0xKSB7XG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCA9IGl0ZW0ubGVuZ3RoIC0gbGFzdF9uZXdsaW5lX2luZGV4O1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX19jaGFyYWN0ZXJfY291bnQgKz0gaXRlbS5sZW5ndGg7XG4gIH1cbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaXRlbSA9IG51bGw7XG4gIGlmICghdGhpcy5pc19lbXB0eSgpKSB7XG4gICAgaXRlbSA9IHRoaXMuX19pdGVtcy5wb3AoKTtcbiAgICB0aGlzLl9fY2hhcmFjdGVyX2NvdW50IC09IGl0ZW0ubGVuZ3RoO1xuICB9XG4gIHJldHVybiBpdGVtO1xufTtcblxuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5fcmVtb3ZlX2luZGVudCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fX2luZGVudF9jb3VudCA+IDApIHtcbiAgICB0aGlzLl9faW5kZW50X2NvdW50IC09IDE7XG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCAtPSB0aGlzLl9fcGFyZW50LmluZGVudF9zaXplO1xuICB9XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5fcmVtb3ZlX3dyYXBfaW5kZW50ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9fd3JhcF9wb2ludF9pbmRlbnRfY291bnQgPiAwKSB7XG4gICAgdGhpcy5fX3dyYXBfcG9pbnRfaW5kZW50X2NvdW50IC09IDE7XG4gIH1cbn07XG5PdXRwdXRMaW5lLnByb3RvdHlwZS50cmltID0gZnVuY3Rpb24oKSB7XG4gIHdoaWxlICh0aGlzLmxhc3QoKSA9PT0gJyAnKSB7XG4gICAgdGhpcy5fX2l0ZW1zLnBvcCgpO1xuICAgIHRoaXMuX19jaGFyYWN0ZXJfY291bnQgLT0gMTtcbiAgfVxufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBpZiAodGhpcy5pc19lbXB0eSgpKSB7XG4gICAgaWYgKHRoaXMuX19wYXJlbnQuaW5kZW50X2VtcHR5X2xpbmVzKSB7XG4gICAgICByZXN1bHQgPSB0aGlzLl9fcGFyZW50LmdldF9pbmRlbnRfc3RyaW5nKHRoaXMuX19pbmRlbnRfY291bnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSB0aGlzLl9fcGFyZW50LmdldF9pbmRlbnRfc3RyaW5nKHRoaXMuX19pbmRlbnRfY291bnQsIHRoaXMuX19hbGlnbm1lbnRfY291bnQpO1xuICAgIHJlc3VsdCArPSB0aGlzLl9faXRlbXMuam9pbignJyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmZ1bmN0aW9uIEluZGVudFN0cmluZ0NhY2hlKG9wdGlvbnMsIGJhc2VJbmRlbnRTdHJpbmcpIHtcbiAgdGhpcy5fX2NhY2hlID0gWycnXTtcbiAgdGhpcy5fX2luZGVudF9zaXplID0gb3B0aW9ucy5pbmRlbnRfc2l6ZTtcbiAgdGhpcy5fX2luZGVudF9zdHJpbmcgPSBvcHRpb25zLmluZGVudF9jaGFyO1xuICBpZiAoIW9wdGlvbnMuaW5kZW50X3dpdGhfdGFicykge1xuICAgIHRoaXMuX19pbmRlbnRfc3RyaW5nID0gbmV3IEFycmF5KG9wdGlvbnMuaW5kZW50X3NpemUgKyAxKS5qb2luKG9wdGlvbnMuaW5kZW50X2NoYXIpO1xuICB9XG5cbiAgLy8gU2V0IHRvIG51bGwgdG8gY29udGludWUgc3VwcG9ydCBmb3IgYXV0byBkZXRlY3Rpb24gb2YgYmFzZSBpbmRlbnRcbiAgYmFzZUluZGVudFN0cmluZyA9IGJhc2VJbmRlbnRTdHJpbmcgfHwgJyc7XG4gIGlmIChvcHRpb25zLmluZGVudF9sZXZlbCA+IDApIHtcbiAgICBiYXNlSW5kZW50U3RyaW5nID0gbmV3IEFycmF5KG9wdGlvbnMuaW5kZW50X2xldmVsICsgMSkuam9pbih0aGlzLl9faW5kZW50X3N0cmluZyk7XG4gIH1cblxuICB0aGlzLl9fYmFzZV9zdHJpbmcgPSBiYXNlSW5kZW50U3RyaW5nO1xuICB0aGlzLl9fYmFzZV9zdHJpbmdfbGVuZ3RoID0gYmFzZUluZGVudFN0cmluZy5sZW5ndGg7XG59XG5cbkluZGVudFN0cmluZ0NhY2hlLnByb3RvdHlwZS5nZXRfaW5kZW50X3NpemUgPSBmdW5jdGlvbihpbmRlbnQsIGNvbHVtbikge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fX2Jhc2Vfc3RyaW5nX2xlbmd0aDtcbiAgY29sdW1uID0gY29sdW1uIHx8IDA7XG4gIGlmIChpbmRlbnQgPCAwKSB7XG4gICAgcmVzdWx0ID0gMDtcbiAgfVxuICByZXN1bHQgKz0gaW5kZW50ICogdGhpcy5fX2luZGVudF9zaXplO1xuICByZXN1bHQgKz0gY29sdW1uO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuSW5kZW50U3RyaW5nQ2FjaGUucHJvdG90eXBlLmdldF9pbmRlbnRfc3RyaW5nID0gZnVuY3Rpb24oaW5kZW50X2xldmVsLCBjb2x1bW4pIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuX19iYXNlX3N0cmluZztcbiAgY29sdW1uID0gY29sdW1uIHx8IDA7XG4gIGlmIChpbmRlbnRfbGV2ZWwgPCAwKSB7XG4gICAgaW5kZW50X2xldmVsID0gMDtcbiAgICByZXN1bHQgPSAnJztcbiAgfVxuICBjb2x1bW4gKz0gaW5kZW50X2xldmVsICogdGhpcy5fX2luZGVudF9zaXplO1xuICB0aGlzLl9fZW5zdXJlX2NhY2hlKGNvbHVtbik7XG4gIHJlc3VsdCArPSB0aGlzLl9fY2FjaGVbY29sdW1uXTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbkluZGVudFN0cmluZ0NhY2hlLnByb3RvdHlwZS5fX2Vuc3VyZV9jYWNoZSA9IGZ1bmN0aW9uKGNvbHVtbikge1xuICB3aGlsZSAoY29sdW1uID49IHRoaXMuX19jYWNoZS5sZW5ndGgpIHtcbiAgICB0aGlzLl9fYWRkX2NvbHVtbigpO1xuICB9XG59O1xuXG5JbmRlbnRTdHJpbmdDYWNoZS5wcm90b3R5cGUuX19hZGRfY29sdW1uID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjb2x1bW4gPSB0aGlzLl9fY2FjaGUubGVuZ3RoO1xuICB2YXIgaW5kZW50ID0gMDtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBpZiAodGhpcy5fX2luZGVudF9zaXplICYmIGNvbHVtbiA+PSB0aGlzLl9faW5kZW50X3NpemUpIHtcbiAgICBpbmRlbnQgPSBNYXRoLmZsb29yKGNvbHVtbiAvIHRoaXMuX19pbmRlbnRfc2l6ZSk7XG4gICAgY29sdW1uIC09IGluZGVudCAqIHRoaXMuX19pbmRlbnRfc2l6ZTtcbiAgICByZXN1bHQgPSBuZXcgQXJyYXkoaW5kZW50ICsgMSkuam9pbih0aGlzLl9faW5kZW50X3N0cmluZyk7XG4gIH1cbiAgaWYgKGNvbHVtbikge1xuICAgIHJlc3VsdCArPSBuZXcgQXJyYXkoY29sdW1uICsgMSkuam9pbignICcpO1xuICB9XG5cbiAgdGhpcy5fX2NhY2hlLnB1c2gocmVzdWx0KTtcbn07XG5cbmZ1bmN0aW9uIE91dHB1dChvcHRpb25zLCBiYXNlSW5kZW50U3RyaW5nKSB7XG4gIHRoaXMuX19pbmRlbnRfY2FjaGUgPSBuZXcgSW5kZW50U3RyaW5nQ2FjaGUob3B0aW9ucywgYmFzZUluZGVudFN0cmluZyk7XG4gIHRoaXMucmF3ID0gZmFsc2U7XG4gIHRoaXMuX2VuZF93aXRoX25ld2xpbmUgPSBvcHRpb25zLmVuZF93aXRoX25ld2xpbmU7XG4gIHRoaXMuaW5kZW50X3NpemUgPSBvcHRpb25zLmluZGVudF9zaXplO1xuICB0aGlzLndyYXBfbGluZV9sZW5ndGggPSBvcHRpb25zLndyYXBfbGluZV9sZW5ndGg7XG4gIHRoaXMuaW5kZW50X2VtcHR5X2xpbmVzID0gb3B0aW9ucy5pbmRlbnRfZW1wdHlfbGluZXM7XG4gIHRoaXMuX19saW5lcyA9IFtdO1xuICB0aGlzLnByZXZpb3VzX2xpbmUgPSBudWxsO1xuICB0aGlzLmN1cnJlbnRfbGluZSA9IG51bGw7XG4gIHRoaXMubmV4dF9saW5lID0gbmV3IE91dHB1dExpbmUodGhpcyk7XG4gIHRoaXMuc3BhY2VfYmVmb3JlX3Rva2VuID0gZmFsc2U7XG4gIHRoaXMubm9uX2JyZWFraW5nX3NwYWNlID0gZmFsc2U7XG4gIHRoaXMucHJldmlvdXNfdG9rZW5fd3JhcHBlZCA9IGZhbHNlO1xuICAvLyBpbml0aWFsaXplXG4gIHRoaXMuX19hZGRfb3V0cHV0bGluZSgpO1xufVxuXG5PdXRwdXQucHJvdG90eXBlLl9fYWRkX291dHB1dGxpbmUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5wcmV2aW91c19saW5lID0gdGhpcy5jdXJyZW50X2xpbmU7XG4gIHRoaXMuY3VycmVudF9saW5lID0gdGhpcy5uZXh0X2xpbmUuY2xvbmVfZW1wdHkoKTtcbiAgdGhpcy5fX2xpbmVzLnB1c2godGhpcy5jdXJyZW50X2xpbmUpO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5nZXRfbGluZV9udW1iZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX19saW5lcy5sZW5ndGg7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmdldF9pbmRlbnRfc3RyaW5nID0gZnVuY3Rpb24oaW5kZW50LCBjb2x1bW4pIHtcbiAgcmV0dXJuIHRoaXMuX19pbmRlbnRfY2FjaGUuZ2V0X2luZGVudF9zdHJpbmcoaW5kZW50LCBjb2x1bW4pO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5nZXRfaW5kZW50X3NpemUgPSBmdW5jdGlvbihpbmRlbnQsIGNvbHVtbikge1xuICByZXR1cm4gdGhpcy5fX2luZGVudF9jYWNoZS5nZXRfaW5kZW50X3NpemUoaW5kZW50LCBjb2x1bW4pO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5pc19lbXB0eSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gIXRoaXMucHJldmlvdXNfbGluZSAmJiB0aGlzLmN1cnJlbnRfbGluZS5pc19lbXB0eSgpO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5hZGRfbmV3X2xpbmUgPSBmdW5jdGlvbihmb3JjZV9uZXdsaW5lKSB7XG4gIC8vIG5ldmVyIG5ld2xpbmUgYXQgdGhlIHN0YXJ0IG9mIGZpbGVcbiAgLy8gb3RoZXJ3aXNlLCBuZXdsaW5lIG9ubHkgaWYgd2UgZGlkbid0IGp1c3QgYWRkIG9uZSBvciB3ZSdyZSBmb3JjZWRcbiAgaWYgKHRoaXMuaXNfZW1wdHkoKSB8fFxuICAgICghZm9yY2VfbmV3bGluZSAmJiB0aGlzLmp1c3RfYWRkZWRfbmV3bGluZSgpKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGlmIHJhdyBvdXRwdXQgaXMgZW5hYmxlZCwgZG9uJ3QgcHJpbnQgYWRkaXRpb25hbCBuZXdsaW5lcyxcbiAgLy8gYnV0IHN0aWxsIHJldHVybiBUcnVlIGFzIHRob3VnaCB5b3UgaGFkXG4gIGlmICghdGhpcy5yYXcpIHtcbiAgICB0aGlzLl9fYWRkX291dHB1dGxpbmUoKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuZ2V0X2NvZGUgPSBmdW5jdGlvbihlb2wpIHtcbiAgdGhpcy50cmltKHRydWUpO1xuXG4gIC8vIGhhbmRsZSBzb21lIGVkZ2UgY2FzZXMgd2hlcmUgdGhlIGxhc3QgdG9rZW5zXG4gIC8vIGhhcyB0ZXh0IHRoYXQgZW5kcyB3aXRoIG5ld2xpbmUocylcbiAgdmFyIGxhc3RfaXRlbSA9IHRoaXMuY3VycmVudF9saW5lLnBvcCgpO1xuICBpZiAobGFzdF9pdGVtKSB7XG4gICAgaWYgKGxhc3RfaXRlbVtsYXN0X2l0ZW0ubGVuZ3RoIC0gMV0gPT09ICdcXG4nKSB7XG4gICAgICBsYXN0X2l0ZW0gPSBsYXN0X2l0ZW0ucmVwbGFjZSgvXFxuKyQvZywgJycpO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRfbGluZS5wdXNoKGxhc3RfaXRlbSk7XG4gIH1cblxuICBpZiAodGhpcy5fZW5kX3dpdGhfbmV3bGluZSkge1xuICAgIHRoaXMuX19hZGRfb3V0cHV0bGluZSgpO1xuICB9XG5cbiAgdmFyIHN3ZWV0X2NvZGUgPSB0aGlzLl9fbGluZXMuam9pbignXFxuJyk7XG5cbiAgaWYgKGVvbCAhPT0gJ1xcbicpIHtcbiAgICBzd2VldF9jb2RlID0gc3dlZXRfY29kZS5yZXBsYWNlKC9bXFxuXS9nLCBlb2wpO1xuICB9XG4gIHJldHVybiBzd2VldF9jb2RlO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5zZXRfd3JhcF9wb2ludCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmN1cnJlbnRfbGluZS5fc2V0X3dyYXBfcG9pbnQoKTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuc2V0X2luZGVudCA9IGZ1bmN0aW9uKGluZGVudCwgYWxpZ25tZW50KSB7XG4gIGluZGVudCA9IGluZGVudCB8fCAwO1xuICBhbGlnbm1lbnQgPSBhbGlnbm1lbnQgfHwgMDtcblxuICAvLyBOZXh0IGxpbmUgc3RvcmVzIGFsaWdubWVudCB2YWx1ZXNcbiAgdGhpcy5uZXh0X2xpbmUuc2V0X2luZGVudChpbmRlbnQsIGFsaWdubWVudCk7XG5cbiAgLy8gTmV2ZXIgaW5kZW50IHlvdXIgZmlyc3Qgb3V0cHV0IGluZGVudCBhdCB0aGUgc3RhcnQgb2YgdGhlIGZpbGVcbiAgaWYgKHRoaXMuX19saW5lcy5sZW5ndGggPiAxKSB7XG4gICAgdGhpcy5jdXJyZW50X2xpbmUuc2V0X2luZGVudChpbmRlbnQsIGFsaWdubWVudCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB0aGlzLmN1cnJlbnRfbGluZS5zZXRfaW5kZW50KCk7XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuYWRkX3Jhd190b2tlbiA9IGZ1bmN0aW9uKHRva2VuKSB7XG4gIGZvciAodmFyIHggPSAwOyB4IDwgdG9rZW4ubmV3bGluZXM7IHgrKykge1xuICAgIHRoaXMuX19hZGRfb3V0cHV0bGluZSgpO1xuICB9XG4gIHRoaXMuY3VycmVudF9saW5lLnNldF9pbmRlbnQoLTEpO1xuICB0aGlzLmN1cnJlbnRfbGluZS5wdXNoKHRva2VuLndoaXRlc3BhY2VfYmVmb3JlKTtcbiAgdGhpcy5jdXJyZW50X2xpbmUucHVzaCh0b2tlbi50ZXh0KTtcbiAgdGhpcy5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcbiAgdGhpcy5ub25fYnJlYWtpbmdfc3BhY2UgPSBmYWxzZTtcbiAgdGhpcy5wcmV2aW91c190b2tlbl93cmFwcGVkID0gZmFsc2U7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmFkZF90b2tlbiA9IGZ1bmN0aW9uKHByaW50YWJsZV90b2tlbikge1xuICB0aGlzLl9fYWRkX3NwYWNlX2JlZm9yZV90b2tlbigpO1xuICB0aGlzLmN1cnJlbnRfbGluZS5wdXNoKHByaW50YWJsZV90b2tlbik7XG4gIHRoaXMuc3BhY2VfYmVmb3JlX3Rva2VuID0gZmFsc2U7XG4gIHRoaXMubm9uX2JyZWFraW5nX3NwYWNlID0gZmFsc2U7XG4gIHRoaXMucHJldmlvdXNfdG9rZW5fd3JhcHBlZCA9IHRoaXMuY3VycmVudF9saW5lLl9hbGxvd193cmFwKCk7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLl9fYWRkX3NwYWNlX2JlZm9yZV90b2tlbiA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5zcGFjZV9iZWZvcmVfdG9rZW4gJiYgIXRoaXMuanVzdF9hZGRlZF9uZXdsaW5lKCkpIHtcbiAgICBpZiAoIXRoaXMubm9uX2JyZWFraW5nX3NwYWNlKSB7XG4gICAgICB0aGlzLnNldF93cmFwX3BvaW50KCk7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudF9saW5lLnB1c2goJyAnKTtcbiAgfVxufTtcblxuT3V0cHV0LnByb3RvdHlwZS5yZW1vdmVfaW5kZW50ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgdmFyIG91dHB1dF9sZW5ndGggPSB0aGlzLl9fbGluZXMubGVuZ3RoO1xuICB3aGlsZSAoaW5kZXggPCBvdXRwdXRfbGVuZ3RoKSB7XG4gICAgdGhpcy5fX2xpbmVzW2luZGV4XS5fcmVtb3ZlX2luZGVudCgpO1xuICAgIGluZGV4Kys7XG4gIH1cbiAgdGhpcy5jdXJyZW50X2xpbmUuX3JlbW92ZV93cmFwX2luZGVudCgpO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS50cmltID0gZnVuY3Rpb24oZWF0X25ld2xpbmVzKSB7XG4gIGVhdF9uZXdsaW5lcyA9IChlYXRfbmV3bGluZXMgPT09IHVuZGVmaW5lZCkgPyBmYWxzZSA6IGVhdF9uZXdsaW5lcztcblxuICB0aGlzLmN1cnJlbnRfbGluZS50cmltKCk7XG5cbiAgd2hpbGUgKGVhdF9uZXdsaW5lcyAmJiB0aGlzLl9fbGluZXMubGVuZ3RoID4gMSAmJlxuICAgIHRoaXMuY3VycmVudF9saW5lLmlzX2VtcHR5KCkpIHtcbiAgICB0aGlzLl9fbGluZXMucG9wKCk7XG4gICAgdGhpcy5jdXJyZW50X2xpbmUgPSB0aGlzLl9fbGluZXNbdGhpcy5fX2xpbmVzLmxlbmd0aCAtIDFdO1xuICAgIHRoaXMuY3VycmVudF9saW5lLnRyaW0oKTtcbiAgfVxuXG4gIHRoaXMucHJldmlvdXNfbGluZSA9IHRoaXMuX19saW5lcy5sZW5ndGggPiAxID9cbiAgICB0aGlzLl9fbGluZXNbdGhpcy5fX2xpbmVzLmxlbmd0aCAtIDJdIDogbnVsbDtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuanVzdF9hZGRlZF9uZXdsaW5lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmN1cnJlbnRfbGluZS5pc19lbXB0eSgpO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5qdXN0X2FkZGVkX2JsYW5rbGluZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5pc19lbXB0eSgpIHx8XG4gICAgKHRoaXMuY3VycmVudF9saW5lLmlzX2VtcHR5KCkgJiYgdGhpcy5wcmV2aW91c19saW5lLmlzX2VtcHR5KCkpO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5lbnN1cmVfZW1wdHlfbGluZV9hYm92ZSA9IGZ1bmN0aW9uKHN0YXJ0c193aXRoLCBlbmRzX3dpdGgpIHtcbiAgdmFyIGluZGV4ID0gdGhpcy5fX2xpbmVzLmxlbmd0aCAtIDI7XG4gIHdoaWxlIChpbmRleCA+PSAwKSB7XG4gICAgdmFyIHBvdGVudGlhbEVtcHR5TGluZSA9IHRoaXMuX19saW5lc1tpbmRleF07XG4gICAgaWYgKHBvdGVudGlhbEVtcHR5TGluZS5pc19lbXB0eSgpKSB7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2UgaWYgKHBvdGVudGlhbEVtcHR5TGluZS5pdGVtKDApLmluZGV4T2Yoc3RhcnRzX3dpdGgpICE9PSAwICYmXG4gICAgICBwb3RlbnRpYWxFbXB0eUxpbmUuaXRlbSgtMSkgIT09IGVuZHNfd2l0aCkge1xuICAgICAgdGhpcy5fX2xpbmVzLnNwbGljZShpbmRleCArIDEsIDAsIG5ldyBPdXRwdXRMaW5lKHRoaXMpKTtcbiAgICAgIHRoaXMucHJldmlvdXNfbGluZSA9IHRoaXMuX19saW5lc1t0aGlzLl9fbGluZXMubGVuZ3RoIC0gMl07XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaW5kZXgtLTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuT3V0cHV0ID0gT3V0cHV0O1xuXG5cbi8qKiovIH0pLFxuLyogMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbmZ1bmN0aW9uIFRva2VuKHR5cGUsIHRleHQsIG5ld2xpbmVzLCB3aGl0ZXNwYWNlX2JlZm9yZSkge1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnRleHQgPSB0ZXh0O1xuXG4gIC8vIGNvbW1lbnRzX2JlZm9yZSBhcmVcbiAgLy8gY29tbWVudHMgdGhhdCBoYXZlIGEgbmV3IGxpbmUgYmVmb3JlIHRoZW1cbiAgLy8gYW5kIG1heSBvciBtYXkgbm90IGhhdmUgYSBuZXdsaW5lIGFmdGVyXG4gIC8vIHRoaXMgaXMgYSBzZXQgb2YgY29tbWVudHMgYmVmb3JlXG4gIHRoaXMuY29tbWVudHNfYmVmb3JlID0gbnVsbDsgLyogaW5saW5lIGNvbW1lbnQqL1xuXG5cbiAgLy8gdGhpcy5jb21tZW50c19hZnRlciA9ICBuZXcgVG9rZW5TdHJlYW0oKTsgLy8gbm8gbmV3IGxpbmUgYmVmb3JlIGFuZCBuZXdsaW5lIGFmdGVyXG4gIHRoaXMubmV3bGluZXMgPSBuZXdsaW5lcyB8fCAwO1xuICB0aGlzLndoaXRlc3BhY2VfYmVmb3JlID0gd2hpdGVzcGFjZV9iZWZvcmUgfHwgJyc7XG4gIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5wcmV2aW91cyA9IG51bGw7XG4gIHRoaXMub3BlbmVkID0gbnVsbDtcbiAgdGhpcy5jbG9zZWQgPSBudWxsO1xuICB0aGlzLmRpcmVjdGl2ZXMgPSBudWxsO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzLlRva2VuID0gVG9rZW47XG5cblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoganNoaW50IG5vZGU6IHRydWUsIGN1cmx5OiBmYWxzZSAqL1xuLy8gUGFydHMgb2YgdGhpcyBzZWN0aW9uIG9mIGNvZGUgaXMgdGFrZW4gZnJvbSBhY29ybi5cbi8vXG4vLyBBY29ybiB3YXMgd3JpdHRlbiBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCByZWxlYXNlZCB1bmRlciBhbiBNSVRcbi8vIGxpY2Vuc2UuIFRoZSBVbmljb2RlIHJlZ2V4cHMgKGZvciBpZGVudGlmaWVycyBhbmQgd2hpdGVzcGFjZSkgd2VyZVxuLy8gdGFrZW4gZnJvbSBbRXNwcmltYV0oaHR0cDovL2VzcHJpbWEub3JnKSBieSBBcml5YSBIaWRheWF0LlxuLy9cbi8vIEdpdCByZXBvc2l0b3JpZXMgZm9yIEFjb3JuIGFyZSBhdmFpbGFibGUgYXRcbi8vXG4vLyAgICAgaHR0cDovL21hcmlqbmhhdmVyYmVrZS5ubC9naXQvYWNvcm5cbi8vICAgICBodHRwczovL2dpdGh1Yi5jb20vbWFyaWpuaC9hY29ybi5naXRcblxuLy8gIyMgQ2hhcmFjdGVyIGNhdGVnb3JpZXNcblxuXG5cblxuLy8gYWNvcm4gdXNlZCBjaGFyIGNvZGVzIHRvIHNxdWVlemUgdGhlIGxhc3QgYml0IG9mIHBlcmZvcm1hbmNlIG91dFxuLy8gQmVhdXRpZmllciBpcyBva2F5IHdpdGhvdXQgdGhhdCwgc28gd2UncmUgdXNpbmcgcmVnZXhcbi8vIHBlcm1pdCAjICgyMyksICQgKDM2KSwgYW5kIEAgKDY0KS4gQCBpcyB1c2VkIGluIEVTNyBkZWNvcmF0b3JzLlxuLy8gNjUgdGhyb3VnaCA5MSBhcmUgdXBwZXJjYXNlIGxldHRlcnMuXG4vLyBwZXJtaXQgXyAoOTUpLlxuLy8gOTcgdGhyb3VnaCAxMjMgYXJlIGxvd2VyY2FzZSBsZXR0ZXJzLlxudmFyIGJhc2VBU0NJSWlkZW50aWZpZXJTdGFydENoYXJzID0gXCJcXFxceDIzXFxcXHgyNFxcXFx4NDBcXFxceDQxLVxcXFx4NWFcXFxceDVmXFxcXHg2MS1cXFxceDdhXCI7XG5cbi8vIGluc2lkZSBhbiBpZGVudGlmaWVyIEAgaXMgbm90IGFsbG93ZWQgYnV0IDAtOSBhcmUuXG52YXIgYmFzZUFTQ0lJaWRlbnRpZmllckNoYXJzID0gXCJcXFxceDI0XFxcXHgzMC1cXFxceDM5XFxcXHg0MS1cXFxceDVhXFxcXHg1ZlxcXFx4NjEtXFxcXHg3YVwiO1xuXG4vLyBCaWcgdWdseSByZWd1bGFyIGV4cHJlc3Npb25zIHRoYXQgbWF0Y2ggY2hhcmFjdGVycyBpbiB0aGVcbi8vIHdoaXRlc3BhY2UsIGlkZW50aWZpZXIsIGFuZCBpZGVudGlmaWVyLXN0YXJ0IGNhdGVnb3JpZXMuIFRoZXNlXG4vLyBhcmUgb25seSBhcHBsaWVkIHdoZW4gYSBjaGFyYWN0ZXIgaXMgZm91bmQgdG8gYWN0dWFsbHkgaGF2ZSBhXG4vLyBjb2RlIHBvaW50IGFib3ZlIDEyOC5cbnZhciBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzID0gXCJcXFxceGFhXFxcXHhiNVxcXFx4YmFcXFxceGMwLVxcXFx4ZDZcXFxceGQ4LVxcXFx4ZjZcXFxceGY4LVxcXFx1MDJjMVxcXFx1MDJjNi1cXFxcdTAyZDFcXFxcdTAyZTAtXFxcXHUwMmU0XFxcXHUwMmVjXFxcXHUwMmVlXFxcXHUwMzcwLVxcXFx1MDM3NFxcXFx1MDM3NlxcXFx1MDM3N1xcXFx1MDM3YS1cXFxcdTAzN2RcXFxcdTAzODZcXFxcdTAzODgtXFxcXHUwMzhhXFxcXHUwMzhjXFxcXHUwMzhlLVxcXFx1MDNhMVxcXFx1MDNhMy1cXFxcdTAzZjVcXFxcdTAzZjctXFxcXHUwNDgxXFxcXHUwNDhhLVxcXFx1MDUyN1xcXFx1MDUzMS1cXFxcdTA1NTZcXFxcdTA1NTlcXFxcdTA1NjEtXFxcXHUwNTg3XFxcXHUwNWQwLVxcXFx1MDVlYVxcXFx1MDVmMC1cXFxcdTA1ZjJcXFxcdTA2MjAtXFxcXHUwNjRhXFxcXHUwNjZlXFxcXHUwNjZmXFxcXHUwNjcxLVxcXFx1MDZkM1xcXFx1MDZkNVxcXFx1MDZlNVxcXFx1MDZlNlxcXFx1MDZlZVxcXFx1MDZlZlxcXFx1MDZmYS1cXFxcdTA2ZmNcXFxcdTA2ZmZcXFxcdTA3MTBcXFxcdTA3MTItXFxcXHUwNzJmXFxcXHUwNzRkLVxcXFx1MDdhNVxcXFx1MDdiMVxcXFx1MDdjYS1cXFxcdTA3ZWFcXFxcdTA3ZjRcXFxcdTA3ZjVcXFxcdTA3ZmFcXFxcdTA4MDAtXFxcXHUwODE1XFxcXHUwODFhXFxcXHUwODI0XFxcXHUwODI4XFxcXHUwODQwLVxcXFx1MDg1OFxcXFx1MDhhMFxcXFx1MDhhMi1cXFxcdTA4YWNcXFxcdTA5MDQtXFxcXHUwOTM5XFxcXHUwOTNkXFxcXHUwOTUwXFxcXHUwOTU4LVxcXFx1MDk2MVxcXFx1MDk3MS1cXFxcdTA5NzdcXFxcdTA5NzktXFxcXHUwOTdmXFxcXHUwOTg1LVxcXFx1MDk4Y1xcXFx1MDk4ZlxcXFx1MDk5MFxcXFx1MDk5My1cXFxcdTA5YThcXFxcdTA5YWEtXFxcXHUwOWIwXFxcXHUwOWIyXFxcXHUwOWI2LVxcXFx1MDliOVxcXFx1MDliZFxcXFx1MDljZVxcXFx1MDlkY1xcXFx1MDlkZFxcXFx1MDlkZi1cXFxcdTA5ZTFcXFxcdTA5ZjBcXFxcdTA5ZjFcXFxcdTBhMDUtXFxcXHUwYTBhXFxcXHUwYTBmXFxcXHUwYTEwXFxcXHUwYTEzLVxcXFx1MGEyOFxcXFx1MGEyYS1cXFxcdTBhMzBcXFxcdTBhMzJcXFxcdTBhMzNcXFxcdTBhMzVcXFxcdTBhMzZcXFxcdTBhMzhcXFxcdTBhMzlcXFxcdTBhNTktXFxcXHUwYTVjXFxcXHUwYTVlXFxcXHUwYTcyLVxcXFx1MGE3NFxcXFx1MGE4NS1cXFxcdTBhOGRcXFxcdTBhOGYtXFxcXHUwYTkxXFxcXHUwYTkzLVxcXFx1MGFhOFxcXFx1MGFhYS1cXFxcdTBhYjBcXFxcdTBhYjJcXFxcdTBhYjNcXFxcdTBhYjUtXFxcXHUwYWI5XFxcXHUwYWJkXFxcXHUwYWQwXFxcXHUwYWUwXFxcXHUwYWUxXFxcXHUwYjA1LVxcXFx1MGIwY1xcXFx1MGIwZlxcXFx1MGIxMFxcXFx1MGIxMy1cXFxcdTBiMjhcXFxcdTBiMmEtXFxcXHUwYjMwXFxcXHUwYjMyXFxcXHUwYjMzXFxcXHUwYjM1LVxcXFx1MGIzOVxcXFx1MGIzZFxcXFx1MGI1Y1xcXFx1MGI1ZFxcXFx1MGI1Zi1cXFxcdTBiNjFcXFxcdTBiNzFcXFxcdTBiODNcXFxcdTBiODUtXFxcXHUwYjhhXFxcXHUwYjhlLVxcXFx1MGI5MFxcXFx1MGI5Mi1cXFxcdTBiOTVcXFxcdTBiOTlcXFxcdTBiOWFcXFxcdTBiOWNcXFxcdTBiOWVcXFxcdTBiOWZcXFxcdTBiYTNcXFxcdTBiYTRcXFxcdTBiYTgtXFxcXHUwYmFhXFxcXHUwYmFlLVxcXFx1MGJiOVxcXFx1MGJkMFxcXFx1MGMwNS1cXFxcdTBjMGNcXFxcdTBjMGUtXFxcXHUwYzEwXFxcXHUwYzEyLVxcXFx1MGMyOFxcXFx1MGMyYS1cXFxcdTBjMzNcXFxcdTBjMzUtXFxcXHUwYzM5XFxcXHUwYzNkXFxcXHUwYzU4XFxcXHUwYzU5XFxcXHUwYzYwXFxcXHUwYzYxXFxcXHUwYzg1LVxcXFx1MGM4Y1xcXFx1MGM4ZS1cXFxcdTBjOTBcXFxcdTBjOTItXFxcXHUwY2E4XFxcXHUwY2FhLVxcXFx1MGNiM1xcXFx1MGNiNS1cXFxcdTBjYjlcXFxcdTBjYmRcXFxcdTBjZGVcXFxcdTBjZTBcXFxcdTBjZTFcXFxcdTBjZjFcXFxcdTBjZjJcXFxcdTBkMDUtXFxcXHUwZDBjXFxcXHUwZDBlLVxcXFx1MGQxMFxcXFx1MGQxMi1cXFxcdTBkM2FcXFxcdTBkM2RcXFxcdTBkNGVcXFxcdTBkNjBcXFxcdTBkNjFcXFxcdTBkN2EtXFxcXHUwZDdmXFxcXHUwZDg1LVxcXFx1MGQ5NlxcXFx1MGQ5YS1cXFxcdTBkYjFcXFxcdTBkYjMtXFxcXHUwZGJiXFxcXHUwZGJkXFxcXHUwZGMwLVxcXFx1MGRjNlxcXFx1MGUwMS1cXFxcdTBlMzBcXFxcdTBlMzJcXFxcdTBlMzNcXFxcdTBlNDAtXFxcXHUwZTQ2XFxcXHUwZTgxXFxcXHUwZTgyXFxcXHUwZTg0XFxcXHUwZTg3XFxcXHUwZTg4XFxcXHUwZThhXFxcXHUwZThkXFxcXHUwZTk0LVxcXFx1MGU5N1xcXFx1MGU5OS1cXFxcdTBlOWZcXFxcdTBlYTEtXFxcXHUwZWEzXFxcXHUwZWE1XFxcXHUwZWE3XFxcXHUwZWFhXFxcXHUwZWFiXFxcXHUwZWFkLVxcXFx1MGViMFxcXFx1MGViMlxcXFx1MGViM1xcXFx1MGViZFxcXFx1MGVjMC1cXFxcdTBlYzRcXFxcdTBlYzZcXFxcdTBlZGMtXFxcXHUwZWRmXFxcXHUwZjAwXFxcXHUwZjQwLVxcXFx1MGY0N1xcXFx1MGY0OS1cXFxcdTBmNmNcXFxcdTBmODgtXFxcXHUwZjhjXFxcXHUxMDAwLVxcXFx1MTAyYVxcXFx1MTAzZlxcXFx1MTA1MC1cXFxcdTEwNTVcXFxcdTEwNWEtXFxcXHUxMDVkXFxcXHUxMDYxXFxcXHUxMDY1XFxcXHUxMDY2XFxcXHUxMDZlLVxcXFx1MTA3MFxcXFx1MTA3NS1cXFxcdTEwODFcXFxcdTEwOGVcXFxcdTEwYTAtXFxcXHUxMGM1XFxcXHUxMGM3XFxcXHUxMGNkXFxcXHUxMGQwLVxcXFx1MTBmYVxcXFx1MTBmYy1cXFxcdTEyNDhcXFxcdTEyNGEtXFxcXHUxMjRkXFxcXHUxMjUwLVxcXFx1MTI1NlxcXFx1MTI1OFxcXFx1MTI1YS1cXFxcdTEyNWRcXFxcdTEyNjAtXFxcXHUxMjg4XFxcXHUxMjhhLVxcXFx1MTI4ZFxcXFx1MTI5MC1cXFxcdTEyYjBcXFxcdTEyYjItXFxcXHUxMmI1XFxcXHUxMmI4LVxcXFx1MTJiZVxcXFx1MTJjMFxcXFx1MTJjMi1cXFxcdTEyYzVcXFxcdTEyYzgtXFxcXHUxMmQ2XFxcXHUxMmQ4LVxcXFx1MTMxMFxcXFx1MTMxMi1cXFxcdTEzMTVcXFxcdTEzMTgtXFxcXHUxMzVhXFxcXHUxMzgwLVxcXFx1MTM4ZlxcXFx1MTNhMC1cXFxcdTEzZjRcXFxcdTE0MDEtXFxcXHUxNjZjXFxcXHUxNjZmLVxcXFx1MTY3ZlxcXFx1MTY4MS1cXFxcdTE2OWFcXFxcdTE2YTAtXFxcXHUxNmVhXFxcXHUxNmVlLVxcXFx1MTZmMFxcXFx1MTcwMC1cXFxcdTE3MGNcXFxcdTE3MGUtXFxcXHUxNzExXFxcXHUxNzIwLVxcXFx1MTczMVxcXFx1MTc0MC1cXFxcdTE3NTFcXFxcdTE3NjAtXFxcXHUxNzZjXFxcXHUxNzZlLVxcXFx1MTc3MFxcXFx1MTc4MC1cXFxcdTE3YjNcXFxcdTE3ZDdcXFxcdTE3ZGNcXFxcdTE4MjAtXFxcXHUxODc3XFxcXHUxODgwLVxcXFx1MThhOFxcXFx1MThhYVxcXFx1MThiMC1cXFxcdTE4ZjVcXFxcdTE5MDAtXFxcXHUxOTFjXFxcXHUxOTUwLVxcXFx1MTk2ZFxcXFx1MTk3MC1cXFxcdTE5NzRcXFxcdTE5ODAtXFxcXHUxOWFiXFxcXHUxOWMxLVxcXFx1MTljN1xcXFx1MWEwMC1cXFxcdTFhMTZcXFxcdTFhMjAtXFxcXHUxYTU0XFxcXHUxYWE3XFxcXHUxYjA1LVxcXFx1MWIzM1xcXFx1MWI0NS1cXFxcdTFiNGJcXFxcdTFiODMtXFxcXHUxYmEwXFxcXHUxYmFlXFxcXHUxYmFmXFxcXHUxYmJhLVxcXFx1MWJlNVxcXFx1MWMwMC1cXFxcdTFjMjNcXFxcdTFjNGQtXFxcXHUxYzRmXFxcXHUxYzVhLVxcXFx1MWM3ZFxcXFx1MWNlOS1cXFxcdTFjZWNcXFxcdTFjZWUtXFxcXHUxY2YxXFxcXHUxY2Y1XFxcXHUxY2Y2XFxcXHUxZDAwLVxcXFx1MWRiZlxcXFx1MWUwMC1cXFxcdTFmMTVcXFxcdTFmMTgtXFxcXHUxZjFkXFxcXHUxZjIwLVxcXFx1MWY0NVxcXFx1MWY0OC1cXFxcdTFmNGRcXFxcdTFmNTAtXFxcXHUxZjU3XFxcXHUxZjU5XFxcXHUxZjViXFxcXHUxZjVkXFxcXHUxZjVmLVxcXFx1MWY3ZFxcXFx1MWY4MC1cXFxcdTFmYjRcXFxcdTFmYjYtXFxcXHUxZmJjXFxcXHUxZmJlXFxcXHUxZmMyLVxcXFx1MWZjNFxcXFx1MWZjNi1cXFxcdTFmY2NcXFxcdTFmZDAtXFxcXHUxZmQzXFxcXHUxZmQ2LVxcXFx1MWZkYlxcXFx1MWZlMC1cXFxcdTFmZWNcXFxcdTFmZjItXFxcXHUxZmY0XFxcXHUxZmY2LVxcXFx1MWZmY1xcXFx1MjA3MVxcXFx1MjA3ZlxcXFx1MjA5MC1cXFxcdTIwOWNcXFxcdTIxMDJcXFxcdTIxMDdcXFxcdTIxMGEtXFxcXHUyMTEzXFxcXHUyMTE1XFxcXHUyMTE5LVxcXFx1MjExZFxcXFx1MjEyNFxcXFx1MjEyNlxcXFx1MjEyOFxcXFx1MjEyYS1cXFxcdTIxMmRcXFxcdTIxMmYtXFxcXHUyMTM5XFxcXHUyMTNjLVxcXFx1MjEzZlxcXFx1MjE0NS1cXFxcdTIxNDlcXFxcdTIxNGVcXFxcdTIxNjAtXFxcXHUyMTg4XFxcXHUyYzAwLVxcXFx1MmMyZVxcXFx1MmMzMC1cXFxcdTJjNWVcXFxcdTJjNjAtXFxcXHUyY2U0XFxcXHUyY2ViLVxcXFx1MmNlZVxcXFx1MmNmMlxcXFx1MmNmM1xcXFx1MmQwMC1cXFxcdTJkMjVcXFxcdTJkMjdcXFxcdTJkMmRcXFxcdTJkMzAtXFxcXHUyZDY3XFxcXHUyZDZmXFxcXHUyZDgwLVxcXFx1MmQ5NlxcXFx1MmRhMC1cXFxcdTJkYTZcXFxcdTJkYTgtXFxcXHUyZGFlXFxcXHUyZGIwLVxcXFx1MmRiNlxcXFx1MmRiOC1cXFxcdTJkYmVcXFxcdTJkYzAtXFxcXHUyZGM2XFxcXHUyZGM4LVxcXFx1MmRjZVxcXFx1MmRkMC1cXFxcdTJkZDZcXFxcdTJkZDgtXFxcXHUyZGRlXFxcXHUyZTJmXFxcXHUzMDA1LVxcXFx1MzAwN1xcXFx1MzAyMS1cXFxcdTMwMjlcXFxcdTMwMzEtXFxcXHUzMDM1XFxcXHUzMDM4LVxcXFx1MzAzY1xcXFx1MzA0MS1cXFxcdTMwOTZcXFxcdTMwOWQtXFxcXHUzMDlmXFxcXHUzMGExLVxcXFx1MzBmYVxcXFx1MzBmYy1cXFxcdTMwZmZcXFxcdTMxMDUtXFxcXHUzMTJkXFxcXHUzMTMxLVxcXFx1MzE4ZVxcXFx1MzFhMC1cXFxcdTMxYmFcXFxcdTMxZjAtXFxcXHUzMWZmXFxcXHUzNDAwLVxcXFx1NGRiNVxcXFx1NGUwMC1cXFxcdTlmY2NcXFxcdWEwMDAtXFxcXHVhNDhjXFxcXHVhNGQwLVxcXFx1YTRmZFxcXFx1YTUwMC1cXFxcdWE2MGNcXFxcdWE2MTAtXFxcXHVhNjFmXFxcXHVhNjJhXFxcXHVhNjJiXFxcXHVhNjQwLVxcXFx1YTY2ZVxcXFx1YTY3Zi1cXFxcdWE2OTdcXFxcdWE2YTAtXFxcXHVhNmVmXFxcXHVhNzE3LVxcXFx1YTcxZlxcXFx1YTcyMi1cXFxcdWE3ODhcXFxcdWE3OGItXFxcXHVhNzhlXFxcXHVhNzkwLVxcXFx1YTc5M1xcXFx1YTdhMC1cXFxcdWE3YWFcXFxcdWE3ZjgtXFxcXHVhODAxXFxcXHVhODAzLVxcXFx1YTgwNVxcXFx1YTgwNy1cXFxcdWE4MGFcXFxcdWE4MGMtXFxcXHVhODIyXFxcXHVhODQwLVxcXFx1YTg3M1xcXFx1YTg4Mi1cXFxcdWE4YjNcXFxcdWE4ZjItXFxcXHVhOGY3XFxcXHVhOGZiXFxcXHVhOTBhLVxcXFx1YTkyNVxcXFx1YTkzMC1cXFxcdWE5NDZcXFxcdWE5NjAtXFxcXHVhOTdjXFxcXHVhOTg0LVxcXFx1YTliMlxcXFx1YTljZlxcXFx1YWEwMC1cXFxcdWFhMjhcXFxcdWFhNDAtXFxcXHVhYTQyXFxcXHVhYTQ0LVxcXFx1YWE0YlxcXFx1YWE2MC1cXFxcdWFhNzZcXFxcdWFhN2FcXFxcdWFhODAtXFxcXHVhYWFmXFxcXHVhYWIxXFxcXHVhYWI1XFxcXHVhYWI2XFxcXHVhYWI5LVxcXFx1YWFiZFxcXFx1YWFjMFxcXFx1YWFjMlxcXFx1YWFkYi1cXFxcdWFhZGRcXFxcdWFhZTAtXFxcXHVhYWVhXFxcXHVhYWYyLVxcXFx1YWFmNFxcXFx1YWIwMS1cXFxcdWFiMDZcXFxcdWFiMDktXFxcXHVhYjBlXFxcXHVhYjExLVxcXFx1YWIxNlxcXFx1YWIyMC1cXFxcdWFiMjZcXFxcdWFiMjgtXFxcXHVhYjJlXFxcXHVhYmMwLVxcXFx1YWJlMlxcXFx1YWMwMC1cXFxcdWQ3YTNcXFxcdWQ3YjAtXFxcXHVkN2M2XFxcXHVkN2NiLVxcXFx1ZDdmYlxcXFx1ZjkwMC1cXFxcdWZhNmRcXFxcdWZhNzAtXFxcXHVmYWQ5XFxcXHVmYjAwLVxcXFx1ZmIwNlxcXFx1ZmIxMy1cXFxcdWZiMTdcXFxcdWZiMWRcXFxcdWZiMWYtXFxcXHVmYjI4XFxcXHVmYjJhLVxcXFx1ZmIzNlxcXFx1ZmIzOC1cXFxcdWZiM2NcXFxcdWZiM2VcXFxcdWZiNDBcXFxcdWZiNDFcXFxcdWZiNDNcXFxcdWZiNDRcXFxcdWZiNDYtXFxcXHVmYmIxXFxcXHVmYmQzLVxcXFx1ZmQzZFxcXFx1ZmQ1MC1cXFxcdWZkOGZcXFxcdWZkOTItXFxcXHVmZGM3XFxcXHVmZGYwLVxcXFx1ZmRmYlxcXFx1ZmU3MC1cXFxcdWZlNzRcXFxcdWZlNzYtXFxcXHVmZWZjXFxcXHVmZjIxLVxcXFx1ZmYzYVxcXFx1ZmY0MS1cXFxcdWZmNWFcXFxcdWZmNjYtXFxcXHVmZmJlXFxcXHVmZmMyLVxcXFx1ZmZjN1xcXFx1ZmZjYS1cXFxcdWZmY2ZcXFxcdWZmZDItXFxcXHVmZmQ3XFxcXHVmZmRhLVxcXFx1ZmZkY1wiO1xudmFyIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzID0gXCJcXFxcdTAzMDAtXFxcXHUwMzZmXFxcXHUwNDgzLVxcXFx1MDQ4N1xcXFx1MDU5MS1cXFxcdTA1YmRcXFxcdTA1YmZcXFxcdTA1YzFcXFxcdTA1YzJcXFxcdTA1YzRcXFxcdTA1YzVcXFxcdTA1YzdcXFxcdTA2MTAtXFxcXHUwNjFhXFxcXHUwNjIwLVxcXFx1MDY0OVxcXFx1MDY3Mi1cXFxcdTA2ZDNcXFxcdTA2ZTctXFxcXHUwNmU4XFxcXHUwNmZiLVxcXFx1MDZmY1xcXFx1MDczMC1cXFxcdTA3NGFcXFxcdTA4MDAtXFxcXHUwODE0XFxcXHUwODFiLVxcXFx1MDgyM1xcXFx1MDgyNS1cXFxcdTA4MjdcXFxcdTA4MjktXFxcXHUwODJkXFxcXHUwODQwLVxcXFx1MDg1N1xcXFx1MDhlNC1cXFxcdTA4ZmVcXFxcdTA5MDAtXFxcXHUwOTAzXFxcXHUwOTNhLVxcXFx1MDkzY1xcXFx1MDkzZS1cXFxcdTA5NGZcXFxcdTA5NTEtXFxcXHUwOTU3XFxcXHUwOTYyLVxcXFx1MDk2M1xcXFx1MDk2Ni1cXFxcdTA5NmZcXFxcdTA5ODEtXFxcXHUwOTgzXFxcXHUwOWJjXFxcXHUwOWJlLVxcXFx1MDljNFxcXFx1MDljN1xcXFx1MDljOFxcXFx1MDlkN1xcXFx1MDlkZi1cXFxcdTA5ZTBcXFxcdTBhMDEtXFxcXHUwYTAzXFxcXHUwYTNjXFxcXHUwYTNlLVxcXFx1MGE0MlxcXFx1MGE0N1xcXFx1MGE0OFxcXFx1MGE0Yi1cXFxcdTBhNGRcXFxcdTBhNTFcXFxcdTBhNjYtXFxcXHUwYTcxXFxcXHUwYTc1XFxcXHUwYTgxLVxcXFx1MGE4M1xcXFx1MGFiY1xcXFx1MGFiZS1cXFxcdTBhYzVcXFxcdTBhYzctXFxcXHUwYWM5XFxcXHUwYWNiLVxcXFx1MGFjZFxcXFx1MGFlMi1cXFxcdTBhZTNcXFxcdTBhZTYtXFxcXHUwYWVmXFxcXHUwYjAxLVxcXFx1MGIwM1xcXFx1MGIzY1xcXFx1MGIzZS1cXFxcdTBiNDRcXFxcdTBiNDdcXFxcdTBiNDhcXFxcdTBiNGItXFxcXHUwYjRkXFxcXHUwYjU2XFxcXHUwYjU3XFxcXHUwYjVmLVxcXFx1MGI2MFxcXFx1MGI2Ni1cXFxcdTBiNmZcXFxcdTBiODJcXFxcdTBiYmUtXFxcXHUwYmMyXFxcXHUwYmM2LVxcXFx1MGJjOFxcXFx1MGJjYS1cXFxcdTBiY2RcXFxcdTBiZDdcXFxcdTBiZTYtXFxcXHUwYmVmXFxcXHUwYzAxLVxcXFx1MGMwM1xcXFx1MGM0Ni1cXFxcdTBjNDhcXFxcdTBjNGEtXFxcXHUwYzRkXFxcXHUwYzU1XFxcXHUwYzU2XFxcXHUwYzYyLVxcXFx1MGM2M1xcXFx1MGM2Ni1cXFxcdTBjNmZcXFxcdTBjODJcXFxcdTBjODNcXFxcdTBjYmNcXFxcdTBjYmUtXFxcXHUwY2M0XFxcXHUwY2M2LVxcXFx1MGNjOFxcXFx1MGNjYS1cXFxcdTBjY2RcXFxcdTBjZDVcXFxcdTBjZDZcXFxcdTBjZTItXFxcXHUwY2UzXFxcXHUwY2U2LVxcXFx1MGNlZlxcXFx1MGQwMlxcXFx1MGQwM1xcXFx1MGQ0Ni1cXFxcdTBkNDhcXFxcdTBkNTdcXFxcdTBkNjItXFxcXHUwZDYzXFxcXHUwZDY2LVxcXFx1MGQ2ZlxcXFx1MGQ4MlxcXFx1MGQ4M1xcXFx1MGRjYVxcXFx1MGRjZi1cXFxcdTBkZDRcXFxcdTBkZDZcXFxcdTBkZDgtXFxcXHUwZGRmXFxcXHUwZGYyXFxcXHUwZGYzXFxcXHUwZTM0LVxcXFx1MGUzYVxcXFx1MGU0MC1cXFxcdTBlNDVcXFxcdTBlNTAtXFxcXHUwZTU5XFxcXHUwZWI0LVxcXFx1MGViOVxcXFx1MGVjOC1cXFxcdTBlY2RcXFxcdTBlZDAtXFxcXHUwZWQ5XFxcXHUwZjE4XFxcXHUwZjE5XFxcXHUwZjIwLVxcXFx1MGYyOVxcXFx1MGYzNVxcXFx1MGYzN1xcXFx1MGYzOVxcXFx1MGY0MS1cXFxcdTBmNDdcXFxcdTBmNzEtXFxcXHUwZjg0XFxcXHUwZjg2LVxcXFx1MGY4N1xcXFx1MGY4ZC1cXFxcdTBmOTdcXFxcdTBmOTktXFxcXHUwZmJjXFxcXHUwZmM2XFxcXHUxMDAwLVxcXFx1MTAyOVxcXFx1MTA0MC1cXFxcdTEwNDlcXFxcdTEwNjctXFxcXHUxMDZkXFxcXHUxMDcxLVxcXFx1MTA3NFxcXFx1MTA4Mi1cXFxcdTEwOGRcXFxcdTEwOGYtXFxcXHUxMDlkXFxcXHUxMzVkLVxcXFx1MTM1ZlxcXFx1MTcwZS1cXFxcdTE3MTBcXFxcdTE3MjAtXFxcXHUxNzMwXFxcXHUxNzQwLVxcXFx1MTc1MFxcXFx1MTc3MlxcXFx1MTc3M1xcXFx1MTc4MC1cXFxcdTE3YjJcXFxcdTE3ZGRcXFxcdTE3ZTAtXFxcXHUxN2U5XFxcXHUxODBiLVxcXFx1MTgwZFxcXFx1MTgxMC1cXFxcdTE4MTlcXFxcdTE5MjAtXFxcXHUxOTJiXFxcXHUxOTMwLVxcXFx1MTkzYlxcXFx1MTk1MS1cXFxcdTE5NmRcXFxcdTE5YjAtXFxcXHUxOWMwXFxcXHUxOWM4LVxcXFx1MTljOVxcXFx1MTlkMC1cXFxcdTE5ZDlcXFxcdTFhMDAtXFxcXHUxYTE1XFxcXHUxYTIwLVxcXFx1MWE1M1xcXFx1MWE2MC1cXFxcdTFhN2NcXFxcdTFhN2YtXFxcXHUxYTg5XFxcXHUxYTkwLVxcXFx1MWE5OVxcXFx1MWI0Ni1cXFxcdTFiNGJcXFxcdTFiNTAtXFxcXHUxYjU5XFxcXHUxYjZiLVxcXFx1MWI3M1xcXFx1MWJiMC1cXFxcdTFiYjlcXFxcdTFiZTYtXFxcXHUxYmYzXFxcXHUxYzAwLVxcXFx1MWMyMlxcXFx1MWM0MC1cXFxcdTFjNDlcXFxcdTFjNWItXFxcXHUxYzdkXFxcXHUxY2QwLVxcXFx1MWNkMlxcXFx1MWQwMC1cXFxcdTFkYmVcXFxcdTFlMDEtXFxcXHUxZjE1XFxcXHUyMDBjXFxcXHUyMDBkXFxcXHUyMDNmXFxcXHUyMDQwXFxcXHUyMDU0XFxcXHUyMGQwLVxcXFx1MjBkY1xcXFx1MjBlMVxcXFx1MjBlNS1cXFxcdTIwZjBcXFxcdTJkODEtXFxcXHUyZDk2XFxcXHUyZGUwLVxcXFx1MmRmZlxcXFx1MzAyMS1cXFxcdTMwMjhcXFxcdTMwOTlcXFxcdTMwOWFcXFxcdWE2NDAtXFxcXHVhNjZkXFxcXHVhNjc0LVxcXFx1YTY3ZFxcXFx1YTY5ZlxcXFx1YTZmMC1cXFxcdWE2ZjFcXFxcdWE3ZjgtXFxcXHVhODAwXFxcXHVhODA2XFxcXHVhODBiXFxcXHVhODIzLVxcXFx1YTgyN1xcXFx1YTg4MC1cXFxcdWE4ODFcXFxcdWE4YjQtXFxcXHVhOGM0XFxcXHVhOGQwLVxcXFx1YThkOVxcXFx1YThmMy1cXFxcdWE4ZjdcXFxcdWE5MDAtXFxcXHVhOTA5XFxcXHVhOTI2LVxcXFx1YTkyZFxcXFx1YTkzMC1cXFxcdWE5NDVcXFxcdWE5ODAtXFxcXHVhOTgzXFxcXHVhOWIzLVxcXFx1YTljMFxcXFx1YWEwMC1cXFxcdWFhMjdcXFxcdWFhNDAtXFxcXHVhYTQxXFxcXHVhYTRjLVxcXFx1YWE0ZFxcXFx1YWE1MC1cXFxcdWFhNTlcXFxcdWFhN2JcXFxcdWFhZTAtXFxcXHVhYWU5XFxcXHVhYWYyLVxcXFx1YWFmM1xcXFx1YWJjMC1cXFxcdWFiZTFcXFxcdWFiZWNcXFxcdWFiZWRcXFxcdWFiZjAtXFxcXHVhYmY5XFxcXHVmYjIwLVxcXFx1ZmIyOFxcXFx1ZmUwMC1cXFxcdWZlMGZcXFxcdWZlMjAtXFxcXHVmZTI2XFxcXHVmZTMzXFxcXHVmZTM0XFxcXHVmZTRkLVxcXFx1ZmU0ZlxcXFx1ZmYxMC1cXFxcdWZmMTlcXFxcdWZmM2ZcIjtcbi8vdmFyIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0ID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBcIl1cIik7XG4vL3ZhciBub25BU0NJSWlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKFwiW1wiICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzICsgXCJdXCIpO1xuXG52YXIgdW5pY29kZUVzY2FwZU9yQ29kZVBvaW50ID0gXCJcXFxcXFxcXHVbMC05YS1mQS1GXXs0fXxcXFxcXFxcXHVcXFxce1swLTlhLWZBLUZdK1xcXFx9XCI7XG52YXIgaWRlbnRpZmllclN0YXJ0ID0gXCIoPzpcIiArIHVuaWNvZGVFc2NhcGVPckNvZGVQb2ludCArIFwifFtcIiArIGJhc2VBU0NJSWlkZW50aWZpZXJTdGFydENoYXJzICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIFwiXSlcIjtcbnZhciBpZGVudGlmaWVyQ2hhcnMgPSBcIig/OlwiICsgdW5pY29kZUVzY2FwZU9yQ29kZVBvaW50ICsgXCJ8W1wiICsgYmFzZUFTQ0lJaWRlbnRpZmllckNoYXJzICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzICsgXCJdKSpcIjtcblxuZXhwb3J0cy5pZGVudGlmaWVyID0gbmV3IFJlZ0V4cChpZGVudGlmaWVyU3RhcnQgKyBpZGVudGlmaWVyQ2hhcnMsICdnJyk7XG5leHBvcnRzLmlkZW50aWZpZXJTdGFydCA9IG5ldyBSZWdFeHAoaWRlbnRpZmllclN0YXJ0KTtcbmV4cG9ydHMuaWRlbnRpZmllck1hdGNoID0gbmV3IFJlZ0V4cChcIig/OlwiICsgdW5pY29kZUVzY2FwZU9yQ29kZVBvaW50ICsgXCJ8W1wiICsgYmFzZUFTQ0lJaWRlbnRpZmllckNoYXJzICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzICsgXCJdKStcIik7XG5cbnZhciBub25BU0NJSXdoaXRlc3BhY2UgPSAvW1xcdTE2ODBcXHUxODBlXFx1MjAwMC1cXHUyMDBhXFx1MjAyZlxcdTIwNWZcXHUzMDAwXFx1ZmVmZl0vOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblxuLy8gV2hldGhlciBhIHNpbmdsZSBjaGFyYWN0ZXIgZGVub3RlcyBhIG5ld2xpbmUuXG5cbmV4cG9ydHMubmV3bGluZSA9IC9bXFxuXFxyXFx1MjAyOFxcdTIwMjldLztcblxuLy8gTWF0Y2hlcyBhIHdob2xlIGxpbmUgYnJlYWsgKHdoZXJlIENSTEYgaXMgY29uc2lkZXJlZCBhIHNpbmdsZVxuLy8gbGluZSBicmVhaykuIFVzZWQgdG8gY291bnQgbGluZXMuXG5cbi8vIGluIGphdmFzY3JpcHQsIHRoZXNlIHR3byBkaWZmZXJcbi8vIGluIHB5dGhvbiB0aGV5IGFyZSB0aGUgc2FtZSwgZGlmZmVyZW50IG1ldGhvZHMgYXJlIGNhbGxlZCBvbiB0aGVtXG5leHBvcnRzLmxpbmVCcmVhayA9IG5ldyBSZWdFeHAoJ1xcclxcbnwnICsgZXhwb3J0cy5uZXdsaW5lLnNvdXJjZSk7XG5leHBvcnRzLmFsbExpbmVCcmVha3MgPSBuZXcgUmVnRXhwKGV4cG9ydHMubGluZUJyZWFrLnNvdXJjZSwgJ2cnKTtcblxuXG4vKioqLyB9KSxcbi8qIDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbnZhciBCYXNlT3B0aW9ucyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDYpLk9wdGlvbnMpO1xuXG52YXIgdmFsaWRQb3NpdGlvblZhbHVlcyA9IFsnYmVmb3JlLW5ld2xpbmUnLCAnYWZ0ZXItbmV3bGluZScsICdwcmVzZXJ2ZS1uZXdsaW5lJ107XG5cbmZ1bmN0aW9uIE9wdGlvbnMob3B0aW9ucykge1xuICBCYXNlT3B0aW9ucy5jYWxsKHRoaXMsIG9wdGlvbnMsICdqcycpO1xuXG4gIC8vIGNvbXBhdGliaWxpdHksIHJlXG4gIHZhciByYXdfYnJhY2Vfc3R5bGUgPSB0aGlzLnJhd19vcHRpb25zLmJyYWNlX3N0eWxlIHx8IG51bGw7XG4gIGlmIChyYXdfYnJhY2Vfc3R5bGUgPT09IFwiZXhwYW5kLXN0cmljdFwiKSB7IC8vZ3JhY2VmdWwgaGFuZGxpbmcgb2YgZGVwcmVjYXRlZCBvcHRpb25cbiAgICB0aGlzLnJhd19vcHRpb25zLmJyYWNlX3N0eWxlID0gXCJleHBhbmRcIjtcbiAgfSBlbHNlIGlmIChyYXdfYnJhY2Vfc3R5bGUgPT09IFwiY29sbGFwc2UtcHJlc2VydmUtaW5saW5lXCIpIHsgLy9ncmFjZWZ1bCBoYW5kbGluZyBvZiBkZXByZWNhdGVkIG9wdGlvblxuICAgIHRoaXMucmF3X29wdGlvbnMuYnJhY2Vfc3R5bGUgPSBcImNvbGxhcHNlLHByZXNlcnZlLWlubGluZVwiO1xuICB9IGVsc2UgaWYgKHRoaXMucmF3X29wdGlvbnMuYnJhY2VzX29uX293bl9saW5lICE9PSB1bmRlZmluZWQpIHsgLy9ncmFjZWZ1bCBoYW5kbGluZyBvZiBkZXByZWNhdGVkIG9wdGlvblxuICAgIHRoaXMucmF3X29wdGlvbnMuYnJhY2Vfc3R5bGUgPSB0aGlzLnJhd19vcHRpb25zLmJyYWNlc19vbl9vd25fbGluZSA/IFwiZXhwYW5kXCIgOiBcImNvbGxhcHNlXCI7XG4gICAgLy8gfSBlbHNlIGlmICghcmF3X2JyYWNlX3N0eWxlKSB7IC8vTm90aGluZyBleGlzdHMgdG8gc2V0IGl0XG4gICAgLy8gICByYXdfYnJhY2Vfc3R5bGUgPSBcImNvbGxhcHNlXCI7XG4gIH1cblxuICAvL3ByZXNlcnZlLWlubGluZSBpbiBkZWxpbWl0ZWQgc3RyaW5nIHdpbGwgdHJpZ2dlciBicmFjZV9wcmVzZXJ2ZV9pbmxpbmUsIGV2ZXJ5dGhpbmdcbiAgLy9lbHNlIGlzIGNvbnNpZGVyZWQgYSBicmFjZV9zdHlsZSBhbmQgdGhlIGxhc3Qgb25lIG9ubHkgd2lsbCBoYXZlIGFuIGVmZmVjdFxuXG4gIHZhciBicmFjZV9zdHlsZV9zcGxpdCA9IHRoaXMuX2dldF9zZWxlY3Rpb25fbGlzdCgnYnJhY2Vfc3R5bGUnLCBbJ2NvbGxhcHNlJywgJ2V4cGFuZCcsICdlbmQtZXhwYW5kJywgJ25vbmUnLCAncHJlc2VydmUtaW5saW5lJ10pO1xuXG4gIHRoaXMuYnJhY2VfcHJlc2VydmVfaW5saW5lID0gZmFsc2U7IC8vRGVmYXVsdHMgaW4gY2FzZSBvbmUgb3Igb3RoZXIgd2FzIG5vdCBzcGVjaWZpZWQgaW4gbWV0YS1vcHRpb25cbiAgdGhpcy5icmFjZV9zdHlsZSA9IFwiY29sbGFwc2VcIjtcblxuICBmb3IgKHZhciBicyA9IDA7IGJzIDwgYnJhY2Vfc3R5bGVfc3BsaXQubGVuZ3RoOyBicysrKSB7XG4gICAgaWYgKGJyYWNlX3N0eWxlX3NwbGl0W2JzXSA9PT0gXCJwcmVzZXJ2ZS1pbmxpbmVcIikge1xuICAgICAgdGhpcy5icmFjZV9wcmVzZXJ2ZV9pbmxpbmUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJyYWNlX3N0eWxlID0gYnJhY2Vfc3R5bGVfc3BsaXRbYnNdO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMudW5pbmRlbnRfY2hhaW5lZF9tZXRob2RzID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ3VuaW5kZW50X2NoYWluZWRfbWV0aG9kcycpO1xuICB0aGlzLmJyZWFrX2NoYWluZWRfbWV0aG9kcyA9IHRoaXMuX2dldF9ib29sZWFuKCdicmVha19jaGFpbmVkX21ldGhvZHMnKTtcbiAgdGhpcy5zcGFjZV9pbl9wYXJlbiA9IHRoaXMuX2dldF9ib29sZWFuKCdzcGFjZV9pbl9wYXJlbicpO1xuICB0aGlzLnNwYWNlX2luX2VtcHR5X3BhcmVuID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ3NwYWNlX2luX2VtcHR5X3BhcmVuJyk7XG4gIHRoaXMuanNsaW50X2hhcHB5ID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ2pzbGludF9oYXBweScpO1xuICB0aGlzLnNwYWNlX2FmdGVyX2Fub25fZnVuY3Rpb24gPSB0aGlzLl9nZXRfYm9vbGVhbignc3BhY2VfYWZ0ZXJfYW5vbl9mdW5jdGlvbicpO1xuICB0aGlzLnNwYWNlX2FmdGVyX25hbWVkX2Z1bmN0aW9uID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ3NwYWNlX2FmdGVyX25hbWVkX2Z1bmN0aW9uJyk7XG4gIHRoaXMua2VlcF9hcnJheV9pbmRlbnRhdGlvbiA9IHRoaXMuX2dldF9ib29sZWFuKCdrZWVwX2FycmF5X2luZGVudGF0aW9uJyk7XG4gIHRoaXMuc3BhY2VfYmVmb3JlX2NvbmRpdGlvbmFsID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ3NwYWNlX2JlZm9yZV9jb25kaXRpb25hbCcsIHRydWUpO1xuICB0aGlzLnVuZXNjYXBlX3N0cmluZ3MgPSB0aGlzLl9nZXRfYm9vbGVhbigndW5lc2NhcGVfc3RyaW5ncycpO1xuICB0aGlzLmU0eCA9IHRoaXMuX2dldF9ib29sZWFuKCdlNHgnKTtcbiAgdGhpcy5jb21tYV9maXJzdCA9IHRoaXMuX2dldF9ib29sZWFuKCdjb21tYV9maXJzdCcpO1xuICB0aGlzLm9wZXJhdG9yX3Bvc2l0aW9uID0gdGhpcy5fZ2V0X3NlbGVjdGlvbignb3BlcmF0b3JfcG9zaXRpb24nLCB2YWxpZFBvc2l0aW9uVmFsdWVzKTtcblxuICAvLyBGb3IgdGVzdGluZyBvZiBiZWF1dGlmeSBwcmVzZXJ2ZTpzdGFydCBkaXJlY3RpdmVcbiAgdGhpcy50ZXN0X291dHB1dF9yYXcgPSB0aGlzLl9nZXRfYm9vbGVhbigndGVzdF9vdXRwdXRfcmF3Jyk7XG5cbiAgLy8gZm9yY2UgdGhpcy5fb3B0aW9ucy5zcGFjZV9hZnRlcl9hbm9uX2Z1bmN0aW9uIHRvIHRydWUgaWYgdGhpcy5fb3B0aW9ucy5qc2xpbnRfaGFwcHlcbiAgaWYgKHRoaXMuanNsaW50X2hhcHB5KSB7XG4gICAgdGhpcy5zcGFjZV9hZnRlcl9hbm9uX2Z1bmN0aW9uID0gdHJ1ZTtcbiAgfVxuXG59XG5PcHRpb25zLnByb3RvdHlwZSA9IG5ldyBCYXNlT3B0aW9ucygpO1xuXG5cblxubW9kdWxlLmV4cG9ydHMuT3B0aW9ucyA9IE9wdGlvbnM7XG5cblxuLyoqKi8gfSksXG4vKiA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxuZnVuY3Rpb24gT3B0aW9ucyhvcHRpb25zLCBtZXJnZV9jaGlsZF9maWVsZCkge1xuICB0aGlzLnJhd19vcHRpb25zID0gX21lcmdlT3B0cyhvcHRpb25zLCBtZXJnZV9jaGlsZF9maWVsZCk7XG5cbiAgLy8gU3VwcG9ydCBwYXNzaW5nIHRoZSBzb3VyY2UgdGV4dCBiYWNrIHdpdGggbm8gY2hhbmdlXG4gIHRoaXMuZGlzYWJsZWQgPSB0aGlzLl9nZXRfYm9vbGVhbignZGlzYWJsZWQnKTtcblxuICB0aGlzLmVvbCA9IHRoaXMuX2dldF9jaGFyYWN0ZXJzKCdlb2wnLCAnYXV0bycpO1xuICB0aGlzLmVuZF93aXRoX25ld2xpbmUgPSB0aGlzLl9nZXRfYm9vbGVhbignZW5kX3dpdGhfbmV3bGluZScpO1xuICB0aGlzLmluZGVudF9zaXplID0gdGhpcy5fZ2V0X251bWJlcignaW5kZW50X3NpemUnLCA0KTtcbiAgdGhpcy5pbmRlbnRfY2hhciA9IHRoaXMuX2dldF9jaGFyYWN0ZXJzKCdpbmRlbnRfY2hhcicsICcgJyk7XG4gIHRoaXMuaW5kZW50X2xldmVsID0gdGhpcy5fZ2V0X251bWJlcignaW5kZW50X2xldmVsJyk7XG5cbiAgdGhpcy5wcmVzZXJ2ZV9uZXdsaW5lcyA9IHRoaXMuX2dldF9ib29sZWFuKCdwcmVzZXJ2ZV9uZXdsaW5lcycsIHRydWUpO1xuICB0aGlzLm1heF9wcmVzZXJ2ZV9uZXdsaW5lcyA9IHRoaXMuX2dldF9udW1iZXIoJ21heF9wcmVzZXJ2ZV9uZXdsaW5lcycsIDMyNzg2KTtcbiAgaWYgKCF0aGlzLnByZXNlcnZlX25ld2xpbmVzKSB7XG4gICAgdGhpcy5tYXhfcHJlc2VydmVfbmV3bGluZXMgPSAwO1xuICB9XG5cbiAgdGhpcy5pbmRlbnRfd2l0aF90YWJzID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ2luZGVudF93aXRoX3RhYnMnLCB0aGlzLmluZGVudF9jaGFyID09PSAnXFx0Jyk7XG4gIGlmICh0aGlzLmluZGVudF93aXRoX3RhYnMpIHtcbiAgICB0aGlzLmluZGVudF9jaGFyID0gJ1xcdCc7XG5cbiAgICAvLyBpbmRlbnRfc2l6ZSBiZWhhdmlvciBjaGFuZ2VkIGFmdGVyIDEuOC42XG4gICAgLy8gSXQgdXNlZCB0byBiZSB0aGF0IGluZGVudF9zaXplIHdvdWxkIGJlXG4gICAgLy8gc2V0IHRvIDEgZm9yIGluZGVudF93aXRoX3RhYnMuIFRoYXQgaXMgbm8gbG9uZ2VyIG5lZWRlZCBhbmRcbiAgICAvLyBhY3R1YWxseSBkb2Vzbid0IG1ha2Ugc2Vuc2UgLSB3aHkgbm90IHVzZSBzcGFjZXM/IEZ1cnRoZXIsXG4gICAgLy8gdGhhdCBtaWdodCBwcm9kdWNlIHVuZXhwZWN0ZWQgYmVoYXZpb3IgLSB0YWJzIGJlaW5nIHVzZWRcbiAgICAvLyBmb3Igc2luZ2xlLWNvbHVtbiBhbGlnbm1lbnQuIFNvLCB3aGVuIGluZGVudF93aXRoX3RhYnMgaXMgdHJ1ZVxuICAgIC8vIGFuZCBpbmRlbnRfc2l6ZSBpcyAxLCByZXNldCBpbmRlbnRfc2l6ZSB0byA0LlxuICAgIGlmICh0aGlzLmluZGVudF9zaXplID09PSAxKSB7XG4gICAgICB0aGlzLmluZGVudF9zaXplID0gNDtcbiAgICB9XG4gIH1cblxuICAvLyBCYWNrd2FyZHMgY29tcGF0IHdpdGggMS4zLnhcbiAgdGhpcy53cmFwX2xpbmVfbGVuZ3RoID0gdGhpcy5fZ2V0X251bWJlcignd3JhcF9saW5lX2xlbmd0aCcsIHRoaXMuX2dldF9udW1iZXIoJ21heF9jaGFyJykpO1xuXG4gIHRoaXMuaW5kZW50X2VtcHR5X2xpbmVzID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ2luZGVudF9lbXB0eV9saW5lcycpO1xuXG4gIC8vIHZhbGlkIHRlbXBsYXRpbmcgbGFuZ3VhZ2VzIFsnZGphbmdvJywgJ2VyYicsICdoYW5kbGViYXJzJywgJ3BocCcsICdzbWFydHknLCAnYW5ndWxhciddXG4gIC8vIEZvciBub3csICdhdXRvJyA9IGFsbCBvZmYgZm9yIGphdmFzY3JpcHQsIGFsbCBleGNlcHQgYW5ndWxhciBvbiBmb3IgaHRtbCAoYW5kIGlubGluZSBqYXZhc2NyaXB0L2NzcykuXG4gIC8vIG90aGVyIHZhbHVlcyBpZ25vcmVkXG4gIHRoaXMudGVtcGxhdGluZyA9IHRoaXMuX2dldF9zZWxlY3Rpb25fbGlzdCgndGVtcGxhdGluZycsIFsnYXV0bycsICdub25lJywgJ2FuZ3VsYXInLCAnZGphbmdvJywgJ2VyYicsICdoYW5kbGViYXJzJywgJ3BocCcsICdzbWFydHknXSwgWydhdXRvJ10pO1xufVxuXG5PcHRpb25zLnByb3RvdHlwZS5fZ2V0X2FycmF5ID0gZnVuY3Rpb24obmFtZSwgZGVmYXVsdF92YWx1ZSkge1xuICB2YXIgb3B0aW9uX3ZhbHVlID0gdGhpcy5yYXdfb3B0aW9uc1tuYW1lXTtcbiAgdmFyIHJlc3VsdCA9IGRlZmF1bHRfdmFsdWUgfHwgW107XG4gIGlmICh0eXBlb2Ygb3B0aW9uX3ZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChvcHRpb25fdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIG9wdGlvbl92YWx1ZS5jb25jYXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlc3VsdCA9IG9wdGlvbl92YWx1ZS5jb25jYXQoKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbl92YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXN1bHQgPSBvcHRpb25fdmFsdWUuc3BsaXQoL1teYS16QS1aMC05X1xcL1xcLV0rLyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbk9wdGlvbnMucHJvdG90eXBlLl9nZXRfYm9vbGVhbiA9IGZ1bmN0aW9uKG5hbWUsIGRlZmF1bHRfdmFsdWUpIHtcbiAgdmFyIG9wdGlvbl92YWx1ZSA9IHRoaXMucmF3X29wdGlvbnNbbmFtZV07XG4gIHZhciByZXN1bHQgPSBvcHRpb25fdmFsdWUgPT09IHVuZGVmaW5lZCA/ICEhZGVmYXVsdF92YWx1ZSA6ICEhb3B0aW9uX3ZhbHVlO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuT3B0aW9ucy5wcm90b3R5cGUuX2dldF9jaGFyYWN0ZXJzID0gZnVuY3Rpb24obmFtZSwgZGVmYXVsdF92YWx1ZSkge1xuICB2YXIgb3B0aW9uX3ZhbHVlID0gdGhpcy5yYXdfb3B0aW9uc1tuYW1lXTtcbiAgdmFyIHJlc3VsdCA9IGRlZmF1bHRfdmFsdWUgfHwgJyc7XG4gIGlmICh0eXBlb2Ygb3B0aW9uX3ZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJlc3VsdCA9IG9wdGlvbl92YWx1ZS5yZXBsYWNlKC9cXFxcci8sICdcXHInKS5yZXBsYWNlKC9cXFxcbi8sICdcXG4nKS5yZXBsYWNlKC9cXFxcdC8sICdcXHQnKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuT3B0aW9ucy5wcm90b3R5cGUuX2dldF9udW1iZXIgPSBmdW5jdGlvbihuYW1lLCBkZWZhdWx0X3ZhbHVlKSB7XG4gIHZhciBvcHRpb25fdmFsdWUgPSB0aGlzLnJhd19vcHRpb25zW25hbWVdO1xuICBkZWZhdWx0X3ZhbHVlID0gcGFyc2VJbnQoZGVmYXVsdF92YWx1ZSwgMTApO1xuICBpZiAoaXNOYU4oZGVmYXVsdF92YWx1ZSkpIHtcbiAgICBkZWZhdWx0X3ZhbHVlID0gMDtcbiAgfVxuICB2YXIgcmVzdWx0ID0gcGFyc2VJbnQob3B0aW9uX3ZhbHVlLCAxMCk7XG4gIGlmIChpc05hTihyZXN1bHQpKSB7XG4gICAgcmVzdWx0ID0gZGVmYXVsdF92YWx1ZTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuT3B0aW9ucy5wcm90b3R5cGUuX2dldF9zZWxlY3Rpb24gPSBmdW5jdGlvbihuYW1lLCBzZWxlY3Rpb25fbGlzdCwgZGVmYXVsdF92YWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fZ2V0X3NlbGVjdGlvbl9saXN0KG5hbWUsIHNlbGVjdGlvbl9saXN0LCBkZWZhdWx0X3ZhbHVlKTtcbiAgaWYgKHJlc3VsdC5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkludmFsaWQgT3B0aW9uIFZhbHVlOiBUaGUgb3B0aW9uICdcIiArIG5hbWUgKyBcIicgY2FuIG9ubHkgYmUgb25lIG9mIHRoZSBmb2xsb3dpbmcgdmFsdWVzOlxcblwiICtcbiAgICAgIHNlbGVjdGlvbl9saXN0ICsgXCJcXG5Zb3UgcGFzc2VkIGluOiAnXCIgKyB0aGlzLnJhd19vcHRpb25zW25hbWVdICsgXCInXCIpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFswXTtcbn07XG5cblxuT3B0aW9ucy5wcm90b3R5cGUuX2dldF9zZWxlY3Rpb25fbGlzdCA9IGZ1bmN0aW9uKG5hbWUsIHNlbGVjdGlvbl9saXN0LCBkZWZhdWx0X3ZhbHVlKSB7XG4gIGlmICghc2VsZWN0aW9uX2xpc3QgfHwgc2VsZWN0aW9uX2xpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2VsZWN0aW9uIGxpc3QgY2Fubm90IGJlIGVtcHR5LlwiKTtcbiAgfVxuXG4gIGRlZmF1bHRfdmFsdWUgPSBkZWZhdWx0X3ZhbHVlIHx8IFtzZWxlY3Rpb25fbGlzdFswXV07XG4gIGlmICghdGhpcy5faXNfdmFsaWRfc2VsZWN0aW9uKGRlZmF1bHRfdmFsdWUsIHNlbGVjdGlvbl9saXN0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgRGVmYXVsdCBWYWx1ZSFcIik7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gdGhpcy5fZ2V0X2FycmF5KG5hbWUsIGRlZmF1bHRfdmFsdWUpO1xuICBpZiAoIXRoaXMuX2lzX3ZhbGlkX3NlbGVjdGlvbihyZXN1bHQsIHNlbGVjdGlvbl9saXN0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiSW52YWxpZCBPcHRpb24gVmFsdWU6IFRoZSBvcHRpb24gJ1wiICsgbmFtZSArIFwiJyBjYW4gY29udGFpbiBvbmx5IHRoZSBmb2xsb3dpbmcgdmFsdWVzOlxcblwiICtcbiAgICAgIHNlbGVjdGlvbl9saXN0ICsgXCJcXG5Zb3UgcGFzc2VkIGluOiAnXCIgKyB0aGlzLnJhd19vcHRpb25zW25hbWVdICsgXCInXCIpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbk9wdGlvbnMucHJvdG90eXBlLl9pc192YWxpZF9zZWxlY3Rpb24gPSBmdW5jdGlvbihyZXN1bHQsIHNlbGVjdGlvbl9saXN0KSB7XG4gIHJldHVybiByZXN1bHQubGVuZ3RoICYmIHNlbGVjdGlvbl9saXN0Lmxlbmd0aCAmJlxuICAgICFyZXN1bHQuc29tZShmdW5jdGlvbihpdGVtKSB7IHJldHVybiBzZWxlY3Rpb25fbGlzdC5pbmRleE9mKGl0ZW0pID09PSAtMTsgfSk7XG59O1xuXG5cbi8vIG1lcmdlcyBjaGlsZCBvcHRpb25zIHVwIHdpdGggdGhlIHBhcmVudCBvcHRpb25zIG9iamVjdFxuLy8gRXhhbXBsZTogb2JqID0ge2E6IDEsIGI6IHthOiAyfX1cbi8vICAgICAgICAgIG1lcmdlT3B0cyhvYmosICdiJylcbi8vXG4vLyAgICAgICAgICBSZXR1cm5zOiB7YTogMn1cbmZ1bmN0aW9uIF9tZXJnZU9wdHMoYWxsT3B0aW9ucywgY2hpbGRGaWVsZE5hbWUpIHtcbiAgdmFyIGZpbmFsT3B0cyA9IHt9O1xuICBhbGxPcHRpb25zID0gX25vcm1hbGl6ZU9wdHMoYWxsT3B0aW9ucyk7XG4gIHZhciBuYW1lO1xuXG4gIGZvciAobmFtZSBpbiBhbGxPcHRpb25zKSB7XG4gICAgaWYgKG5hbWUgIT09IGNoaWxkRmllbGROYW1lKSB7XG4gICAgICBmaW5hbE9wdHNbbmFtZV0gPSBhbGxPcHRpb25zW25hbWVdO1xuICAgIH1cbiAgfVxuXG4gIC8vbWVyZ2UgaW4gdGhlIHBlciB0eXBlIHNldHRpbmdzIGZvciB0aGUgY2hpbGRGaWVsZE5hbWVcbiAgaWYgKGNoaWxkRmllbGROYW1lICYmIGFsbE9wdGlvbnNbY2hpbGRGaWVsZE5hbWVdKSB7XG4gICAgZm9yIChuYW1lIGluIGFsbE9wdGlvbnNbY2hpbGRGaWVsZE5hbWVdKSB7XG4gICAgICBmaW5hbE9wdHNbbmFtZV0gPSBhbGxPcHRpb25zW2NoaWxkRmllbGROYW1lXVtuYW1lXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZpbmFsT3B0cztcbn1cblxuZnVuY3Rpb24gX25vcm1hbGl6ZU9wdHMob3B0aW9ucykge1xuICB2YXIgY29udmVydGVkT3B0cyA9IHt9O1xuICB2YXIga2V5O1xuXG4gIGZvciAoa2V5IGluIG9wdGlvbnMpIHtcbiAgICB2YXIgbmV3S2V5ID0ga2V5LnJlcGxhY2UoLy0vZywgXCJfXCIpO1xuICAgIGNvbnZlcnRlZE9wdHNbbmV3S2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgfVxuICByZXR1cm4gY29udmVydGVkT3B0cztcbn1cblxubW9kdWxlLmV4cG9ydHMuT3B0aW9ucyA9IE9wdGlvbnM7XG5tb2R1bGUuZXhwb3J0cy5ub3JtYWxpemVPcHRzID0gX25vcm1hbGl6ZU9wdHM7XG5tb2R1bGUuZXhwb3J0cy5tZXJnZU9wdHMgPSBfbWVyZ2VPcHRzO1xuXG5cbi8qKiovIH0pLFxuLyogNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxudmFyIElucHV0U2Nhbm5lciA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDgpLklucHV0U2Nhbm5lcik7XG52YXIgQmFzZVRva2VuaXplciA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDkpLlRva2VuaXplcik7XG52YXIgQkFTRVRPS0VOID0gKF9fd2VicGFja19yZXF1aXJlX18oOSkuVE9LRU4pO1xudmFyIERpcmVjdGl2ZXMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygxMykuRGlyZWN0aXZlcyk7XG52YXIgYWNvcm4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xudmFyIFBhdHRlcm4gPSAoX193ZWJwYWNrX3JlcXVpcmVfXygxMikuUGF0dGVybik7XG52YXIgVGVtcGxhdGFibGVQYXR0ZXJuID0gKF9fd2VicGFja19yZXF1aXJlX18oMTQpLlRlbXBsYXRhYmxlUGF0dGVybik7XG5cblxuZnVuY3Rpb24gaW5fYXJyYXkod2hhdCwgYXJyKSB7XG4gIHJldHVybiBhcnIuaW5kZXhPZih3aGF0KSAhPT0gLTE7XG59XG5cblxudmFyIFRPS0VOID0ge1xuICBTVEFSVF9FWFBSOiAnVEtfU1RBUlRfRVhQUicsXG4gIEVORF9FWFBSOiAnVEtfRU5EX0VYUFInLFxuICBTVEFSVF9CTE9DSzogJ1RLX1NUQVJUX0JMT0NLJyxcbiAgRU5EX0JMT0NLOiAnVEtfRU5EX0JMT0NLJyxcbiAgV09SRDogJ1RLX1dPUkQnLFxuICBSRVNFUlZFRDogJ1RLX1JFU0VSVkVEJyxcbiAgU0VNSUNPTE9OOiAnVEtfU0VNSUNPTE9OJyxcbiAgU1RSSU5HOiAnVEtfU1RSSU5HJyxcbiAgRVFVQUxTOiAnVEtfRVFVQUxTJyxcbiAgT1BFUkFUT1I6ICdUS19PUEVSQVRPUicsXG4gIENPTU1BOiAnVEtfQ09NTUEnLFxuICBCTE9DS19DT01NRU5UOiAnVEtfQkxPQ0tfQ09NTUVOVCcsXG4gIENPTU1FTlQ6ICdUS19DT01NRU5UJyxcbiAgRE9UOiAnVEtfRE9UJyxcbiAgVU5LTk9XTjogJ1RLX1VOS05PV04nLFxuICBTVEFSVDogQkFTRVRPS0VOLlNUQVJULFxuICBSQVc6IEJBU0VUT0tFTi5SQVcsXG4gIEVPRjogQkFTRVRPS0VOLkVPRlxufTtcblxuXG52YXIgZGlyZWN0aXZlc19jb3JlID0gbmV3IERpcmVjdGl2ZXMoL1xcL1xcKi8sIC9cXCpcXC8vKTtcblxudmFyIG51bWJlcl9wYXR0ZXJuID0gLzBbeFhdWzAxMjM0NTY3ODlhYmNkZWZBQkNERUZfXSpuP3wwW29PXVswMTIzNDU2N19dKm4/fDBbYkJdWzAxX10qbj98XFxkW1xcZF9dKm58KD86XFwuXFxkW1xcZF9dKnxcXGRbXFxkX10qXFwuP1tcXGRfXSopKD86W2VFXVsrLV0/W1xcZF9dKyk/LztcblxudmFyIGRpZ2l0ID0gL1swLTldLztcblxuLy8gRG90IFwiLlwiIG11c3QgYmUgZGlzdGluZ3Vpc2hlZCBmcm9tIFwiLi4uXCIgYW5kIGRlY2ltYWxcbnZhciBkb3RfcGF0dGVybiA9IC9bXlxcZFxcLl0vO1xuXG52YXIgcG9zaXRpb25hYmxlX29wZXJhdG9ycyA9IChcbiAgXCI+Pj4gPT09ICE9PSAmJj0gPz89IHx8PSBcIiArXG4gIFwiPDwgJiYgPj0gKiogIT0gPT0gPD0gPj4gfHwgPz8gfD4gXCIgK1xuICBcIjwgLyAtICsgPiA6ICYgJSA/IF4gfCAqXCIpLnNwbGl0KCcgJyk7XG5cbi8vIElNUE9SVEFOVDogdGhpcyBtdXN0IGJlIHNvcnRlZCBsb25nZXN0IHRvIHNob3J0ZXN0IG9yIHRva2VuaXppbmcgbWFueSBub3Qgd29yay5cbi8vIEFsc28sIHlvdSBtdXN0IHVwZGF0ZSBwb3NzaXRpb25hYmxlIG9wZXJhdG9ycyBzZXBhcmF0ZWx5IGZyb20gcHVuY3RcbnZhciBwdW5jdCA9XG4gIFwiPj4+PSBcIiArXG4gIFwiLi4uID4+PSA8PD0gPT09ID4+PiAhPT0gKio9ICYmPSA/Pz0gfHw9IFwiICtcbiAgXCI9PiBePSA6OiAvPSA8PCA8PSA9PSAmJiAtPSA+PSA+PiAhPSAtLSArPSAqKiB8fCA/PyArKyAlPSAmPSAqPSB8PSB8PiBcIiArXG4gIFwiPSAhID8gPiA8IDogLyBeIC0gKyAqICYgJSB+IHxcIjtcblxucHVuY3QgPSBwdW5jdC5yZXBsYWNlKC9bLVtcXF17fSgpKis/LixcXFxcXiR8I10vZywgXCJcXFxcJCZcIik7XG4vLyA/LiBidXQgbm90IGlmIGZvbGxvd2VkIGJ5IGEgbnVtYmVyIFxucHVuY3QgPSAnXFxcXD9cXFxcLig/IVxcXFxkKSAnICsgcHVuY3Q7XG5wdW5jdCA9IHB1bmN0LnJlcGxhY2UoLyAvZywgJ3wnKTtcblxudmFyIHB1bmN0X3BhdHRlcm4gPSBuZXcgUmVnRXhwKHB1bmN0KTtcblxuLy8gd29yZHMgd2hpY2ggc2hvdWxkIGFsd2F5cyBzdGFydCBvbiBuZXcgbGluZS5cbnZhciBsaW5lX3N0YXJ0ZXJzID0gJ2NvbnRpbnVlLHRyeSx0aHJvdyxyZXR1cm4sdmFyLGxldCxjb25zdCxpZixzd2l0Y2gsY2FzZSxkZWZhdWx0LGZvcix3aGlsZSxicmVhayxmdW5jdGlvbixpbXBvcnQsZXhwb3J0Jy5zcGxpdCgnLCcpO1xudmFyIHJlc2VydmVkX3dvcmRzID0gbGluZV9zdGFydGVycy5jb25jYXQoWydkbycsICdpbicsICdvZicsICdlbHNlJywgJ2dldCcsICdzZXQnLCAnbmV3JywgJ2NhdGNoJywgJ2ZpbmFsbHknLCAndHlwZW9mJywgJ3lpZWxkJywgJ2FzeW5jJywgJ2F3YWl0JywgJ2Zyb20nLCAnYXMnLCAnY2xhc3MnLCAnZXh0ZW5kcyddKTtcbnZhciByZXNlcnZlZF93b3JkX3BhdHRlcm4gPSBuZXcgUmVnRXhwKCdeKD86JyArIHJlc2VydmVkX3dvcmRzLmpvaW4oJ3wnKSArICcpJCcpO1xuXG4vLyB2YXIgdGVtcGxhdGVfcGF0dGVybiA9IC8oPzooPzo8XFw/cGhwfDxcXD89KVtcXHNcXFNdKj9cXD8+KXwoPzo8JVtcXHNcXFNdKj8lPikvZztcblxudmFyIGluX2h0bWxfY29tbWVudDtcblxudmFyIFRva2VuaXplciA9IGZ1bmN0aW9uKGlucHV0X3N0cmluZywgb3B0aW9ucykge1xuICBCYXNlVG9rZW5pemVyLmNhbGwodGhpcywgaW5wdXRfc3RyaW5nLCBvcHRpb25zKTtcblxuICB0aGlzLl9wYXR0ZXJucy53aGl0ZXNwYWNlID0gdGhpcy5fcGF0dGVybnMud2hpdGVzcGFjZS5tYXRjaGluZyhcbiAgICAvXFx1MDBBMFxcdTE2ODBcXHUxODBlXFx1MjAwMC1cXHUyMDBhXFx1MjAyZlxcdTIwNWZcXHUzMDAwXFx1ZmVmZi8uc291cmNlLFxuICAgIC9cXHUyMDI4XFx1MjAyOS8uc291cmNlKTtcblxuICB2YXIgcGF0dGVybl9yZWFkZXIgPSBuZXcgUGF0dGVybih0aGlzLl9pbnB1dCk7XG4gIHZhciB0ZW1wbGF0YWJsZSA9IG5ldyBUZW1wbGF0YWJsZVBhdHRlcm4odGhpcy5faW5wdXQpXG4gICAgLnJlYWRfb3B0aW9ucyh0aGlzLl9vcHRpb25zKTtcblxuICB0aGlzLl9fcGF0dGVybnMgPSB7XG4gICAgdGVtcGxhdGU6IHRlbXBsYXRhYmxlLFxuICAgIGlkZW50aWZpZXI6IHRlbXBsYXRhYmxlLnN0YXJ0aW5nX3dpdGgoYWNvcm4uaWRlbnRpZmllcikubWF0Y2hpbmcoYWNvcm4uaWRlbnRpZmllck1hdGNoKSxcbiAgICBudW1iZXI6IHBhdHRlcm5fcmVhZGVyLm1hdGNoaW5nKG51bWJlcl9wYXR0ZXJuKSxcbiAgICBwdW5jdDogcGF0dGVybl9yZWFkZXIubWF0Y2hpbmcocHVuY3RfcGF0dGVybiksXG4gICAgLy8gY29tbWVudCBlbmRzIGp1c3QgYmVmb3JlIG5lYXJlc3QgbGluZWZlZWQgb3IgZW5kIG9mIGZpbGVcbiAgICBjb21tZW50OiBwYXR0ZXJuX3JlYWRlci5zdGFydGluZ193aXRoKC9cXC9cXC8vKS51bnRpbCgvW1xcblxcclxcdTIwMjhcXHUyMDI5XS8pLFxuICAgIC8vICAvKiAuLi4gKi8gY29tbWVudCBlbmRzIHdpdGggbmVhcmVzdCAqLyBvciBlbmQgb2YgZmlsZVxuICAgIGJsb2NrX2NvbW1lbnQ6IHBhdHRlcm5fcmVhZGVyLnN0YXJ0aW5nX3dpdGgoL1xcL1xcKi8pLnVudGlsX2FmdGVyKC9cXCpcXC8vKSxcbiAgICBodG1sX2NvbW1lbnRfc3RhcnQ6IHBhdHRlcm5fcmVhZGVyLm1hdGNoaW5nKC88IS0tLyksXG4gICAgaHRtbF9jb21tZW50X2VuZDogcGF0dGVybl9yZWFkZXIubWF0Y2hpbmcoLy0tPi8pLFxuICAgIGluY2x1ZGU6IHBhdHRlcm5fcmVhZGVyLnN0YXJ0aW5nX3dpdGgoLyNpbmNsdWRlLykudW50aWxfYWZ0ZXIoYWNvcm4ubGluZUJyZWFrKSxcbiAgICBzaGViYW5nOiBwYXR0ZXJuX3JlYWRlci5zdGFydGluZ193aXRoKC8jIS8pLnVudGlsX2FmdGVyKGFjb3JuLmxpbmVCcmVhayksXG4gICAgeG1sOiBwYXR0ZXJuX3JlYWRlci5tYXRjaGluZygvW1xcc1xcU10qPzwoXFwvPykoWy1hLXpBLVo6MC05Xy5dK3x7W159XSs/fXwhXFxbQ0RBVEFcXFtbXlxcXV0qP1xcXVxcXXwpKFxccyp7W159XSs/fXxcXHMrWy1hLXpBLVo6MC05Xy5dK3xcXHMrWy1hLXpBLVo6MC05Xy5dK1xccyo9XFxzKignW14nXSonfFwiW15cIl0qXCJ8eyhbXnt9XXx7W159XSs/fSkrP30pKSpcXHMqKFxcLz8pXFxzKj4vKSxcbiAgICBzaW5nbGVfcXVvdGU6IHRlbXBsYXRhYmxlLnVudGlsKC9bJ1xcXFxcXG5cXHJcXHUyMDI4XFx1MjAyOV0vKSxcbiAgICBkb3VibGVfcXVvdGU6IHRlbXBsYXRhYmxlLnVudGlsKC9bXCJcXFxcXFxuXFxyXFx1MjAyOFxcdTIwMjldLyksXG4gICAgdGVtcGxhdGVfdGV4dDogdGVtcGxhdGFibGUudW50aWwoL1tgXFxcXCRdLyksXG4gICAgdGVtcGxhdGVfZXhwcmVzc2lvbjogdGVtcGxhdGFibGUudW50aWwoL1tgfVxcXFxdLylcbiAgfTtcblxufTtcblRva2VuaXplci5wcm90b3R5cGUgPSBuZXcgQmFzZVRva2VuaXplcigpO1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9pc19jb21tZW50ID0gZnVuY3Rpb24oY3VycmVudF90b2tlbikge1xuICByZXR1cm4gY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5DT01NRU5UIHx8IGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uQkxPQ0tfQ09NTUVOVCB8fCBjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLlVOS05PV047XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9pc19vcGVuaW5nID0gZnVuY3Rpb24oY3VycmVudF90b2tlbikge1xuICByZXR1cm4gY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5TVEFSVF9CTE9DSyB8fCBjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLlNUQVJUX0VYUFI7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9pc19jbG9zaW5nID0gZnVuY3Rpb24oY3VycmVudF90b2tlbiwgb3Blbl90b2tlbikge1xuICByZXR1cm4gKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uRU5EX0JMT0NLIHx8IGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uRU5EX0VYUFIpICYmXG4gICAgKG9wZW5fdG9rZW4gJiYgKFxuICAgICAgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJ10nICYmIG9wZW5fdG9rZW4udGV4dCA9PT0gJ1snKSB8fFxuICAgICAgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJyknICYmIG9wZW5fdG9rZW4udGV4dCA9PT0gJygnKSB8fFxuICAgICAgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJ30nICYmIG9wZW5fdG9rZW4udGV4dCA9PT0gJ3snKSkpO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fcmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgaW5faHRtbF9jb21tZW50ID0gZmFsc2U7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9nZXRfbmV4dF90b2tlbiA9IGZ1bmN0aW9uKHByZXZpb3VzX3Rva2VuLCBvcGVuX3Rva2VuKSB7IC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbiAgdmFyIHRva2VuID0gbnVsbDtcbiAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcbiAgdmFyIGMgPSB0aGlzLl9pbnB1dC5wZWVrKCk7XG5cbiAgaWYgKGMgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLkVPRiwgJycpO1xuICB9XG5cbiAgdG9rZW4gPSB0b2tlbiB8fCB0aGlzLl9yZWFkX25vbl9qYXZhc2NyaXB0KGMpO1xuICB0b2tlbiA9IHRva2VuIHx8IHRoaXMuX3JlYWRfc3RyaW5nKGMpO1xuICB0b2tlbiA9IHRva2VuIHx8IHRoaXMuX3JlYWRfcGFpcihjLCB0aGlzLl9pbnB1dC5wZWVrKDEpKTsgLy8gSXNzdWUgIzIwNjIgaGFjayBmb3IgcmVjb3JkIHR5cGUgJyN7J1xuICB0b2tlbiA9IHRva2VuIHx8IHRoaXMuX3JlYWRfd29yZChwcmV2aW91c190b2tlbik7XG4gIHRva2VuID0gdG9rZW4gfHwgdGhpcy5fcmVhZF9zaW5nbGVzKGMpO1xuICB0b2tlbiA9IHRva2VuIHx8IHRoaXMuX3JlYWRfY29tbWVudChjKTtcbiAgdG9rZW4gPSB0b2tlbiB8fCB0aGlzLl9yZWFkX3JlZ2V4cChjLCBwcmV2aW91c190b2tlbik7XG4gIHRva2VuID0gdG9rZW4gfHwgdGhpcy5fcmVhZF94bWwoYywgcHJldmlvdXNfdG9rZW4pO1xuICB0b2tlbiA9IHRva2VuIHx8IHRoaXMuX3JlYWRfcHVuY3R1YXRpb24oKTtcbiAgdG9rZW4gPSB0b2tlbiB8fCB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uVU5LTk9XTiwgdGhpcy5faW5wdXQubmV4dCgpKTtcblxuICByZXR1cm4gdG9rZW47XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZWFkX3dvcmQgPSBmdW5jdGlvbihwcmV2aW91c190b2tlbikge1xuICB2YXIgcmVzdWx0aW5nX3N0cmluZztcbiAgcmVzdWx0aW5nX3N0cmluZyA9IHRoaXMuX19wYXR0ZXJucy5pZGVudGlmaWVyLnJlYWQoKTtcbiAgaWYgKHJlc3VsdGluZ19zdHJpbmcgIT09ICcnKSB7XG4gICAgcmVzdWx0aW5nX3N0cmluZyA9IHJlc3VsdGluZ19zdHJpbmcucmVwbGFjZShhY29ybi5hbGxMaW5lQnJlYWtzLCAnXFxuJyk7XG4gICAgaWYgKCEocHJldmlvdXNfdG9rZW4udHlwZSA9PT0gVE9LRU4uRE9UIHx8XG4gICAgICAgIChwcmV2aW91c190b2tlbi50eXBlID09PSBUT0tFTi5SRVNFUlZFRCAmJiAocHJldmlvdXNfdG9rZW4udGV4dCA9PT0gJ3NldCcgfHwgcHJldmlvdXNfdG9rZW4udGV4dCA9PT0gJ2dldCcpKSkgJiZcbiAgICAgIHJlc2VydmVkX3dvcmRfcGF0dGVybi50ZXN0KHJlc3VsdGluZ19zdHJpbmcpKSB7XG4gICAgICBpZiAoKHJlc3VsdGluZ19zdHJpbmcgPT09ICdpbicgfHwgcmVzdWx0aW5nX3N0cmluZyA9PT0gJ29mJykgJiZcbiAgICAgICAgKHByZXZpb3VzX3Rva2VuLnR5cGUgPT09IFRPS0VOLldPUkQgfHwgcHJldmlvdXNfdG9rZW4udHlwZSA9PT0gVE9LRU4uU1RSSU5HKSkgeyAvLyBoYWNrIGZvciAnaW4nIGFuZCAnb2YnIG9wZXJhdG9yc1xuICAgICAgICByZXR1cm4gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLk9QRVJBVE9SLCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uUkVTRVJWRUQsIHJlc3VsdGluZ19zdHJpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLldPUkQsIHJlc3VsdGluZ19zdHJpbmcpO1xuICB9XG5cbiAgcmVzdWx0aW5nX3N0cmluZyA9IHRoaXMuX19wYXR0ZXJucy5udW1iZXIucmVhZCgpO1xuICBpZiAocmVzdWx0aW5nX3N0cmluZyAhPT0gJycpIHtcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLldPUkQsIHJlc3VsdGluZ19zdHJpbmcpO1xuICB9XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZWFkX3NpbmdsZXMgPSBmdW5jdGlvbihjKSB7XG4gIHZhciB0b2tlbiA9IG51bGw7XG4gIGlmIChjID09PSAnKCcgfHwgYyA9PT0gJ1snKSB7XG4gICAgdG9rZW4gPSB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uU1RBUlRfRVhQUiwgYyk7XG4gIH0gZWxzZSBpZiAoYyA9PT0gJyknIHx8IGMgPT09ICddJykge1xuICAgIHRva2VuID0gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLkVORF9FWFBSLCBjKTtcbiAgfSBlbHNlIGlmIChjID09PSAneycpIHtcbiAgICB0b2tlbiA9IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5TVEFSVF9CTE9DSywgYyk7XG4gIH0gZWxzZSBpZiAoYyA9PT0gJ30nKSB7XG4gICAgdG9rZW4gPSB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uRU5EX0JMT0NLLCBjKTtcbiAgfSBlbHNlIGlmIChjID09PSAnOycpIHtcbiAgICB0b2tlbiA9IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5TRU1JQ09MT04sIGMpO1xuICB9IGVsc2UgaWYgKGMgPT09ICcuJyAmJiBkb3RfcGF0dGVybi50ZXN0KHRoaXMuX2lucHV0LnBlZWsoMSkpKSB7XG4gICAgdG9rZW4gPSB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uRE9ULCBjKTtcbiAgfSBlbHNlIGlmIChjID09PSAnLCcpIHtcbiAgICB0b2tlbiA9IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5DT01NQSwgYyk7XG4gIH1cblxuICBpZiAodG9rZW4pIHtcbiAgICB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gIH1cbiAgcmV0dXJuIHRva2VuO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fcmVhZF9wYWlyID0gZnVuY3Rpb24oYywgZCkge1xuICB2YXIgdG9rZW4gPSBudWxsO1xuICBpZiAoYyA9PT0gJyMnICYmIGQgPT09ICd7Jykge1xuICAgIHRva2VuID0gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLlNUQVJUX0JMT0NLLCBjICsgZCk7XG4gIH1cblxuICBpZiAodG9rZW4pIHtcbiAgICB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgdGhpcy5faW5wdXQubmV4dCgpO1xuICB9XG4gIHJldHVybiB0b2tlbjtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3JlYWRfcHVuY3R1YXRpb24gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9fcGF0dGVybnMucHVuY3QucmVhZCgpO1xuXG4gIGlmIChyZXN1bHRpbmdfc3RyaW5nICE9PSAnJykge1xuICAgIGlmIChyZXN1bHRpbmdfc3RyaW5nID09PSAnPScpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uRVFVQUxTLCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgICB9IGVsc2UgaWYgKHJlc3VsdGluZ19zdHJpbmcgPT09ICc/LicpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uRE9ULCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5PUEVSQVRPUiwgcmVzdWx0aW5nX3N0cmluZyk7XG4gICAgfVxuICB9XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZWFkX25vbl9qYXZhc2NyaXB0ID0gZnVuY3Rpb24oYykge1xuICB2YXIgcmVzdWx0aW5nX3N0cmluZyA9ICcnO1xuXG4gIGlmIChjID09PSAnIycpIHtcbiAgICBpZiAodGhpcy5faXNfZmlyc3RfdG9rZW4oKSkge1xuICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHRoaXMuX19wYXR0ZXJucy5zaGViYW5nLnJlYWQoKTtcblxuICAgICAgaWYgKHJlc3VsdGluZ19zdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5VTktOT1dOLCByZXN1bHRpbmdfc3RyaW5nLnRyaW0oKSArICdcXG4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBoYW5kbGVzIGV4dGVuZHNjcmlwdCAjaW5jbHVkZXNcbiAgICByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5fX3BhdHRlcm5zLmluY2x1ZGUucmVhZCgpO1xuXG4gICAgaWYgKHJlc3VsdGluZ19zdHJpbmcpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uVU5LTk9XTiwgcmVzdWx0aW5nX3N0cmluZy50cmltKCkgKyAnXFxuJyk7XG4gICAgfVxuXG4gICAgYyA9IHRoaXMuX2lucHV0Lm5leHQoKTtcblxuICAgIC8vIFNwaWRlcm1vbmtleS1zcGVjaWZpYyBzaGFycCB2YXJpYWJsZXMgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMuIENvbnNpZGVyZWQgb2Jzb2xldGUuXG4gICAgdmFyIHNoYXJwID0gJyMnO1xuICAgIGlmICh0aGlzLl9pbnB1dC5oYXNOZXh0KCkgJiYgdGhpcy5faW5wdXQudGVzdENoYXIoZGlnaXQpKSB7XG4gICAgICBkbyB7XG4gICAgICAgIGMgPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgICAgIHNoYXJwICs9IGM7XG4gICAgICB9IHdoaWxlICh0aGlzLl9pbnB1dC5oYXNOZXh0KCkgJiYgYyAhPT0gJyMnICYmIGMgIT09ICc9Jyk7XG4gICAgICBpZiAoYyA9PT0gJyMnKSB7XG4gICAgICAgIC8vXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2lucHV0LnBlZWsoKSA9PT0gJ1snICYmIHRoaXMuX2lucHV0LnBlZWsoMSkgPT09ICddJykge1xuICAgICAgICBzaGFycCArPSAnW10nO1xuICAgICAgICB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgICAgIHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5faW5wdXQucGVlaygpID09PSAneycgJiYgdGhpcy5faW5wdXQucGVlaygxKSA9PT0gJ30nKSB7XG4gICAgICAgIHNoYXJwICs9ICd7fSc7XG4gICAgICAgIHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICAgICAgdGhpcy5faW5wdXQubmV4dCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5XT1JELCBzaGFycCk7XG4gICAgfVxuXG4gICAgdGhpcy5faW5wdXQuYmFjaygpO1xuXG4gIH0gZWxzZSBpZiAoYyA9PT0gJzwnICYmIHRoaXMuX2lzX2ZpcnN0X3Rva2VuKCkpIHtcbiAgICByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5fX3BhdHRlcm5zLmh0bWxfY29tbWVudF9zdGFydC5yZWFkKCk7XG4gICAgaWYgKHJlc3VsdGluZ19zdHJpbmcpIHtcbiAgICAgIHdoaWxlICh0aGlzLl9pbnB1dC5oYXNOZXh0KCkgJiYgIXRoaXMuX2lucHV0LnRlc3RDaGFyKGFjb3JuLm5ld2xpbmUpKSB7XG4gICAgICAgIHJlc3VsdGluZ19zdHJpbmcgKz0gdGhpcy5faW5wdXQubmV4dCgpO1xuICAgICAgfVxuICAgICAgaW5faHRtbF9jb21tZW50ID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uQ09NTUVOVCwgcmVzdWx0aW5nX3N0cmluZyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGluX2h0bWxfY29tbWVudCAmJiBjID09PSAnLScpIHtcbiAgICByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5fX3BhdHRlcm5zLmh0bWxfY29tbWVudF9lbmQucmVhZCgpO1xuICAgIGlmIChyZXN1bHRpbmdfc3RyaW5nKSB7XG4gICAgICBpbl9odG1sX2NvbW1lbnQgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uQ09NTUVOVCwgcmVzdWx0aW5nX3N0cmluZyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZWFkX2NvbW1lbnQgPSBmdW5jdGlvbihjKSB7XG4gIHZhciB0b2tlbiA9IG51bGw7XG4gIGlmIChjID09PSAnLycpIHtcbiAgICB2YXIgY29tbWVudCA9ICcnO1xuICAgIGlmICh0aGlzLl9pbnB1dC5wZWVrKDEpID09PSAnKicpIHtcbiAgICAgIC8vIHBlZWsgZm9yIGNvbW1lbnQgLyogLi4uICovXG4gICAgICBjb21tZW50ID0gdGhpcy5fX3BhdHRlcm5zLmJsb2NrX2NvbW1lbnQucmVhZCgpO1xuICAgICAgdmFyIGRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzX2NvcmUuZ2V0X2RpcmVjdGl2ZXMoY29tbWVudCk7XG4gICAgICBpZiAoZGlyZWN0aXZlcyAmJiBkaXJlY3RpdmVzLmlnbm9yZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICBjb21tZW50ICs9IGRpcmVjdGl2ZXNfY29yZS5yZWFkSWdub3JlZCh0aGlzLl9pbnB1dCk7XG4gICAgICB9XG4gICAgICBjb21tZW50ID0gY29tbWVudC5yZXBsYWNlKGFjb3JuLmFsbExpbmVCcmVha3MsICdcXG4nKTtcbiAgICAgIHRva2VuID0gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLkJMT0NLX0NPTU1FTlQsIGNvbW1lbnQpO1xuICAgICAgdG9rZW4uZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZXM7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9pbnB1dC5wZWVrKDEpID09PSAnLycpIHtcbiAgICAgIC8vIHBlZWsgZm9yIGNvbW1lbnQgLy8gLi4uXG4gICAgICBjb21tZW50ID0gdGhpcy5fX3BhdHRlcm5zLmNvbW1lbnQucmVhZCgpO1xuICAgICAgdG9rZW4gPSB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uQ09NTUVOVCwgY29tbWVudCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0b2tlbjtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3JlYWRfc3RyaW5nID0gZnVuY3Rpb24oYykge1xuICBpZiAoYyA9PT0gJ2AnIHx8IGMgPT09IFwiJ1wiIHx8IGMgPT09ICdcIicpIHtcbiAgICB2YXIgcmVzdWx0aW5nX3N0cmluZyA9IHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICB0aGlzLmhhc19jaGFyX2VzY2FwZXMgPSBmYWxzZTtcblxuICAgIGlmIChjID09PSAnYCcpIHtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgKz0gdGhpcy5fcmVhZF9zdHJpbmdfcmVjdXJzaXZlKCdgJywgdHJ1ZSwgJyR7Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgKz0gdGhpcy5fcmVhZF9zdHJpbmdfcmVjdXJzaXZlKGMpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhhc19jaGFyX2VzY2FwZXMgJiYgdGhpcy5fb3B0aW9ucy51bmVzY2FwZV9zdHJpbmdzKSB7XG4gICAgICByZXN1bHRpbmdfc3RyaW5nID0gdW5lc2NhcGVfc3RyaW5nKHJlc3VsdGluZ19zdHJpbmcpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9pbnB1dC5wZWVrKCkgPT09IGMpIHtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgKz0gdGhpcy5faW5wdXQubmV4dCgpO1xuICAgIH1cblxuICAgIHJlc3VsdGluZ19zdHJpbmcgPSByZXN1bHRpbmdfc3RyaW5nLnJlcGxhY2UoYWNvcm4uYWxsTGluZUJyZWFrcywgJ1xcbicpO1xuXG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5TVFJJTkcsIHJlc3VsdGluZ19zdHJpbmcpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9hbGxvd19yZWdleHBfb3JfeG1sID0gZnVuY3Rpb24ocHJldmlvdXNfdG9rZW4pIHtcbiAgLy8gcmVnZXggYW5kIHhtbCBjYW4gb25seSBhcHBlYXIgaW4gc3BlY2lmaWMgbG9jYXRpb25zIGR1cmluZyBwYXJzaW5nXG4gIHJldHVybiAocHJldmlvdXNfdG9rZW4udHlwZSA9PT0gVE9LRU4uUkVTRVJWRUQgJiYgaW5fYXJyYXkocHJldmlvdXNfdG9rZW4udGV4dCwgWydyZXR1cm4nLCAnY2FzZScsICd0aHJvdycsICdlbHNlJywgJ2RvJywgJ3R5cGVvZicsICd5aWVsZCddKSkgfHxcbiAgICAocHJldmlvdXNfdG9rZW4udHlwZSA9PT0gVE9LRU4uRU5EX0VYUFIgJiYgcHJldmlvdXNfdG9rZW4udGV4dCA9PT0gJyknICYmXG4gICAgICBwcmV2aW91c190b2tlbi5vcGVuZWQucHJldmlvdXMudHlwZSA9PT0gVE9LRU4uUkVTRVJWRUQgJiYgaW5fYXJyYXkocHJldmlvdXNfdG9rZW4ub3BlbmVkLnByZXZpb3VzLnRleHQsIFsnaWYnLCAnd2hpbGUnLCAnZm9yJ10pKSB8fFxuICAgIChpbl9hcnJheShwcmV2aW91c190b2tlbi50eXBlLCBbVE9LRU4uQ09NTUVOVCwgVE9LRU4uU1RBUlRfRVhQUiwgVE9LRU4uU1RBUlRfQkxPQ0ssIFRPS0VOLlNUQVJULFxuICAgICAgVE9LRU4uRU5EX0JMT0NLLCBUT0tFTi5PUEVSQVRPUiwgVE9LRU4uRVFVQUxTLCBUT0tFTi5FT0YsIFRPS0VOLlNFTUlDT0xPTiwgVE9LRU4uQ09NTUFcbiAgICBdKSk7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZWFkX3JlZ2V4cCA9IGZ1bmN0aW9uKGMsIHByZXZpb3VzX3Rva2VuKSB7XG5cbiAgaWYgKGMgPT09ICcvJyAmJiB0aGlzLl9hbGxvd19yZWdleHBfb3JfeG1sKHByZXZpb3VzX3Rva2VuKSkge1xuICAgIC8vIGhhbmRsZSByZWdleHBcbiAgICAvL1xuICAgIHZhciByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5faW5wdXQubmV4dCgpO1xuICAgIHZhciBlc2MgPSBmYWxzZTtcblxuICAgIHZhciBpbl9jaGFyX2NsYXNzID0gZmFsc2U7XG4gICAgd2hpbGUgKHRoaXMuX2lucHV0Lmhhc05leHQoKSAmJlxuICAgICAgKChlc2MgfHwgaW5fY2hhcl9jbGFzcyB8fCB0aGlzLl9pbnB1dC5wZWVrKCkgIT09IGMpICYmXG4gICAgICAgICF0aGlzLl9pbnB1dC50ZXN0Q2hhcihhY29ybi5uZXdsaW5lKSkpIHtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgKz0gdGhpcy5faW5wdXQucGVlaygpO1xuICAgICAgaWYgKCFlc2MpIHtcbiAgICAgICAgZXNjID0gdGhpcy5faW5wdXQucGVlaygpID09PSAnXFxcXCc7XG4gICAgICAgIGlmICh0aGlzLl9pbnB1dC5wZWVrKCkgPT09ICdbJykge1xuICAgICAgICAgIGluX2NoYXJfY2xhc3MgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2lucHV0LnBlZWsoKSA9PT0gJ10nKSB7XG4gICAgICAgICAgaW5fY2hhcl9jbGFzcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlc2MgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faW5wdXQucGVlaygpID09PSBjKSB7XG4gICAgICByZXN1bHRpbmdfc3RyaW5nICs9IHRoaXMuX2lucHV0Lm5leHQoKTtcblxuICAgICAgLy8gcmVnZXhwcyBtYXkgaGF2ZSBtb2RpZmllcnMgL3JlZ2V4cC9NT0QgLCBzbyBmZXRjaCB0aG9zZSwgdG9vXG4gICAgICAvLyBPbmx5IFtnaW1dIGFyZSB2YWxpZCwgYnV0IGlmIHRoZSB1c2VyIHB1dHMgaW4gZ2FyYmFnZSwgZG8gd2hhdCB3ZSBjYW4gdG8gdGFrZSBpdC5cbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgKz0gdGhpcy5faW5wdXQucmVhZChhY29ybi5pZGVudGlmaWVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5TVFJJTkcsIHJlc3VsdGluZ19zdHJpbmcpO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fcmVhZF94bWwgPSBmdW5jdGlvbihjLCBwcmV2aW91c190b2tlbikge1xuXG4gIGlmICh0aGlzLl9vcHRpb25zLmU0eCAmJiBjID09PSBcIjxcIiAmJiB0aGlzLl9hbGxvd19yZWdleHBfb3JfeG1sKHByZXZpb3VzX3Rva2VuKSkge1xuICAgIHZhciB4bWxTdHIgPSAnJztcbiAgICB2YXIgbWF0Y2ggPSB0aGlzLl9fcGF0dGVybnMueG1sLnJlYWRfbWF0Y2goKTtcbiAgICAvLyBoYW5kbGUgZTR4IHhtbCBsaXRlcmFsc1xuICAgIC8vXG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICAvLyBUcmltIHJvb3QgdGFnIHRvIGF0dGVtcHQgdG9cbiAgICAgIHZhciByb290VGFnID0gbWF0Y2hbMl0ucmVwbGFjZSgvXntcXHMrLywgJ3snKS5yZXBsYWNlKC9cXHMrfSQvLCAnfScpO1xuICAgICAgdmFyIGlzQ3VybHlSb290ID0gcm9vdFRhZy5pbmRleE9mKCd7JykgPT09IDA7XG4gICAgICB2YXIgZGVwdGggPSAwO1xuICAgICAgd2hpbGUgKG1hdGNoKSB7XG4gICAgICAgIHZhciBpc0VuZFRhZyA9ICEhbWF0Y2hbMV07XG4gICAgICAgIHZhciB0YWdOYW1lID0gbWF0Y2hbMl07XG4gICAgICAgIHZhciBpc1NpbmdsZXRvblRhZyA9ICghIW1hdGNoW21hdGNoLmxlbmd0aCAtIDFdKSB8fCAodGFnTmFtZS5zbGljZSgwLCA4KSA9PT0gXCIhW0NEQVRBW1wiKTtcbiAgICAgICAgaWYgKCFpc1NpbmdsZXRvblRhZyAmJlxuICAgICAgICAgICh0YWdOYW1lID09PSByb290VGFnIHx8IChpc0N1cmx5Um9vdCAmJiB0YWdOYW1lLnJlcGxhY2UoL157XFxzKy8sICd7JykucmVwbGFjZSgvXFxzK30kLywgJ30nKSkpKSB7XG4gICAgICAgICAgaWYgKGlzRW5kVGFnKSB7XG4gICAgICAgICAgICAtLWRlcHRoO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICArK2RlcHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB4bWxTdHIgKz0gbWF0Y2hbMF07XG4gICAgICAgIGlmIChkZXB0aCA8PSAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbWF0Y2ggPSB0aGlzLl9fcGF0dGVybnMueG1sLnJlYWRfbWF0Y2goKTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBjbG9zZSBjb3JyZWN0bHksIGtlZXAgdW5mb3JtYXR0ZWQuXG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHhtbFN0ciArPSB0aGlzLl9pbnB1dC5tYXRjaCgvW1xcc1xcU10qL2cpWzBdO1xuICAgICAgfVxuICAgICAgeG1sU3RyID0geG1sU3RyLnJlcGxhY2UoYWNvcm4uYWxsTGluZUJyZWFrcywgJ1xcbicpO1xuICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5TVFJJTkcsIHhtbFN0cik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5mdW5jdGlvbiB1bmVzY2FwZV9zdHJpbmcocykge1xuICAvLyBZb3UgdGhpbmsgdGhhdCBhIHJlZ2V4IHdvdWxkIHdvcmsgZm9yIHRoaXNcbiAgLy8gcmV0dXJuIHMucmVwbGFjZSgvXFxcXHgoWzAtOWEtZl17Mn0pL2dpLCBmdW5jdGlvbihtYXRjaCwgdmFsKSB7XG4gIC8vICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQodmFsLCAxNikpO1xuICAvLyAgICAgfSlcbiAgLy8gSG93ZXZlciwgZGVhbGluZyB3aXRoICdcXHhmZicsICdcXFxceGZmJywgJ1xcXFxcXHhmZicgbWFrZXMgdGhpcyBtb3JlIGZ1bi5cbiAgdmFyIG91dCA9ICcnLFxuICAgIGVzY2FwZWQgPSAwO1xuXG4gIHZhciBpbnB1dF9zY2FuID0gbmV3IElucHV0U2Nhbm5lcihzKTtcbiAgdmFyIG1hdGNoZWQgPSBudWxsO1xuXG4gIHdoaWxlIChpbnB1dF9zY2FuLmhhc05leHQoKSkge1xuICAgIC8vIEtlZXAgYW55IHdoaXRlc3BhY2UsIG5vbi1zbGFzaCBjaGFyYWN0ZXJzXG4gICAgLy8gYWxzbyBrZWVwIHNsYXNoIHBhaXJzLlxuICAgIG1hdGNoZWQgPSBpbnB1dF9zY2FuLm1hdGNoKC8oW1xcc118W15cXFxcXXxcXFxcXFxcXCkrL2cpO1xuXG4gICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgIG91dCArPSBtYXRjaGVkWzBdO1xuICAgIH1cblxuICAgIGlmIChpbnB1dF9zY2FuLnBlZWsoKSA9PT0gJ1xcXFwnKSB7XG4gICAgICBpbnB1dF9zY2FuLm5leHQoKTtcbiAgICAgIGlmIChpbnB1dF9zY2FuLnBlZWsoKSA9PT0gJ3gnKSB7XG4gICAgICAgIG1hdGNoZWQgPSBpbnB1dF9zY2FuLm1hdGNoKC94KFswLTlBLUZhLWZdezJ9KS9nKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5wdXRfc2Nhbi5wZWVrKCkgPT09ICd1Jykge1xuICAgICAgICBtYXRjaGVkID0gaW5wdXRfc2Nhbi5tYXRjaCgvdShbMC05QS1GYS1mXXs0fSkvZyk7XG4gICAgICAgIGlmICghbWF0Y2hlZCkge1xuICAgICAgICAgIG1hdGNoZWQgPSBpbnB1dF9zY2FuLm1hdGNoKC91XFx7KFswLTlBLUZhLWZdKylcXH0vZyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnXFxcXCc7XG4gICAgICAgIGlmIChpbnB1dF9zY2FuLmhhc05leHQoKSkge1xuICAgICAgICAgIG91dCArPSBpbnB1dF9zY2FuLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlcmUncyBzb21lIGVycm9yIGRlY29kaW5nLCByZXR1cm4gdGhlIG9yaWdpbmFsIHN0cmluZ1xuICAgICAgaWYgKCFtYXRjaGVkKSB7XG4gICAgICAgIHJldHVybiBzO1xuICAgICAgfVxuXG4gICAgICBlc2NhcGVkID0gcGFyc2VJbnQobWF0Y2hlZFsxXSwgMTYpO1xuXG4gICAgICBpZiAoZXNjYXBlZCA+IDB4N2UgJiYgZXNjYXBlZCA8PSAweGZmICYmIG1hdGNoZWRbMF0uaW5kZXhPZigneCcpID09PSAwKSB7XG4gICAgICAgIC8vIHdlIGJhaWwgb3V0IG9uIFxceDdmLi5cXHhmZixcbiAgICAgICAgLy8gbGVhdmluZyB3aG9sZSBzdHJpbmcgZXNjYXBlZCxcbiAgICAgICAgLy8gYXMgaXQncyBwcm9iYWJseSBjb21wbGV0ZWx5IGJpbmFyeVxuICAgICAgICByZXR1cm4gcztcbiAgICAgIH0gZWxzZSBpZiAoZXNjYXBlZCA+PSAweDAwICYmIGVzY2FwZWQgPCAweDIwKSB7XG4gICAgICAgIC8vIGxlYXZlIDB4MDAuLi4weDFmIGVzY2FwZWRcbiAgICAgICAgb3V0ICs9ICdcXFxcJyArIG1hdGNoZWRbMF07XG4gICAgICB9IGVsc2UgaWYgKGVzY2FwZWQgPiAweDEwRkZGRikge1xuICAgICAgICAvLyBJZiB0aGUgZXNjYXBlIHNlcXVlbmNlIGlzIG91dCBvZiBib3VuZHMsIGtlZXAgdGhlIG9yaWdpbmFsIHNlcXVlbmNlIGFuZCBjb250aW51ZSBjb252ZXJzaW9uXG4gICAgICAgIG91dCArPSAnXFxcXCcgKyBtYXRjaGVkWzBdO1xuICAgICAgfSBlbHNlIGlmIChlc2NhcGVkID09PSAweDIyIHx8IGVzY2FwZWQgPT09IDB4MjcgfHwgZXNjYXBlZCA9PT0gMHg1Yykge1xuICAgICAgICAvLyBzaW5nbGUtcXVvdGUsIGFwb3N0cm9waGUsIGJhY2tzbGFzaCAtIGVzY2FwZSB0aGVzZVxuICAgICAgICBvdXQgKz0gJ1xcXFwnICsgU3RyaW5nLmZyb21DaGFyQ29kZShlc2NhcGVkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGVzY2FwZWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG5cbi8vIGhhbmRsZSBzdHJpbmdcbi8vXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZWFkX3N0cmluZ19yZWN1cnNpdmUgPSBmdW5jdGlvbihkZWxpbWl0ZXIsIGFsbG93X3VuZXNjYXBlZF9uZXdsaW5lcywgc3RhcnRfc3ViKSB7XG4gIHZhciBjdXJyZW50X2NoYXI7XG4gIHZhciBwYXR0ZXJuO1xuICBpZiAoZGVsaW1pdGVyID09PSAnXFwnJykge1xuICAgIHBhdHRlcm4gPSB0aGlzLl9fcGF0dGVybnMuc2luZ2xlX3F1b3RlO1xuICB9IGVsc2UgaWYgKGRlbGltaXRlciA9PT0gJ1wiJykge1xuICAgIHBhdHRlcm4gPSB0aGlzLl9fcGF0dGVybnMuZG91YmxlX3F1b3RlO1xuICB9IGVsc2UgaWYgKGRlbGltaXRlciA9PT0gJ2AnKSB7XG4gICAgcGF0dGVybiA9IHRoaXMuX19wYXR0ZXJucy50ZW1wbGF0ZV90ZXh0O1xuICB9IGVsc2UgaWYgKGRlbGltaXRlciA9PT0gJ30nKSB7XG4gICAgcGF0dGVybiA9IHRoaXMuX19wYXR0ZXJucy50ZW1wbGF0ZV9leHByZXNzaW9uO1xuICB9XG5cbiAgdmFyIHJlc3VsdGluZ19zdHJpbmcgPSBwYXR0ZXJuLnJlYWQoKTtcbiAgdmFyIG5leHQgPSAnJztcbiAgd2hpbGUgKHRoaXMuX2lucHV0Lmhhc05leHQoKSkge1xuICAgIG5leHQgPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgaWYgKG5leHQgPT09IGRlbGltaXRlciB8fFxuICAgICAgKCFhbGxvd191bmVzY2FwZWRfbmV3bGluZXMgJiYgYWNvcm4ubmV3bGluZS50ZXN0KG5leHQpKSkge1xuICAgICAgdGhpcy5faW5wdXQuYmFjaygpO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIGlmIChuZXh0ID09PSAnXFxcXCcgJiYgdGhpcy5faW5wdXQuaGFzTmV4dCgpKSB7XG4gICAgICBjdXJyZW50X2NoYXIgPSB0aGlzLl9pbnB1dC5wZWVrKCk7XG5cbiAgICAgIGlmIChjdXJyZW50X2NoYXIgPT09ICd4JyB8fCBjdXJyZW50X2NoYXIgPT09ICd1Jykge1xuICAgICAgICB0aGlzLmhhc19jaGFyX2VzY2FwZXMgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChjdXJyZW50X2NoYXIgPT09ICdcXHInICYmIHRoaXMuX2lucHV0LnBlZWsoMSkgPT09ICdcXG4nKSB7XG4gICAgICAgIHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICAgIH1cbiAgICAgIG5leHQgKz0gdGhpcy5faW5wdXQubmV4dCgpO1xuICAgIH0gZWxzZSBpZiAoc3RhcnRfc3ViKSB7XG4gICAgICBpZiAoc3RhcnRfc3ViID09PSAnJHsnICYmIG5leHQgPT09ICckJyAmJiB0aGlzLl9pbnB1dC5wZWVrKCkgPT09ICd7Jykge1xuICAgICAgICBuZXh0ICs9IHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXJ0X3N1YiA9PT0gbmV4dCkge1xuICAgICAgICBpZiAoZGVsaW1pdGVyID09PSAnYCcpIHtcbiAgICAgICAgICBuZXh0ICs9IHRoaXMuX3JlYWRfc3RyaW5nX3JlY3Vyc2l2ZSgnfScsIGFsbG93X3VuZXNjYXBlZF9uZXdsaW5lcywgJ2AnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0ICs9IHRoaXMuX3JlYWRfc3RyaW5nX3JlY3Vyc2l2ZSgnYCcsIGFsbG93X3VuZXNjYXBlZF9uZXdsaW5lcywgJyR7Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2lucHV0Lmhhc05leHQoKSkge1xuICAgICAgICAgIG5leHQgKz0gdGhpcy5faW5wdXQubmV4dCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG5leHQgKz0gcGF0dGVybi5yZWFkKCk7XG4gICAgcmVzdWx0aW5nX3N0cmluZyArPSBuZXh0O1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdGluZ19zdHJpbmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5Ub2tlbml6ZXIgPSBUb2tlbml6ZXI7XG5tb2R1bGUuZXhwb3J0cy5UT0tFTiA9IFRPS0VOO1xubW9kdWxlLmV4cG9ydHMucG9zaXRpb25hYmxlX29wZXJhdG9ycyA9IHBvc2l0aW9uYWJsZV9vcGVyYXRvcnMuc2xpY2UoKTtcbm1vZHVsZS5leHBvcnRzLmxpbmVfc3RhcnRlcnMgPSBsaW5lX3N0YXJ0ZXJzLnNsaWNlKCk7XG5cblxuLyoqKi8gfSksXG4vKiA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxudmFyIHJlZ2V4cF9oYXNfc3RpY2t5ID0gUmVnRXhwLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnc3RpY2t5Jyk7XG5cbmZ1bmN0aW9uIElucHV0U2Nhbm5lcihpbnB1dF9zdHJpbmcpIHtcbiAgdGhpcy5fX2lucHV0ID0gaW5wdXRfc3RyaW5nIHx8ICcnO1xuICB0aGlzLl9faW5wdXRfbGVuZ3RoID0gdGhpcy5fX2lucHV0Lmxlbmd0aDtcbiAgdGhpcy5fX3Bvc2l0aW9uID0gMDtcbn1cblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5yZXN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX19wb3NpdGlvbiA9IDA7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLmJhY2sgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX19wb3NpdGlvbiA+IDApIHtcbiAgICB0aGlzLl9fcG9zaXRpb24gLT0gMTtcbiAgfVxufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5oYXNOZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9fcG9zaXRpb24gPCB0aGlzLl9faW5wdXRfbGVuZ3RoO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciB2YWwgPSBudWxsO1xuICBpZiAodGhpcy5oYXNOZXh0KCkpIHtcbiAgICB2YWwgPSB0aGlzLl9faW5wdXQuY2hhckF0KHRoaXMuX19wb3NpdGlvbik7XG4gICAgdGhpcy5fX3Bvc2l0aW9uICs9IDE7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gIHZhciB2YWwgPSBudWxsO1xuICBpbmRleCA9IGluZGV4IHx8IDA7XG4gIGluZGV4ICs9IHRoaXMuX19wb3NpdGlvbjtcbiAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLl9faW5wdXRfbGVuZ3RoKSB7XG4gICAgdmFsID0gdGhpcy5fX2lucHV0LmNoYXJBdChpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn07XG5cbi8vIFRoaXMgaXMgYSBKYXZhU2NyaXB0IG9ubHkgaGVscGVyIGZ1bmN0aW9uIChub3QgaW4gcHl0aG9uKVxuLy8gSmF2YXNjcmlwdCBkb2Vzbid0IGhhdmUgYSBtYXRjaCBtZXRob2Rcbi8vIGFuZCBub3QgYWxsIGltcGxlbWVudGF0aW9uIHN1cHBvcnQgXCJzdGlja3lcIiBmbGFnLlxuLy8gSWYgdGhleSBkbyBub3Qgc3VwcG9ydCBzdGlja3kgdGhlbiBib3RoIHRoaXMubWF0Y2goKSBhbmQgdGhpcy50ZXN0KCkgbWV0aG9kXG4vLyBtdXN0IGdldCB0aGUgbWF0Y2ggYW5kIGNoZWNrIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2guXG4vLyBJZiBzdGlja3kgaXMgc3VwcG9ydGVkIGFuZCBzZXQsIHRoaXMgbWV0aG9kIHdpbGwgdXNlIGl0LlxuLy8gT3RoZXJ3aXNlIGl0IHdpbGwgY2hlY2sgdGhhdCBnbG9iYWwgaXMgc2V0LCBhbmQgZmFsbCBiYWNrIHRvIHRoZSBzbG93ZXIgbWV0aG9kLlxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5fX21hdGNoID0gZnVuY3Rpb24ocGF0dGVybiwgaW5kZXgpIHtcbiAgcGF0dGVybi5sYXN0SW5kZXggPSBpbmRleDtcbiAgdmFyIHBhdHRlcm5fbWF0Y2ggPSBwYXR0ZXJuLmV4ZWModGhpcy5fX2lucHV0KTtcblxuICBpZiAocGF0dGVybl9tYXRjaCAmJiAhKHJlZ2V4cF9oYXNfc3RpY2t5ICYmIHBhdHRlcm4uc3RpY2t5KSkge1xuICAgIGlmIChwYXR0ZXJuX21hdGNoLmluZGV4ICE9PSBpbmRleCkge1xuICAgICAgcGF0dGVybl9tYXRjaCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhdHRlcm5fbWF0Y2g7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbihwYXR0ZXJuLCBpbmRleCkge1xuICBpbmRleCA9IGluZGV4IHx8IDA7XG4gIGluZGV4ICs9IHRoaXMuX19wb3NpdGlvbjtcblxuICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMuX19pbnB1dF9sZW5ndGgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9fbWF0Y2gocGF0dGVybiwgaW5kZXgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS50ZXN0Q2hhciA9IGZ1bmN0aW9uKHBhdHRlcm4sIGluZGV4KSB7XG4gIC8vIHRlc3Qgb25lIGNoYXJhY3RlciByZWdleCBtYXRjaFxuICB2YXIgdmFsID0gdGhpcy5wZWVrKGluZGV4KTtcbiAgcGF0dGVybi5sYXN0SW5kZXggPSAwO1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmIHBhdHRlcm4udGVzdCh2YWwpO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgdmFyIHBhdHRlcm5fbWF0Y2ggPSB0aGlzLl9fbWF0Y2gocGF0dGVybiwgdGhpcy5fX3Bvc2l0aW9uKTtcbiAgaWYgKHBhdHRlcm5fbWF0Y2gpIHtcbiAgICB0aGlzLl9fcG9zaXRpb24gKz0gcGF0dGVybl9tYXRjaFswXS5sZW5ndGg7XG4gIH0gZWxzZSB7XG4gICAgcGF0dGVybl9tYXRjaCA9IG51bGw7XG4gIH1cbiAgcmV0dXJuIHBhdHRlcm5fbWF0Y2g7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihzdGFydGluZ19wYXR0ZXJuLCB1bnRpbF9wYXR0ZXJuLCB1bnRpbF9hZnRlcikge1xuICB2YXIgdmFsID0gJyc7XG4gIHZhciBtYXRjaDtcbiAgaWYgKHN0YXJ0aW5nX3BhdHRlcm4pIHtcbiAgICBtYXRjaCA9IHRoaXMubWF0Y2goc3RhcnRpbmdfcGF0dGVybik7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICB2YWwgKz0gbWF0Y2hbMF07XG4gICAgfVxuICB9XG4gIGlmICh1bnRpbF9wYXR0ZXJuICYmIChtYXRjaCB8fCAhc3RhcnRpbmdfcGF0dGVybikpIHtcbiAgICB2YWwgKz0gdGhpcy5yZWFkVW50aWwodW50aWxfcGF0dGVybiwgdW50aWxfYWZ0ZXIpO1xuICB9XG4gIHJldHVybiB2YWw7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLnJlYWRVbnRpbCA9IGZ1bmN0aW9uKHBhdHRlcm4sIHVudGlsX2FmdGVyKSB7XG4gIHZhciB2YWwgPSAnJztcbiAgdmFyIG1hdGNoX2luZGV4ID0gdGhpcy5fX3Bvc2l0aW9uO1xuICBwYXR0ZXJuLmxhc3RJbmRleCA9IHRoaXMuX19wb3NpdGlvbjtcbiAgdmFyIHBhdHRlcm5fbWF0Y2ggPSBwYXR0ZXJuLmV4ZWModGhpcy5fX2lucHV0KTtcbiAgaWYgKHBhdHRlcm5fbWF0Y2gpIHtcbiAgICBtYXRjaF9pbmRleCA9IHBhdHRlcm5fbWF0Y2guaW5kZXg7XG4gICAgaWYgKHVudGlsX2FmdGVyKSB7XG4gICAgICBtYXRjaF9pbmRleCArPSBwYXR0ZXJuX21hdGNoWzBdLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbWF0Y2hfaW5kZXggPSB0aGlzLl9faW5wdXRfbGVuZ3RoO1xuICB9XG5cbiAgdmFsID0gdGhpcy5fX2lucHV0LnN1YnN0cmluZyh0aGlzLl9fcG9zaXRpb24sIG1hdGNoX2luZGV4KTtcbiAgdGhpcy5fX3Bvc2l0aW9uID0gbWF0Y2hfaW5kZXg7XG4gIHJldHVybiB2YWw7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLnJlYWRVbnRpbEFmdGVyID0gZnVuY3Rpb24ocGF0dGVybikge1xuICByZXR1cm4gdGhpcy5yZWFkVW50aWwocGF0dGVybiwgdHJ1ZSk7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLmdldF9yZWdleHAgPSBmdW5jdGlvbihwYXR0ZXJuLCBtYXRjaF9mcm9tKSB7XG4gIHZhciByZXN1bHQgPSBudWxsO1xuICB2YXIgZmxhZ3MgPSAnZyc7XG4gIGlmIChtYXRjaF9mcm9tICYmIHJlZ2V4cF9oYXNfc3RpY2t5KSB7XG4gICAgZmxhZ3MgPSAneSc7XG4gIH1cbiAgLy8gc3RyaW5ncyBhcmUgY29udmVydGVkIHRvIHJlZ2V4cFxuICBpZiAodHlwZW9mIHBhdHRlcm4gPT09IFwic3RyaW5nXCIgJiYgcGF0dGVybiAhPT0gJycpIHtcbiAgICAvLyByZXN1bHQgPSBuZXcgUmVnRXhwKHBhdHRlcm4ucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyksIGZsYWdzKTtcbiAgICByZXN1bHQgPSBuZXcgUmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcbiAgfSBlbHNlIGlmIChwYXR0ZXJuKSB7XG4gICAgcmVzdWx0ID0gbmV3IFJlZ0V4cChwYXR0ZXJuLnNvdXJjZSwgZmxhZ3MpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLmdldF9saXRlcmFsX3JlZ2V4cCA9IGZ1bmN0aW9uKGxpdGVyYWxfc3RyaW5nKSB7XG4gIHJldHVybiBSZWdFeHAobGl0ZXJhbF9zdHJpbmcucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJykpO1xufTtcblxuLyogY3NzIGJlYXV0aWZpZXIgbGVnYWN5IGhlbHBlcnMgKi9cbklucHV0U2Nhbm5lci5wcm90b3R5cGUucGVla1VudGlsQWZ0ZXIgPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gIHZhciBzdGFydCA9IHRoaXMuX19wb3NpdGlvbjtcbiAgdmFyIHZhbCA9IHRoaXMucmVhZFVudGlsQWZ0ZXIocGF0dGVybik7XG4gIHRoaXMuX19wb3NpdGlvbiA9IHN0YXJ0O1xuICByZXR1cm4gdmFsO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5sb29rQmFjayA9IGZ1bmN0aW9uKHRlc3RWYWwpIHtcbiAgdmFyIHN0YXJ0ID0gdGhpcy5fX3Bvc2l0aW9uIC0gMTtcbiAgcmV0dXJuIHN0YXJ0ID49IHRlc3RWYWwubGVuZ3RoICYmIHRoaXMuX19pbnB1dC5zdWJzdHJpbmcoc3RhcnQgLSB0ZXN0VmFsLmxlbmd0aCwgc3RhcnQpXG4gICAgLnRvTG93ZXJDYXNlKCkgPT09IHRlc3RWYWw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5JbnB1dFNjYW5uZXIgPSBJbnB1dFNjYW5uZXI7XG5cblxuLyoqKi8gfSksXG4vKiA5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG52YXIgSW5wdXRTY2FubmVyID0gKF9fd2VicGFja19yZXF1aXJlX18oOCkuSW5wdXRTY2FubmVyKTtcbnZhciBUb2tlbiA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDMpLlRva2VuKTtcbnZhciBUb2tlblN0cmVhbSA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKS5Ub2tlblN0cmVhbSk7XG52YXIgV2hpdGVzcGFjZVBhdHRlcm4gPSAoX193ZWJwYWNrX3JlcXVpcmVfXygxMSkuV2hpdGVzcGFjZVBhdHRlcm4pO1xuXG52YXIgVE9LRU4gPSB7XG4gIFNUQVJUOiAnVEtfU1RBUlQnLFxuICBSQVc6ICdUS19SQVcnLFxuICBFT0Y6ICdUS19FT0YnXG59O1xuXG52YXIgVG9rZW5pemVyID0gZnVuY3Rpb24oaW5wdXRfc3RyaW5nLCBvcHRpb25zKSB7XG4gIHRoaXMuX2lucHV0ID0gbmV3IElucHV0U2Nhbm5lcihpbnB1dF9zdHJpbmcpO1xuICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5fX3Rva2VucyA9IG51bGw7XG5cbiAgdGhpcy5fcGF0dGVybnMgPSB7fTtcbiAgdGhpcy5fcGF0dGVybnMud2hpdGVzcGFjZSA9IG5ldyBXaGl0ZXNwYWNlUGF0dGVybih0aGlzLl9pbnB1dCk7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLnRva2VuaXplID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2lucHV0LnJlc3RhcnQoKTtcbiAgdGhpcy5fX3Rva2VucyA9IG5ldyBUb2tlblN0cmVhbSgpO1xuXG4gIHRoaXMuX3Jlc2V0KCk7XG5cbiAgdmFyIGN1cnJlbnQ7XG4gIHZhciBwcmV2aW91cyA9IG5ldyBUb2tlbihUT0tFTi5TVEFSVCwgJycpO1xuICB2YXIgb3Blbl90b2tlbiA9IG51bGw7XG4gIHZhciBvcGVuX3N0YWNrID0gW107XG4gIHZhciBjb21tZW50cyA9IG5ldyBUb2tlblN0cmVhbSgpO1xuXG4gIHdoaWxlIChwcmV2aW91cy50eXBlICE9PSBUT0tFTi5FT0YpIHtcbiAgICBjdXJyZW50ID0gdGhpcy5fZ2V0X25leHRfdG9rZW4ocHJldmlvdXMsIG9wZW5fdG9rZW4pO1xuICAgIHdoaWxlICh0aGlzLl9pc19jb21tZW50KGN1cnJlbnQpKSB7XG4gICAgICBjb21tZW50cy5hZGQoY3VycmVudCk7XG4gICAgICBjdXJyZW50ID0gdGhpcy5fZ2V0X25leHRfdG9rZW4ocHJldmlvdXMsIG9wZW5fdG9rZW4pO1xuICAgIH1cblxuICAgIGlmICghY29tbWVudHMuaXNFbXB0eSgpKSB7XG4gICAgICBjdXJyZW50LmNvbW1lbnRzX2JlZm9yZSA9IGNvbW1lbnRzO1xuICAgICAgY29tbWVudHMgPSBuZXcgVG9rZW5TdHJlYW0oKTtcbiAgICB9XG5cbiAgICBjdXJyZW50LnBhcmVudCA9IG9wZW5fdG9rZW47XG5cbiAgICBpZiAodGhpcy5faXNfb3BlbmluZyhjdXJyZW50KSkge1xuICAgICAgb3Blbl9zdGFjay5wdXNoKG9wZW5fdG9rZW4pO1xuICAgICAgb3Blbl90b2tlbiA9IGN1cnJlbnQ7XG4gICAgfSBlbHNlIGlmIChvcGVuX3Rva2VuICYmIHRoaXMuX2lzX2Nsb3NpbmcoY3VycmVudCwgb3Blbl90b2tlbikpIHtcbiAgICAgIGN1cnJlbnQub3BlbmVkID0gb3Blbl90b2tlbjtcbiAgICAgIG9wZW5fdG9rZW4uY2xvc2VkID0gY3VycmVudDtcbiAgICAgIG9wZW5fdG9rZW4gPSBvcGVuX3N0YWNrLnBvcCgpO1xuICAgICAgY3VycmVudC5wYXJlbnQgPSBvcGVuX3Rva2VuO1xuICAgIH1cblxuICAgIGN1cnJlbnQucHJldmlvdXMgPSBwcmV2aW91cztcbiAgICBwcmV2aW91cy5uZXh0ID0gY3VycmVudDtcblxuICAgIHRoaXMuX190b2tlbnMuYWRkKGN1cnJlbnQpO1xuICAgIHByZXZpb3VzID0gY3VycmVudDtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9fdG9rZW5zO1xufTtcblxuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9pc19maXJzdF90b2tlbiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fX3Rva2Vucy5pc0VtcHR5KCk7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZXNldCA9IGZ1bmN0aW9uKCkge307XG5cblRva2VuaXplci5wcm90b3R5cGUuX2dldF9uZXh0X3Rva2VuID0gZnVuY3Rpb24ocHJldmlvdXNfdG9rZW4sIG9wZW5fdG9rZW4pIHsgLy8ganNoaW50IHVudXNlZDpmYWxzZVxuICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuICB2YXIgcmVzdWx0aW5nX3N0cmluZyA9IHRoaXMuX2lucHV0LnJlYWQoLy4rL2cpO1xuICBpZiAocmVzdWx0aW5nX3N0cmluZykge1xuICAgIHJldHVybiB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uUkFXLCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLkVPRiwgJycpO1xuICB9XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9pc19jb21tZW50ID0gZnVuY3Rpb24oY3VycmVudF90b2tlbikgeyAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXG4gIHJldHVybiBmYWxzZTtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX2lzX29wZW5pbmcgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7IC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5faXNfY2xvc2luZyA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4sIG9wZW5fdG9rZW4pIHsgLy8ganNoaW50IHVudXNlZDpmYWxzZVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9jcmVhdGVfdG9rZW4gPSBmdW5jdGlvbih0eXBlLCB0ZXh0KSB7XG4gIHZhciB0b2tlbiA9IG5ldyBUb2tlbih0eXBlLCB0ZXh0LFxuICAgIHRoaXMuX3BhdHRlcm5zLndoaXRlc3BhY2UubmV3bGluZV9jb3VudCxcbiAgICB0aGlzLl9wYXR0ZXJucy53aGl0ZXNwYWNlLndoaXRlc3BhY2VfYmVmb3JlX3Rva2VuKTtcbiAgcmV0dXJuIHRva2VuO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fcmVhZFdoaXRlc3BhY2UgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3BhdHRlcm5zLndoaXRlc3BhY2UucmVhZCgpO1xufTtcblxuXG5cbm1vZHVsZS5leHBvcnRzLlRva2VuaXplciA9IFRva2VuaXplcjtcbm1vZHVsZS5leHBvcnRzLlRPS0VOID0gVE9LRU47XG5cblxuLyoqKi8gfSksXG4vKiAxMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbmZ1bmN0aW9uIFRva2VuU3RyZWFtKHBhcmVudF90b2tlbikge1xuICAvLyBwcml2YXRlXG4gIHRoaXMuX190b2tlbnMgPSBbXTtcbiAgdGhpcy5fX3Rva2Vuc19sZW5ndGggPSB0aGlzLl9fdG9rZW5zLmxlbmd0aDtcbiAgdGhpcy5fX3Bvc2l0aW9uID0gMDtcbiAgdGhpcy5fX3BhcmVudF90b2tlbiA9IHBhcmVudF90b2tlbjtcbn1cblxuVG9rZW5TdHJlYW0ucHJvdG90eXBlLnJlc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fX3Bvc2l0aW9uID0gMDtcbn07XG5cblRva2VuU3RyZWFtLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9fdG9rZW5zX2xlbmd0aCA9PT0gMDtcbn07XG5cblRva2VuU3RyZWFtLnByb3RvdHlwZS5oYXNOZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9fcG9zaXRpb24gPCB0aGlzLl9fdG9rZW5zX2xlbmd0aDtcbn07XG5cblRva2VuU3RyZWFtLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciB2YWwgPSBudWxsO1xuICBpZiAodGhpcy5oYXNOZXh0KCkpIHtcbiAgICB2YWwgPSB0aGlzLl9fdG9rZW5zW3RoaXMuX19wb3NpdGlvbl07XG4gICAgdGhpcy5fX3Bvc2l0aW9uICs9IDE7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn07XG5cblRva2VuU3RyZWFtLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgdmFyIHZhbCA9IG51bGw7XG4gIGluZGV4ID0gaW5kZXggfHwgMDtcbiAgaW5kZXggKz0gdGhpcy5fX3Bvc2l0aW9uO1xuICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMuX190b2tlbnNfbGVuZ3RoKSB7XG4gICAgdmFsID0gdGhpcy5fX3Rva2Vuc1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn07XG5cblRva2VuU3RyZWFtLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbih0b2tlbikge1xuICBpZiAodGhpcy5fX3BhcmVudF90b2tlbikge1xuICAgIHRva2VuLnBhcmVudCA9IHRoaXMuX19wYXJlbnRfdG9rZW47XG4gIH1cbiAgdGhpcy5fX3Rva2Vucy5wdXNoKHRva2VuKTtcbiAgdGhpcy5fX3Rva2Vuc19sZW5ndGggKz0gMTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLlRva2VuU3RyZWFtID0gVG9rZW5TdHJlYW07XG5cblxuLyoqKi8gfSksXG4vKiAxMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxudmFyIFBhdHRlcm4gPSAoX193ZWJwYWNrX3JlcXVpcmVfXygxMikuUGF0dGVybik7XG5cbmZ1bmN0aW9uIFdoaXRlc3BhY2VQYXR0ZXJuKGlucHV0X3NjYW5uZXIsIHBhcmVudCkge1xuICBQYXR0ZXJuLmNhbGwodGhpcywgaW5wdXRfc2Nhbm5lciwgcGFyZW50KTtcbiAgaWYgKHBhcmVudCkge1xuICAgIHRoaXMuX2xpbmVfcmVnZXhwID0gdGhpcy5faW5wdXQuZ2V0X3JlZ2V4cChwYXJlbnQuX2xpbmVfcmVnZXhwKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9fc2V0X3doaXRlc3BhY2VfcGF0dGVybnMoJycsICcnKTtcbiAgfVxuXG4gIHRoaXMubmV3bGluZV9jb3VudCA9IDA7XG4gIHRoaXMud2hpdGVzcGFjZV9iZWZvcmVfdG9rZW4gPSAnJztcbn1cbldoaXRlc3BhY2VQYXR0ZXJuLnByb3RvdHlwZSA9IG5ldyBQYXR0ZXJuKCk7XG5cbldoaXRlc3BhY2VQYXR0ZXJuLnByb3RvdHlwZS5fX3NldF93aGl0ZXNwYWNlX3BhdHRlcm5zID0gZnVuY3Rpb24od2hpdGVzcGFjZV9jaGFycywgbmV3bGluZV9jaGFycykge1xuICB3aGl0ZXNwYWNlX2NoYXJzICs9ICdcXFxcdCAnO1xuICBuZXdsaW5lX2NoYXJzICs9ICdcXFxcblxcXFxyJztcblxuICB0aGlzLl9tYXRjaF9wYXR0ZXJuID0gdGhpcy5faW5wdXQuZ2V0X3JlZ2V4cChcbiAgICAnWycgKyB3aGl0ZXNwYWNlX2NoYXJzICsgbmV3bGluZV9jaGFycyArICddKycsIHRydWUpO1xuICB0aGlzLl9uZXdsaW5lX3JlZ2V4cCA9IHRoaXMuX2lucHV0LmdldF9yZWdleHAoXG4gICAgJ1xcXFxyXFxcXG58WycgKyBuZXdsaW5lX2NoYXJzICsgJ10nKTtcbn07XG5cbldoaXRlc3BhY2VQYXR0ZXJuLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMubmV3bGluZV9jb3VudCA9IDA7XG4gIHRoaXMud2hpdGVzcGFjZV9iZWZvcmVfdG9rZW4gPSAnJztcblxuICB2YXIgcmVzdWx0aW5nX3N0cmluZyA9IHRoaXMuX2lucHV0LnJlYWQodGhpcy5fbWF0Y2hfcGF0dGVybik7XG4gIGlmIChyZXN1bHRpbmdfc3RyaW5nID09PSAnICcpIHtcbiAgICB0aGlzLndoaXRlc3BhY2VfYmVmb3JlX3Rva2VuID0gJyAnO1xuICB9IGVsc2UgaWYgKHJlc3VsdGluZ19zdHJpbmcpIHtcbiAgICB2YXIgbWF0Y2hlcyA9IHRoaXMuX19zcGxpdCh0aGlzLl9uZXdsaW5lX3JlZ2V4cCwgcmVzdWx0aW5nX3N0cmluZyk7XG4gICAgdGhpcy5uZXdsaW5lX2NvdW50ID0gbWF0Y2hlcy5sZW5ndGggLSAxO1xuICAgIHRoaXMud2hpdGVzcGFjZV9iZWZvcmVfdG9rZW4gPSBtYXRjaGVzW3RoaXMubmV3bGluZV9jb3VudF07XG4gIH1cblxuICByZXR1cm4gcmVzdWx0aW5nX3N0cmluZztcbn07XG5cbldoaXRlc3BhY2VQYXR0ZXJuLnByb3RvdHlwZS5tYXRjaGluZyA9IGZ1bmN0aW9uKHdoaXRlc3BhY2VfY2hhcnMsIG5ld2xpbmVfY2hhcnMpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuX2NyZWF0ZSgpO1xuICByZXN1bHQuX19zZXRfd2hpdGVzcGFjZV9wYXR0ZXJucyh3aGl0ZXNwYWNlX2NoYXJzLCBuZXdsaW5lX2NoYXJzKTtcbiAgcmVzdWx0Ll91cGRhdGUoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbldoaXRlc3BhY2VQYXR0ZXJuLnByb3RvdHlwZS5fY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgV2hpdGVzcGFjZVBhdHRlcm4odGhpcy5faW5wdXQsIHRoaXMpO1xufTtcblxuV2hpdGVzcGFjZVBhdHRlcm4ucHJvdG90eXBlLl9fc3BsaXQgPSBmdW5jdGlvbihyZWdleHAsIGlucHV0X3N0cmluZykge1xuICByZWdleHAubGFzdEluZGV4ID0gMDtcbiAgdmFyIHN0YXJ0X2luZGV4ID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgbmV4dF9tYXRjaCA9IHJlZ2V4cC5leGVjKGlucHV0X3N0cmluZyk7XG4gIHdoaWxlIChuZXh0X21hdGNoKSB7XG4gICAgcmVzdWx0LnB1c2goaW5wdXRfc3RyaW5nLnN1YnN0cmluZyhzdGFydF9pbmRleCwgbmV4dF9tYXRjaC5pbmRleCkpO1xuICAgIHN0YXJ0X2luZGV4ID0gbmV4dF9tYXRjaC5pbmRleCArIG5leHRfbWF0Y2hbMF0ubGVuZ3RoO1xuICAgIG5leHRfbWF0Y2ggPSByZWdleHAuZXhlYyhpbnB1dF9zdHJpbmcpO1xuICB9XG5cbiAgaWYgKHN0YXJ0X2luZGV4IDwgaW5wdXRfc3RyaW5nLmxlbmd0aCkge1xuICAgIHJlc3VsdC5wdXNoKGlucHV0X3N0cmluZy5zdWJzdHJpbmcoc3RhcnRfaW5kZXgsIGlucHV0X3N0cmluZy5sZW5ndGgpKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQucHVzaCgnJyk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbm1vZHVsZS5leHBvcnRzLldoaXRlc3BhY2VQYXR0ZXJuID0gV2hpdGVzcGFjZVBhdHRlcm47XG5cblxuLyoqKi8gfSksXG4vKiAxMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbmZ1bmN0aW9uIFBhdHRlcm4oaW5wdXRfc2Nhbm5lciwgcGFyZW50KSB7XG4gIHRoaXMuX2lucHV0ID0gaW5wdXRfc2Nhbm5lcjtcbiAgdGhpcy5fc3RhcnRpbmdfcGF0dGVybiA9IG51bGw7XG4gIHRoaXMuX21hdGNoX3BhdHRlcm4gPSBudWxsO1xuICB0aGlzLl91bnRpbF9wYXR0ZXJuID0gbnVsbDtcbiAgdGhpcy5fdW50aWxfYWZ0ZXIgPSBmYWxzZTtcblxuICBpZiAocGFyZW50KSB7XG4gICAgdGhpcy5fc3RhcnRpbmdfcGF0dGVybiA9IHRoaXMuX2lucHV0LmdldF9yZWdleHAocGFyZW50Ll9zdGFydGluZ19wYXR0ZXJuLCB0cnVlKTtcbiAgICB0aGlzLl9tYXRjaF9wYXR0ZXJuID0gdGhpcy5faW5wdXQuZ2V0X3JlZ2V4cChwYXJlbnQuX21hdGNoX3BhdHRlcm4sIHRydWUpO1xuICAgIHRoaXMuX3VudGlsX3BhdHRlcm4gPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKHBhcmVudC5fdW50aWxfcGF0dGVybik7XG4gICAgdGhpcy5fdW50aWxfYWZ0ZXIgPSBwYXJlbnQuX3VudGlsX2FmdGVyO1xuICB9XG59XG5cblBhdHRlcm4ucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuX2lucHV0LnJlYWQodGhpcy5fc3RhcnRpbmdfcGF0dGVybik7XG4gIGlmICghdGhpcy5fc3RhcnRpbmdfcGF0dGVybiB8fCByZXN1bHQpIHtcbiAgICByZXN1bHQgKz0gdGhpcy5faW5wdXQucmVhZCh0aGlzLl9tYXRjaF9wYXR0ZXJuLCB0aGlzLl91bnRpbF9wYXR0ZXJuLCB0aGlzLl91bnRpbF9hZnRlcik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblBhdHRlcm4ucHJvdG90eXBlLnJlYWRfbWF0Y2ggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2lucHV0Lm1hdGNoKHRoaXMuX21hdGNoX3BhdHRlcm4pO1xufTtcblxuUGF0dGVybi5wcm90b3R5cGUudW50aWxfYWZ0ZXIgPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9jcmVhdGUoKTtcbiAgcmVzdWx0Ll91bnRpbF9hZnRlciA9IHRydWU7XG4gIHJlc3VsdC5fdW50aWxfcGF0dGVybiA9IHRoaXMuX2lucHV0LmdldF9yZWdleHAocGF0dGVybik7XG4gIHJlc3VsdC5fdXBkYXRlKCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5QYXR0ZXJuLnByb3RvdHlwZS51bnRpbCA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuX2NyZWF0ZSgpO1xuICByZXN1bHQuX3VudGlsX2FmdGVyID0gZmFsc2U7XG4gIHJlc3VsdC5fdW50aWxfcGF0dGVybiA9IHRoaXMuX2lucHV0LmdldF9yZWdleHAocGF0dGVybik7XG4gIHJlc3VsdC5fdXBkYXRlKCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5QYXR0ZXJuLnByb3RvdHlwZS5zdGFydGluZ193aXRoID0gZnVuY3Rpb24ocGF0dGVybikge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fY3JlYXRlKCk7XG4gIHJlc3VsdC5fc3RhcnRpbmdfcGF0dGVybiA9IHRoaXMuX2lucHV0LmdldF9yZWdleHAocGF0dGVybiwgdHJ1ZSk7XG4gIHJlc3VsdC5fdXBkYXRlKCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5QYXR0ZXJuLnByb3RvdHlwZS5tYXRjaGluZyA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuX2NyZWF0ZSgpO1xuICByZXN1bHQuX21hdGNoX3BhdHRlcm4gPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKHBhdHRlcm4sIHRydWUpO1xuICByZXN1bHQuX3VwZGF0ZSgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuUGF0dGVybi5wcm90b3R5cGUuX2NyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFBhdHRlcm4odGhpcy5faW5wdXQsIHRoaXMpO1xufTtcblxuUGF0dGVybi5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uKCkge307XG5cbm1vZHVsZS5leHBvcnRzLlBhdHRlcm4gPSBQYXR0ZXJuO1xuXG5cbi8qKiovIH0pLFxuLyogMTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG5mdW5jdGlvbiBEaXJlY3RpdmVzKHN0YXJ0X2Jsb2NrX3BhdHRlcm4sIGVuZF9ibG9ja19wYXR0ZXJuKSB7XG4gIHN0YXJ0X2Jsb2NrX3BhdHRlcm4gPSB0eXBlb2Ygc3RhcnRfYmxvY2tfcGF0dGVybiA9PT0gJ3N0cmluZycgPyBzdGFydF9ibG9ja19wYXR0ZXJuIDogc3RhcnRfYmxvY2tfcGF0dGVybi5zb3VyY2U7XG4gIGVuZF9ibG9ja19wYXR0ZXJuID0gdHlwZW9mIGVuZF9ibG9ja19wYXR0ZXJuID09PSAnc3RyaW5nJyA/IGVuZF9ibG9ja19wYXR0ZXJuIDogZW5kX2Jsb2NrX3BhdHRlcm4uc291cmNlO1xuICB0aGlzLl9fZGlyZWN0aXZlc19ibG9ja19wYXR0ZXJuID0gbmV3IFJlZ0V4cChzdGFydF9ibG9ja19wYXR0ZXJuICsgLyBiZWF1dGlmeSggXFx3K1s6XVxcdyspKyAvLnNvdXJjZSArIGVuZF9ibG9ja19wYXR0ZXJuLCAnZycpO1xuICB0aGlzLl9fZGlyZWN0aXZlX3BhdHRlcm4gPSAvIChcXHcrKVs6XShcXHcrKS9nO1xuXG4gIHRoaXMuX19kaXJlY3RpdmVzX2VuZF9pZ25vcmVfcGF0dGVybiA9IG5ldyBSZWdFeHAoc3RhcnRfYmxvY2tfcGF0dGVybiArIC9cXHNiZWF1dGlmeVxcc2lnbm9yZTplbmRcXHMvLnNvdXJjZSArIGVuZF9ibG9ja19wYXR0ZXJuLCAnZycpO1xufVxuXG5EaXJlY3RpdmVzLnByb3RvdHlwZS5nZXRfZGlyZWN0aXZlcyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgaWYgKCF0ZXh0Lm1hdGNoKHRoaXMuX19kaXJlY3RpdmVzX2Jsb2NrX3BhdHRlcm4pKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZGlyZWN0aXZlcyA9IHt9O1xuICB0aGlzLl9fZGlyZWN0aXZlX3BhdHRlcm4ubGFzdEluZGV4ID0gMDtcbiAgdmFyIGRpcmVjdGl2ZV9tYXRjaCA9IHRoaXMuX19kaXJlY3RpdmVfcGF0dGVybi5leGVjKHRleHQpO1xuXG4gIHdoaWxlIChkaXJlY3RpdmVfbWF0Y2gpIHtcbiAgICBkaXJlY3RpdmVzW2RpcmVjdGl2ZV9tYXRjaFsxXV0gPSBkaXJlY3RpdmVfbWF0Y2hbMl07XG4gICAgZGlyZWN0aXZlX21hdGNoID0gdGhpcy5fX2RpcmVjdGl2ZV9wYXR0ZXJuLmV4ZWModGV4dCk7XG4gIH1cblxuICByZXR1cm4gZGlyZWN0aXZlcztcbn07XG5cbkRpcmVjdGl2ZXMucHJvdG90eXBlLnJlYWRJZ25vcmVkID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgcmV0dXJuIGlucHV0LnJlYWRVbnRpbEFmdGVyKHRoaXMuX19kaXJlY3RpdmVzX2VuZF9pZ25vcmVfcGF0dGVybik7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzLkRpcmVjdGl2ZXMgPSBEaXJlY3RpdmVzO1xuXG5cbi8qKiovIH0pLFxuLyogMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbnZhciBQYXR0ZXJuID0gKF9fd2VicGFja19yZXF1aXJlX18oMTIpLlBhdHRlcm4pO1xuXG5cbnZhciB0ZW1wbGF0ZV9uYW1lcyA9IHtcbiAgZGphbmdvOiBmYWxzZSxcbiAgZXJiOiBmYWxzZSxcbiAgaGFuZGxlYmFyczogZmFsc2UsXG4gIHBocDogZmFsc2UsXG4gIHNtYXJ0eTogZmFsc2UsXG4gIGFuZ3VsYXI6IGZhbHNlXG59O1xuXG4vLyBUaGlzIGxldHMgdGVtcGxhdGVzIGFwcGVhciBhbnl3aGVyZSB3ZSB3b3VsZCBkbyBhIHJlYWRVbnRpbFxuLy8gVGhlIGNvc3QgaXMgaGlnaGVyIGJ1dCBpdCBpcyBwYXkgdG8gcGxheS5cbmZ1bmN0aW9uIFRlbXBsYXRhYmxlUGF0dGVybihpbnB1dF9zY2FubmVyLCBwYXJlbnQpIHtcbiAgUGF0dGVybi5jYWxsKHRoaXMsIGlucHV0X3NjYW5uZXIsIHBhcmVudCk7XG4gIHRoaXMuX190ZW1wbGF0ZV9wYXR0ZXJuID0gbnVsbDtcbiAgdGhpcy5fZGlzYWJsZWQgPSBPYmplY3QuYXNzaWduKHt9LCB0ZW1wbGF0ZV9uYW1lcyk7XG4gIHRoaXMuX2V4Y2x1ZGVkID0gT2JqZWN0LmFzc2lnbih7fSwgdGVtcGxhdGVfbmFtZXMpO1xuXG4gIGlmIChwYXJlbnQpIHtcbiAgICB0aGlzLl9fdGVtcGxhdGVfcGF0dGVybiA9IHRoaXMuX2lucHV0LmdldF9yZWdleHAocGFyZW50Ll9fdGVtcGxhdGVfcGF0dGVybik7XG4gICAgdGhpcy5fZXhjbHVkZWQgPSBPYmplY3QuYXNzaWduKHRoaXMuX2V4Y2x1ZGVkLCBwYXJlbnQuX2V4Y2x1ZGVkKTtcbiAgICB0aGlzLl9kaXNhYmxlZCA9IE9iamVjdC5hc3NpZ24odGhpcy5fZGlzYWJsZWQsIHBhcmVudC5fZGlzYWJsZWQpO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gbmV3IFBhdHRlcm4oaW5wdXRfc2Nhbm5lcik7XG4gIHRoaXMuX19wYXR0ZXJucyA9IHtcbiAgICBoYW5kbGViYXJzX2NvbW1lbnQ6IHBhdHRlcm4uc3RhcnRpbmdfd2l0aCgve3shLS0vKS51bnRpbF9hZnRlcigvLS19fS8pLFxuICAgIGhhbmRsZWJhcnNfdW5lc2NhcGVkOiBwYXR0ZXJuLnN0YXJ0aW5nX3dpdGgoL3t7ey8pLnVudGlsX2FmdGVyKC99fX0vKSxcbiAgICBoYW5kbGViYXJzOiBwYXR0ZXJuLnN0YXJ0aW5nX3dpdGgoL3t7LykudW50aWxfYWZ0ZXIoL319LyksXG4gICAgcGhwOiBwYXR0ZXJuLnN0YXJ0aW5nX3dpdGgoLzxcXD8oPzpbPSBdfHBocCkvKS51bnRpbF9hZnRlcigvXFw/Pi8pLFxuICAgIGVyYjogcGF0dGVybi5zdGFydGluZ193aXRoKC88JVteJV0vKS51bnRpbF9hZnRlcigvW14lXSU+LyksXG4gICAgLy8gZGphbmdvIGNvZmxpY3RzIHdpdGggaGFuZGxlYmFycyBhIGJpdC5cbiAgICBkamFuZ286IHBhdHRlcm4uc3RhcnRpbmdfd2l0aCgveyUvKS51bnRpbF9hZnRlcigvJX0vKSxcbiAgICBkamFuZ29fdmFsdWU6IHBhdHRlcm4uc3RhcnRpbmdfd2l0aCgve3svKS51bnRpbF9hZnRlcigvfX0vKSxcbiAgICBkamFuZ29fY29tbWVudDogcGF0dGVybi5zdGFydGluZ193aXRoKC97Iy8pLnVudGlsX2FmdGVyKC8jfS8pLFxuICAgIHNtYXJ0eTogcGF0dGVybi5zdGFydGluZ193aXRoKC97KD89W159e1xcc1xcbl0pLykudW50aWxfYWZ0ZXIoL1teXFxzXFxuXX0vKSxcbiAgICBzbWFydHlfY29tbWVudDogcGF0dGVybi5zdGFydGluZ193aXRoKC97XFwqLykudW50aWxfYWZ0ZXIoL1xcKn0vKSxcbiAgICBzbWFydHlfbGl0ZXJhbDogcGF0dGVybi5zdGFydGluZ193aXRoKC97bGl0ZXJhbH0vKS51bnRpbF9hZnRlcigve1xcL2xpdGVyYWx9LylcbiAgfTtcbn1cblRlbXBsYXRhYmxlUGF0dGVybi5wcm90b3R5cGUgPSBuZXcgUGF0dGVybigpO1xuXG5UZW1wbGF0YWJsZVBhdHRlcm4ucHJvdG90eXBlLl9jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUZW1wbGF0YWJsZVBhdHRlcm4odGhpcy5faW5wdXQsIHRoaXMpO1xufTtcblxuVGVtcGxhdGFibGVQYXR0ZXJuLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX19zZXRfdGVtcGxhdGVkX3BhdHRlcm4oKTtcbn07XG5cblRlbXBsYXRhYmxlUGF0dGVybi5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uKGxhbmd1YWdlKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9jcmVhdGUoKTtcbiAgcmVzdWx0Ll9kaXNhYmxlZFtsYW5ndWFnZV0gPSB0cnVlO1xuICByZXN1bHQuX3VwZGF0ZSgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVGVtcGxhdGFibGVQYXR0ZXJuLnByb3RvdHlwZS5yZWFkX29wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9jcmVhdGUoKTtcbiAgZm9yICh2YXIgbGFuZ3VhZ2UgaW4gdGVtcGxhdGVfbmFtZXMpIHtcbiAgICByZXN1bHQuX2Rpc2FibGVkW2xhbmd1YWdlXSA9IG9wdGlvbnMudGVtcGxhdGluZy5pbmRleE9mKGxhbmd1YWdlKSA9PT0gLTE7XG4gIH1cbiAgcmVzdWx0Ll91cGRhdGUoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblRlbXBsYXRhYmxlUGF0dGVybi5wcm90b3R5cGUuZXhjbHVkZSA9IGZ1bmN0aW9uKGxhbmd1YWdlKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9jcmVhdGUoKTtcbiAgcmVzdWx0Ll9leGNsdWRlZFtsYW5ndWFnZV0gPSB0cnVlO1xuICByZXN1bHQuX3VwZGF0ZSgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVGVtcGxhdGFibGVQYXR0ZXJuLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgaWYgKHRoaXMuX21hdGNoX3BhdHRlcm4pIHtcbiAgICByZXN1bHQgPSB0aGlzLl9pbnB1dC5yZWFkKHRoaXMuX3N0YXJ0aW5nX3BhdHRlcm4pO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IHRoaXMuX2lucHV0LnJlYWQodGhpcy5fc3RhcnRpbmdfcGF0dGVybiwgdGhpcy5fX3RlbXBsYXRlX3BhdHRlcm4pO1xuICB9XG4gIHZhciBuZXh0ID0gdGhpcy5fcmVhZF90ZW1wbGF0ZSgpO1xuICB3aGlsZSAobmV4dCkge1xuICAgIGlmICh0aGlzLl9tYXRjaF9wYXR0ZXJuKSB7XG4gICAgICBuZXh0ICs9IHRoaXMuX2lucHV0LnJlYWQodGhpcy5fbWF0Y2hfcGF0dGVybik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHQgKz0gdGhpcy5faW5wdXQucmVhZFVudGlsKHRoaXMuX190ZW1wbGF0ZV9wYXR0ZXJuKTtcbiAgICB9XG4gICAgcmVzdWx0ICs9IG5leHQ7XG4gICAgbmV4dCA9IHRoaXMuX3JlYWRfdGVtcGxhdGUoKTtcbiAgfVxuXG4gIGlmICh0aGlzLl91bnRpbF9hZnRlcikge1xuICAgIHJlc3VsdCArPSB0aGlzLl9pbnB1dC5yZWFkVW50aWxBZnRlcih0aGlzLl91bnRpbF9wYXR0ZXJuKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVGVtcGxhdGFibGVQYXR0ZXJuLnByb3RvdHlwZS5fX3NldF90ZW1wbGF0ZWRfcGF0dGVybiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaXRlbXMgPSBbXTtcblxuICBpZiAoIXRoaXMuX2Rpc2FibGVkLnBocCkge1xuICAgIGl0ZW1zLnB1c2godGhpcy5fX3BhdHRlcm5zLnBocC5fc3RhcnRpbmdfcGF0dGVybi5zb3VyY2UpO1xuICB9XG4gIGlmICghdGhpcy5fZGlzYWJsZWQuaGFuZGxlYmFycykge1xuICAgIGl0ZW1zLnB1c2godGhpcy5fX3BhdHRlcm5zLmhhbmRsZWJhcnMuX3N0YXJ0aW5nX3BhdHRlcm4uc291cmNlKTtcbiAgfVxuICBpZiAoIXRoaXMuX2Rpc2FibGVkLmVyYikge1xuICAgIGl0ZW1zLnB1c2godGhpcy5fX3BhdHRlcm5zLmVyYi5fc3RhcnRpbmdfcGF0dGVybi5zb3VyY2UpO1xuICB9XG4gIGlmICghdGhpcy5fZGlzYWJsZWQuZGphbmdvKSB7XG4gICAgaXRlbXMucHVzaCh0aGlzLl9fcGF0dGVybnMuZGphbmdvLl9zdGFydGluZ19wYXR0ZXJuLnNvdXJjZSk7XG4gICAgLy8gVGhlIHN0YXJ0aW5nIHBhdHRlcm4gZm9yIGRqYW5nbyBpcyBtb3JlIGNvbXBsZXggYmVjYXVzZSBpdCBoYXMgZGlmZmVyZW50XG4gICAgLy8gcGF0dGVybnMgZm9yIHZhbHVlLCBjb21tZW50LCBhbmQgb3RoZXIgc2VjdGlvbnNcbiAgICBpdGVtcy5wdXNoKHRoaXMuX19wYXR0ZXJucy5kamFuZ29fdmFsdWUuX3N0YXJ0aW5nX3BhdHRlcm4uc291cmNlKTtcbiAgICBpdGVtcy5wdXNoKHRoaXMuX19wYXR0ZXJucy5kamFuZ29fY29tbWVudC5fc3RhcnRpbmdfcGF0dGVybi5zb3VyY2UpO1xuICB9XG4gIGlmICghdGhpcy5fZGlzYWJsZWQuc21hcnR5KSB7XG4gICAgaXRlbXMucHVzaCh0aGlzLl9fcGF0dGVybnMuc21hcnR5Ll9zdGFydGluZ19wYXR0ZXJuLnNvdXJjZSk7XG4gIH1cblxuICBpZiAodGhpcy5fdW50aWxfcGF0dGVybikge1xuICAgIGl0ZW1zLnB1c2godGhpcy5fdW50aWxfcGF0dGVybi5zb3VyY2UpO1xuICB9XG4gIHRoaXMuX190ZW1wbGF0ZV9wYXR0ZXJuID0gdGhpcy5faW5wdXQuZ2V0X3JlZ2V4cCgnKD86JyArIGl0ZW1zLmpvaW4oJ3wnKSArICcpJyk7XG59O1xuXG5UZW1wbGF0YWJsZVBhdHRlcm4ucHJvdG90eXBlLl9yZWFkX3RlbXBsYXRlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXN1bHRpbmdfc3RyaW5nID0gJyc7XG4gIHZhciBjID0gdGhpcy5faW5wdXQucGVlaygpO1xuICBpZiAoYyA9PT0gJzwnKSB7XG4gICAgdmFyIHBlZWsxID0gdGhpcy5faW5wdXQucGVlaygxKTtcbiAgICAvL2lmIHdlJ3JlIGluIGEgY29tbWVudCwgZG8gc29tZXRoaW5nIHNwZWNpYWxcbiAgICAvLyBXZSB0cmVhdCBhbGwgY29tbWVudHMgYXMgbGl0ZXJhbHMsIGV2ZW4gbW9yZSB0aGFuIHByZWZvcm1hdHRlZCB0YWdzXG4gICAgLy8gd2UganVzdCBsb29rIGZvciB0aGUgYXBwcm9wcmlhdGUgY2xvc2UgdGFnXG4gICAgaWYgKCF0aGlzLl9kaXNhYmxlZC5waHAgJiYgIXRoaXMuX2V4Y2x1ZGVkLnBocCAmJiBwZWVrMSA9PT0gJz8nKSB7XG4gICAgICByZXN1bHRpbmdfc3RyaW5nID0gcmVzdWx0aW5nX3N0cmluZyB8fFxuICAgICAgICB0aGlzLl9fcGF0dGVybnMucGhwLnJlYWQoKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9kaXNhYmxlZC5lcmIgJiYgIXRoaXMuX2V4Y2x1ZGVkLmVyYiAmJiBwZWVrMSA9PT0gJyUnKSB7XG4gICAgICByZXN1bHRpbmdfc3RyaW5nID0gcmVzdWx0aW5nX3N0cmluZyB8fFxuICAgICAgICB0aGlzLl9fcGF0dGVybnMuZXJiLnJlYWQoKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYyA9PT0gJ3snKSB7XG4gICAgaWYgKCF0aGlzLl9kaXNhYmxlZC5oYW5kbGViYXJzICYmICF0aGlzLl9leGNsdWRlZC5oYW5kbGViYXJzKSB7XG4gICAgICByZXN1bHRpbmdfc3RyaW5nID0gcmVzdWx0aW5nX3N0cmluZyB8fFxuICAgICAgICB0aGlzLl9fcGF0dGVybnMuaGFuZGxlYmFyc19jb21tZW50LnJlYWQoKTtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSByZXN1bHRpbmdfc3RyaW5nIHx8XG4gICAgICAgIHRoaXMuX19wYXR0ZXJucy5oYW5kbGViYXJzX3VuZXNjYXBlZC5yZWFkKCk7XG4gICAgICByZXN1bHRpbmdfc3RyaW5nID0gcmVzdWx0aW5nX3N0cmluZyB8fFxuICAgICAgICB0aGlzLl9fcGF0dGVybnMuaGFuZGxlYmFycy5yZWFkKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5fZGlzYWJsZWQuZGphbmdvKSB7XG4gICAgICAvLyBkamFuZ28gY29mbGljdHMgd2l0aCBoYW5kbGViYXJzIGEgYml0LlxuICAgICAgaWYgKCF0aGlzLl9leGNsdWRlZC5kamFuZ28gJiYgIXRoaXMuX2V4Y2x1ZGVkLmhhbmRsZWJhcnMpIHtcbiAgICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHJlc3VsdGluZ19zdHJpbmcgfHxcbiAgICAgICAgICB0aGlzLl9fcGF0dGVybnMuZGphbmdvX3ZhbHVlLnJlYWQoKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5fZXhjbHVkZWQuZGphbmdvKSB7XG4gICAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSByZXN1bHRpbmdfc3RyaW5nIHx8XG4gICAgICAgICAgdGhpcy5fX3BhdHRlcm5zLmRqYW5nb19jb21tZW50LnJlYWQoKTtcbiAgICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHJlc3VsdGluZ19zdHJpbmcgfHxcbiAgICAgICAgICB0aGlzLl9fcGF0dGVybnMuZGphbmdvLnJlYWQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLl9kaXNhYmxlZC5zbWFydHkpIHtcbiAgICAgIC8vIHNtYXJ0eSBjYW5ub3QgYmUgZW5hYmxlZCB3aXRoIGRqYW5nbyBvciBoYW5kbGViYXJzIGVuYWJsZWRcbiAgICAgIGlmICh0aGlzLl9kaXNhYmxlZC5kamFuZ28gJiYgdGhpcy5fZGlzYWJsZWQuaGFuZGxlYmFycykge1xuICAgICAgICByZXN1bHRpbmdfc3RyaW5nID0gcmVzdWx0aW5nX3N0cmluZyB8fFxuICAgICAgICAgIHRoaXMuX19wYXR0ZXJucy5zbWFydHlfY29tbWVudC5yZWFkKCk7XG4gICAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSByZXN1bHRpbmdfc3RyaW5nIHx8XG4gICAgICAgICAgdGhpcy5fX3BhdHRlcm5zLnNtYXJ0eV9saXRlcmFsLnJlYWQoKTtcbiAgICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHJlc3VsdGluZ19zdHJpbmcgfHxcbiAgICAgICAgICB0aGlzLl9fcGF0dGVybnMuc21hcnR5LnJlYWQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdGluZ19zdHJpbmc7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzLlRlbXBsYXRhYmxlUGF0dGVybiA9IFRlbXBsYXRhYmxlUGF0dGVybjtcblxuXG4vKioqLyB9KVxuLyoqKioqKi8gXHRdKTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRcdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIHN0YXJ0dXBcbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdC8vIFRoaXMgZW50cnkgbW9kdWxlIGlzIHJlZmVyZW5jZWQgYnkgb3RoZXIgbW9kdWxlcyBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qKioqKiovIFx0bGVnYWN5X2JlYXV0aWZ5X2pzID0gX193ZWJwYWNrX2V4cG9ydHNfXztcbi8qKioqKiovIFx0XG4vKioqKioqLyB9KSgpXG47XG52YXIganNfYmVhdXRpZnkgPSBsZWdhY3lfYmVhdXRpZnlfanM7XG4vKiBGb290ZXIgKi9cbmlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEFkZCBzdXBwb3J0IGZvciBBTUQgKCBodHRwczovL2dpdGh1Yi5jb20vYW1kanMvYW1kanMtYXBpL3dpa2kvQU1EI2RlZmluZWFtZC1wcm9wZXJ0eS0gKVxuICAgIGRlZmluZShbXSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7IGpzX2JlYXV0aWZ5OiBqc19iZWF1dGlmeSB9O1xuICAgIH0pO1xufSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8vIEFkZCBzdXBwb3J0IGZvciBDb21tb25KUy4gSnVzdCBwdXQgdGhpcyBmaWxlIHNvbWV3aGVyZSBvbiB5b3VyIHJlcXVpcmUucGF0aHNcbiAgICAvLyBhbmQgeW91IHdpbGwgYmUgYWJsZSB0byBgdmFyIGpzX2JlYXV0aWZ5ID0gcmVxdWlyZShcImJlYXV0aWZ5XCIpLmpzX2JlYXV0aWZ5YC5cbiAgICBleHBvcnRzLmpzX2JlYXV0aWZ5ID0ganNfYmVhdXRpZnk7XG59IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAvLyBJZiB3ZSdyZSBydW5uaW5nIGEgd2ViIHBhZ2UgYW5kIGRvbid0IGhhdmUgZWl0aGVyIG9mIHRoZSBhYm92ZSwgYWRkIG91ciBvbmUgZ2xvYmFsXG4gICAgd2luZG93LmpzX2JlYXV0aWZ5ID0ganNfYmVhdXRpZnk7XG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAvLyBJZiB3ZSBkb24ndCBldmVuIGhhdmUgd2luZG93LCB0cnkgZ2xvYmFsLlxuICAgIGdsb2JhbC5qc19iZWF1dGlmeSA9IGpzX2JlYXV0aWZ5O1xufVxuXG59KCkpO1xuXG4iXSwibmFtZXMiOlsibGVnYWN5X2JlYXV0aWZ5X2pzIiwiX193ZWJwYWNrX21vZHVsZXNfXyIsIm1vZHVsZSIsIl9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cyIsIl9fd2VicGFja19yZXF1aXJlX18iLCJCZWF1dGlmaWVyIiwiT3B0aW9ucyIsImpzX2JlYXV0aWZ5IiwianNfc291cmNlX3RleHQiLCJvcHRpb25zIiwiYmVhdXRpZmllciIsImJlYXV0aWZ5IiwiZXhwb3J0cyIsImRlZmF1bHRPcHRpb25zIiwiT3V0cHV0IiwiVG9rZW4iLCJhY29ybiIsIlRva2VuaXplciIsImxpbmVfc3RhcnRlcnMiLCJwb3NpdGlvbmFibGVfb3BlcmF0b3JzIiwiVE9LRU4iLCJpbl9hcnJheSIsIndoYXQiLCJhcnIiLCJpbmRleE9mIiwibHRyaW0iLCJzIiwicmVwbGFjZSIsImdlbmVyYXRlTWFwRnJvbVN0cmluZ3MiLCJsaXN0IiwicmVzdWx0IiwieCIsImxlbmd0aCIsInJlc2VydmVkX3dvcmQiLCJ0b2tlbiIsIndvcmQiLCJ0eXBlIiwiUkVTRVJWRUQiLCJ0ZXh0IiwicmVzZXJ2ZWRfYXJyYXkiLCJ3b3JkcyIsInNwZWNpYWxfd29yZHMiLCJ2YWxpZFBvc2l0aW9uVmFsdWVzIiwiT1BFUkFUT1JfUE9TSVRJT04iLCJPUEVSQVRPUl9QT1NJVElPTl9CRUZPUkVfT1JfUFJFU0VSVkUiLCJiZWZvcmVfbmV3bGluZSIsInByZXNlcnZlX25ld2xpbmUiLCJNT0RFIiwiQmxvY2tTdGF0ZW1lbnQiLCJTdGF0ZW1lbnQiLCJPYmplY3RMaXRlcmFsIiwiQXJyYXlMaXRlcmFsIiwiRm9ySW5pdGlhbGl6ZXIiLCJDb25kaXRpb25hbCIsIkV4cHJlc3Npb24iLCJyZW1vdmVfcmVkdW5kYW50X2luZGVudGF0aW9uIiwib3V0cHV0IiwiZnJhbWUiLCJtdWx0aWxpbmVfZnJhbWUiLCJtb2RlIiwicmVtb3ZlX2luZGVudCIsInN0YXJ0X2xpbmVfaW5kZXgiLCJzcGxpdF9saW5lYnJlYWtzIiwiYWxsTGluZUJyZWFrcyIsIm91dCIsImlkeCIsInB1c2giLCJzdWJzdHJpbmciLCJpc19hcnJheSIsImlzX2V4cHJlc3Npb24iLCJhbGxfbGluZXNfc3RhcnRfd2l0aCIsImxpbmVzIiwiYyIsImkiLCJsaW5lIiwidHJpbSIsImNoYXJBdCIsImVhY2hfbGluZV9tYXRjaGVzX2luZGVudCIsImluZGVudCIsImxlbiIsInNvdXJjZV90ZXh0IiwiX3NvdXJjZV90ZXh0IiwiX291dHB1dCIsIl90b2tlbnMiLCJfbGFzdF9sYXN0X3RleHQiLCJfZmxhZ3MiLCJfcHJldmlvdXNfZmxhZ3MiLCJfZmxhZ19zdG9yZSIsIl9vcHRpb25zIiwicHJvdG90eXBlIiwiY3JlYXRlX2ZsYWdzIiwiZmxhZ3NfYmFzZSIsIm5leHRfaW5kZW50X2xldmVsIiwiaW5kZW50YXRpb25fbGV2ZWwiLCJqdXN0X2FkZGVkX25ld2xpbmUiLCJsaW5lX2luZGVudF9sZXZlbCIsIm5leHRfZmxhZ3MiLCJwYXJlbnQiLCJsYXN0X3Rva2VuIiwiU1RBUlRfQkxPQ0siLCJsYXN0X3dvcmQiLCJkZWNsYXJhdGlvbl9zdGF0ZW1lbnQiLCJkZWNsYXJhdGlvbl9hc3NpZ25tZW50IiwiaW5saW5lX2ZyYW1lIiwiaWZfYmxvY2siLCJlbHNlX2Jsb2NrIiwiY2xhc3Nfc3RhcnRfYmxvY2siLCJkb19ibG9jayIsImRvX3doaWxlIiwiaW1wb3J0X2Jsb2NrIiwiaW5fY2FzZV9zdGF0ZW1lbnQiLCJpbl9jYXNlIiwiY2FzZV9ib2R5IiwiY2FzZV9ibG9jayIsImFsaWdubWVudCIsImdldF9saW5lX251bWJlciIsInRlcm5hcnlfZGVwdGgiLCJfcmVzZXQiLCJiYXNlSW5kZW50U3RyaW5nIiwibWF0Y2giLCJyYXciLCJ0ZXN0X291dHB1dF9yYXciLCJzZXRfbW9kZSIsInRva2VuaXplciIsInRva2VuaXplIiwiZGlzYWJsZWQiLCJzd2VldF9jb2RlIiwiZW9sIiwibGluZUJyZWFrIiwidGVzdCIsImN1cnJlbnRfdG9rZW4iLCJuZXh0IiwiaGFuZGxlX3Rva2VuIiwiZ2V0X2NvZGUiLCJwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MiLCJTVEFSVF9FWFBSIiwiaGFuZGxlX3N0YXJ0X2V4cHIiLCJFTkRfRVhQUiIsImhhbmRsZV9lbmRfZXhwciIsImhhbmRsZV9zdGFydF9ibG9jayIsIkVORF9CTE9DSyIsImhhbmRsZV9lbmRfYmxvY2siLCJXT1JEIiwiaGFuZGxlX3dvcmQiLCJTRU1JQ09MT04iLCJoYW5kbGVfc2VtaWNvbG9uIiwiU1RSSU5HIiwiaGFuZGxlX3N0cmluZyIsIkVRVUFMUyIsImhhbmRsZV9lcXVhbHMiLCJPUEVSQVRPUiIsImhhbmRsZV9vcGVyYXRvciIsIkNPTU1BIiwiaGFuZGxlX2NvbW1hIiwiQkxPQ0tfQ09NTUVOVCIsImhhbmRsZV9ibG9ja19jb21tZW50IiwiQ09NTUVOVCIsImhhbmRsZV9jb21tZW50IiwiRE9UIiwiaGFuZGxlX2RvdCIsIkVPRiIsImhhbmRsZV9lb2YiLCJVTktOT1dOIiwiaGFuZGxlX3Vua25vd24iLCJoYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMiLCJuZXdsaW5lcyIsImtlZXBfd2hpdGVzcGFjZSIsImtlZXBfYXJyYXlfaW5kZW50YXRpb24iLCJjb21tZW50c19iZWZvcmUiLCJjb21tZW50X3Rva2VuIiwicHJpbnRfbmV3bGluZSIsIm1heF9wcmVzZXJ2ZV9uZXdsaW5lcyIsInByZXNlcnZlX25ld2xpbmVzIiwiaiIsIm5ld2xpbmVfcmVzdHJpY3RlZF90b2tlbnMiLCJhbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lIiwiZm9yY2VfbGluZXdyYXAiLCJ1bmRlZmluZWQiLCJzaG91bGRQcmVzZXJ2ZU9yRm9yY2UiLCJvcGVyYXRvckxvZ2ljQXBwbGllcyIsInNob3VsZFByaW50T3BlcmF0b3JOZXdsaW5lIiwib3BlcmF0b3JfcG9zaXRpb24iLCJ3cmFwX2xpbmVfbGVuZ3RoIiwic2V0X3dyYXBfcG9pbnQiLCJmb3JjZV9uZXdsaW5lIiwibmV4dF90b2tlbiIsInBlZWsiLCJyZXN0b3JlX21vZGUiLCJhZGRfbmV3X2xpbmUiLCJwcmludF90b2tlbl9saW5lX2luZGVudGF0aW9uIiwiY3VycmVudF9saW5lIiwic2V0X2luZGVudCIsIndoaXRlc3BhY2VfYmVmb3JlIiwic3BhY2VfYmVmb3JlX3Rva2VuIiwicHJpbnRfdG9rZW4iLCJhZGRfcmF3X3Rva2VuIiwiY29tbWFfZmlyc3QiLCJwcmV2aW91cyIsInByZXZpb3VzX2xpbmUiLCJsYXN0IiwicG9wcGVkIiwicG9wIiwiaXNfZW1wdHkiLCJhZGRfdG9rZW4iLCJub25fYnJlYWtpbmdfc3BhY2UiLCJwcmV2aW91c190b2tlbl93cmFwcGVkIiwiZGVpbmRlbnQiLCJzdGFydF9vZl9vYmplY3RfcHJvcGVydHkiLCJzdGFydF9vZl9zdGF0ZW1lbnQiLCJzdGFydCIsIm5leHRfbW9kZSIsInNwYWNlX2luX3BhcmVuIiwic3BhY2VfYmVmb3JlX2NvbmRpdGlvbmFsIiwicGVla19iYWNrX3R3byIsInNwYWNlX2FmdGVyX25hbWVkX2Z1bmN0aW9uIiwicGVla19iYWNrX3RocmVlIiwic3BhY2VfYWZ0ZXJfYW5vbl9mdW5jdGlvbiIsInNwYWNlX2luX2VtcHR5X3BhcmVuIiwic2Vjb25kX3Rva2VuIiwiZW1wdHlfYnJhY2VzIiwiZW1wdHlfYW5vbnltb3VzX2Z1bmN0aW9uIiwiYnJhY2VfcHJlc2VydmVfaW5saW5lIiwiaW5kZXgiLCJjaGVja190b2tlbiIsIm9wZW5lZCIsImJyYWNlX3N0eWxlIiwianNsaW50X2hhcHB5IiwianVzdF9hZGRlZF9ibGFua2xpbmUiLCJwcmVmaXgiLCJzdGFydHNXaXRoIiwiaXNHZW5lcmF0b3JBc3RlcmlzayIsImlzVW5hcnkiLCJzcGFjZV9iZWZvcmUiLCJzcGFjZV9hZnRlciIsImluX3Rlcm5hcnkiLCJpc0NvbG9uIiwiaXNUZXJuYXJ5Q29sb24iLCJpc090aGVyQ29sb24iLCJhZnRlcl9uZXdsaW5lIiwibmV3X2xpbmVfbmVlZGVkIiwiZGlyZWN0aXZlcyIsInByZXNlcnZlIiwibmV3bGluZSIsInByaW50X2Jsb2NrX2NvbW1tZW50IiwiamF2YWRvYyIsInN0YXJsZXNzIiwibGFzdEluZGVudCIsImxhc3RJbmRlbnRMZW5ndGgiLCJzbGljZSIsImJyZWFrX2NoYWluZWRfbWV0aG9kcyIsInVuaW5kZW50X2NoYWluZWRfbWV0aG9kcyIsIk91dHB1dExpbmUiLCJfX3BhcmVudCIsIl9fY2hhcmFjdGVyX2NvdW50IiwiX19pbmRlbnRfY291bnQiLCJfX2FsaWdubWVudF9jb3VudCIsIl9fd3JhcF9wb2ludF9pbmRleCIsIl9fd3JhcF9wb2ludF9jaGFyYWN0ZXJfY291bnQiLCJfX3dyYXBfcG9pbnRfaW5kZW50X2NvdW50IiwiX193cmFwX3BvaW50X2FsaWdubWVudF9jb3VudCIsIl9faXRlbXMiLCJjbG9uZV9lbXB0eSIsIml0ZW0iLCJoYXNfbWF0Y2giLCJwYXR0ZXJuIiwibGFzdENoZWNrZWRPdXRwdXQiLCJnZXRfaW5kZW50X3NpemUiLCJfc2V0X3dyYXBfcG9pbnQiLCJuZXh0X2xpbmUiLCJfc2hvdWxkX3dyYXAiLCJfYWxsb3dfd3JhcCIsInNwbGljZSIsImxhc3RfbmV3bGluZV9pbmRleCIsImxhc3RJbmRleE9mIiwiX3JlbW92ZV9pbmRlbnQiLCJpbmRlbnRfc2l6ZSIsIl9yZW1vdmVfd3JhcF9pbmRlbnQiLCJ0b1N0cmluZyIsImluZGVudF9lbXB0eV9saW5lcyIsImdldF9pbmRlbnRfc3RyaW5nIiwiam9pbiIsIkluZGVudFN0cmluZ0NhY2hlIiwiX19jYWNoZSIsIl9faW5kZW50X3NpemUiLCJfX2luZGVudF9zdHJpbmciLCJpbmRlbnRfY2hhciIsImluZGVudF93aXRoX3RhYnMiLCJBcnJheSIsImluZGVudF9sZXZlbCIsIl9fYmFzZV9zdHJpbmciLCJfX2Jhc2Vfc3RyaW5nX2xlbmd0aCIsImNvbHVtbiIsIl9fZW5zdXJlX2NhY2hlIiwiX19hZGRfY29sdW1uIiwiTWF0aCIsImZsb29yIiwiX19pbmRlbnRfY2FjaGUiLCJfZW5kX3dpdGhfbmV3bGluZSIsImVuZF93aXRoX25ld2xpbmUiLCJfX2xpbmVzIiwiX19hZGRfb3V0cHV0bGluZSIsImxhc3RfaXRlbSIsInByaW50YWJsZV90b2tlbiIsIl9fYWRkX3NwYWNlX2JlZm9yZV90b2tlbiIsIm91dHB1dF9sZW5ndGgiLCJlYXRfbmV3bGluZXMiLCJlbnN1cmVfZW1wdHlfbGluZV9hYm92ZSIsInN0YXJ0c193aXRoIiwiZW5kc193aXRoIiwicG90ZW50aWFsRW1wdHlMaW5lIiwiY2xvc2VkIiwiX191bnVzZWRfd2VicGFja19tb2R1bGUiLCJiYXNlQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyIsImJhc2VBU0NJSWlkZW50aWZpZXJDaGFycyIsIm5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMiLCJub25BU0NJSWlkZW50aWZpZXJDaGFycyIsInVuaWNvZGVFc2NhcGVPckNvZGVQb2ludCIsImlkZW50aWZpZXJTdGFydCIsImlkZW50aWZpZXJDaGFycyIsImlkZW50aWZpZXIiLCJSZWdFeHAiLCJpZGVudGlmaWVyTWF0Y2giLCJub25BU0NJSXdoaXRlc3BhY2UiLCJzb3VyY2UiLCJCYXNlT3B0aW9ucyIsImNhbGwiLCJyYXdfYnJhY2Vfc3R5bGUiLCJyYXdfb3B0aW9ucyIsImJyYWNlc19vbl9vd25fbGluZSIsImJyYWNlX3N0eWxlX3NwbGl0IiwiX2dldF9zZWxlY3Rpb25fbGlzdCIsImJzIiwiX2dldF9ib29sZWFuIiwidW5lc2NhcGVfc3RyaW5ncyIsImU0eCIsIl9nZXRfc2VsZWN0aW9uIiwibWVyZ2VfY2hpbGRfZmllbGQiLCJfbWVyZ2VPcHRzIiwiX2dldF9jaGFyYWN0ZXJzIiwiX2dldF9udW1iZXIiLCJ0ZW1wbGF0aW5nIiwiX2dldF9hcnJheSIsIm5hbWUiLCJkZWZhdWx0X3ZhbHVlIiwib3B0aW9uX3ZhbHVlIiwiY29uY2F0Iiwic3BsaXQiLCJwYXJzZUludCIsImlzTmFOIiwic2VsZWN0aW9uX2xpc3QiLCJFcnJvciIsIl9pc192YWxpZF9zZWxlY3Rpb24iLCJzb21lIiwiYWxsT3B0aW9ucyIsImNoaWxkRmllbGROYW1lIiwiZmluYWxPcHRzIiwiX25vcm1hbGl6ZU9wdHMiLCJjb252ZXJ0ZWRPcHRzIiwia2V5IiwibmV3S2V5Iiwibm9ybWFsaXplT3B0cyIsIm1lcmdlT3B0cyIsIklucHV0U2Nhbm5lciIsIkJhc2VUb2tlbml6ZXIiLCJCQVNFVE9LRU4iLCJEaXJlY3RpdmVzIiwiUGF0dGVybiIsIlRlbXBsYXRhYmxlUGF0dGVybiIsIlNUQVJUIiwiUkFXIiwiZGlyZWN0aXZlc19jb3JlIiwibnVtYmVyX3BhdHRlcm4iLCJkaWdpdCIsImRvdF9wYXR0ZXJuIiwicHVuY3QiLCJwdW5jdF9wYXR0ZXJuIiwicmVzZXJ2ZWRfd29yZHMiLCJyZXNlcnZlZF93b3JkX3BhdHRlcm4iLCJpbl9odG1sX2NvbW1lbnQiLCJpbnB1dF9zdHJpbmciLCJfcGF0dGVybnMiLCJ3aGl0ZXNwYWNlIiwibWF0Y2hpbmciLCJwYXR0ZXJuX3JlYWRlciIsIl9pbnB1dCIsInRlbXBsYXRhYmxlIiwicmVhZF9vcHRpb25zIiwiX19wYXR0ZXJucyIsInRlbXBsYXRlIiwic3RhcnRpbmdfd2l0aCIsIm51bWJlciIsImNvbW1lbnQiLCJ1bnRpbCIsImJsb2NrX2NvbW1lbnQiLCJ1bnRpbF9hZnRlciIsImh0bWxfY29tbWVudF9zdGFydCIsImh0bWxfY29tbWVudF9lbmQiLCJpbmNsdWRlIiwic2hlYmFuZyIsInhtbCIsInNpbmdsZV9xdW90ZSIsImRvdWJsZV9xdW90ZSIsInRlbXBsYXRlX3RleHQiLCJ0ZW1wbGF0ZV9leHByZXNzaW9uIiwiX2lzX2NvbW1lbnQiLCJfaXNfb3BlbmluZyIsIl9pc19jbG9zaW5nIiwib3Blbl90b2tlbiIsIl9nZXRfbmV4dF90b2tlbiIsInByZXZpb3VzX3Rva2VuIiwiX3JlYWRXaGl0ZXNwYWNlIiwiX2NyZWF0ZV90b2tlbiIsIl9yZWFkX25vbl9qYXZhc2NyaXB0IiwiX3JlYWRfc3RyaW5nIiwiX3JlYWRfcGFpciIsIl9yZWFkX3dvcmQiLCJfcmVhZF9zaW5nbGVzIiwiX3JlYWRfY29tbWVudCIsIl9yZWFkX3JlZ2V4cCIsIl9yZWFkX3htbCIsIl9yZWFkX3B1bmN0dWF0aW9uIiwicmVzdWx0aW5nX3N0cmluZyIsInJlYWQiLCJkIiwiX2lzX2ZpcnN0X3Rva2VuIiwic2hhcnAiLCJoYXNOZXh0IiwidGVzdENoYXIiLCJiYWNrIiwiZ2V0X2RpcmVjdGl2ZXMiLCJpZ25vcmUiLCJyZWFkSWdub3JlZCIsImhhc19jaGFyX2VzY2FwZXMiLCJfcmVhZF9zdHJpbmdfcmVjdXJzaXZlIiwidW5lc2NhcGVfc3RyaW5nIiwiX2FsbG93X3JlZ2V4cF9vcl94bWwiLCJlc2MiLCJpbl9jaGFyX2NsYXNzIiwieG1sU3RyIiwicmVhZF9tYXRjaCIsInJvb3RUYWciLCJpc0N1cmx5Um9vdCIsImRlcHRoIiwiaXNFbmRUYWciLCJ0YWdOYW1lIiwiaXNTaW5nbGV0b25UYWciLCJlc2NhcGVkIiwiaW5wdXRfc2NhbiIsIm1hdGNoZWQiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJkZWxpbWl0ZXIiLCJhbGxvd191bmVzY2FwZWRfbmV3bGluZXMiLCJzdGFydF9zdWIiLCJjdXJyZW50X2NoYXIiLCJyZWdleHBfaGFzX3N0aWNreSIsImhhc093blByb3BlcnR5IiwiX19pbnB1dCIsIl9faW5wdXRfbGVuZ3RoIiwiX19wb3NpdGlvbiIsInJlc3RhcnQiLCJ2YWwiLCJfX21hdGNoIiwibGFzdEluZGV4IiwicGF0dGVybl9tYXRjaCIsImV4ZWMiLCJzdGlja3kiLCJzdGFydGluZ19wYXR0ZXJuIiwidW50aWxfcGF0dGVybiIsInJlYWRVbnRpbCIsIm1hdGNoX2luZGV4IiwicmVhZFVudGlsQWZ0ZXIiLCJnZXRfcmVnZXhwIiwibWF0Y2hfZnJvbSIsImZsYWdzIiwiZ2V0X2xpdGVyYWxfcmVnZXhwIiwibGl0ZXJhbF9zdHJpbmciLCJwZWVrVW50aWxBZnRlciIsImxvb2tCYWNrIiwidGVzdFZhbCIsInRvTG93ZXJDYXNlIiwiVG9rZW5TdHJlYW0iLCJXaGl0ZXNwYWNlUGF0dGVybiIsIl9fdG9rZW5zIiwiY3VycmVudCIsIm9wZW5fc3RhY2siLCJjb21tZW50cyIsImFkZCIsImlzRW1wdHkiLCJuZXdsaW5lX2NvdW50Iiwid2hpdGVzcGFjZV9iZWZvcmVfdG9rZW4iLCJwYXJlbnRfdG9rZW4iLCJfX3Rva2Vuc19sZW5ndGgiLCJfX3BhcmVudF90b2tlbiIsImlucHV0X3NjYW5uZXIiLCJfbGluZV9yZWdleHAiLCJfX3NldF93aGl0ZXNwYWNlX3BhdHRlcm5zIiwid2hpdGVzcGFjZV9jaGFycyIsIm5ld2xpbmVfY2hhcnMiLCJfbWF0Y2hfcGF0dGVybiIsIl9uZXdsaW5lX3JlZ2V4cCIsIm1hdGNoZXMiLCJfX3NwbGl0IiwiX2NyZWF0ZSIsIl91cGRhdGUiLCJyZWdleHAiLCJzdGFydF9pbmRleCIsIm5leHRfbWF0Y2giLCJfc3RhcnRpbmdfcGF0dGVybiIsIl91bnRpbF9wYXR0ZXJuIiwiX3VudGlsX2FmdGVyIiwic3RhcnRfYmxvY2tfcGF0dGVybiIsImVuZF9ibG9ja19wYXR0ZXJuIiwiX19kaXJlY3RpdmVzX2Jsb2NrX3BhdHRlcm4iLCJfX2RpcmVjdGl2ZV9wYXR0ZXJuIiwiX19kaXJlY3RpdmVzX2VuZF9pZ25vcmVfcGF0dGVybiIsImRpcmVjdGl2ZV9tYXRjaCIsImlucHV0IiwidGVtcGxhdGVfbmFtZXMiLCJkamFuZ28iLCJlcmIiLCJoYW5kbGViYXJzIiwicGhwIiwic21hcnR5IiwiYW5ndWxhciIsIl9fdGVtcGxhdGVfcGF0dGVybiIsIl9kaXNhYmxlZCIsIk9iamVjdCIsImFzc2lnbiIsIl9leGNsdWRlZCIsImhhbmRsZWJhcnNfY29tbWVudCIsImhhbmRsZWJhcnNfdW5lc2NhcGVkIiwiZGphbmdvX3ZhbHVlIiwiZGphbmdvX2NvbW1lbnQiLCJzbWFydHlfY29tbWVudCIsInNtYXJ0eV9saXRlcmFsIiwiX19zZXRfdGVtcGxhdGVkX3BhdHRlcm4iLCJkaXNhYmxlIiwibGFuZ3VhZ2UiLCJleGNsdWRlIiwiX3JlYWRfdGVtcGxhdGUiLCJpdGVtcyIsInBlZWsxIiwiX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fIiwibW9kdWxlSWQiLCJjYWNoZWRNb2R1bGUiLCJfX3dlYnBhY2tfZXhwb3J0c19fIiwiZGVmaW5lIiwiYW1kIiwid2luZG93IiwiZ2xvYmFsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/js-beautify/js/lib/beautify.js\n");

/***/ })

};
;